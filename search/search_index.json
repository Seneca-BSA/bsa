{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lab Manuals AIG240 Robotics SES250 Elecromagnetics Lab Manual SEH500 Microprocessors and Computer Architecture Lab Manual SEP600 Embedded Systems SEA700 Robotics for Software Engineers","title":"Lab Manuals"},{"location":"#lab-manuals","text":"AIG240 Robotics SES250 Elecromagnetics Lab Manual SEH500 Microprocessors and Computer Architecture Lab Manual SEP600 Embedded Systems SEA700 Robotics for Software Engineers","title":"Lab Manuals"},{"location":"aig240/","text":"AIG240 Lab Manual Labs: Lab 1 : Intro to ROS and TurtleSim Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions Lab 3 : ROS Workspace, Package, Publisher and Subscriber Project 1 [10%] Lab 4 : Robot Model and Gazebo Project 2 [10%] Lab 5 : JetAuto Robot Project 3 [10%] Reference Document: JetAuto User Manual","title":"AIG240 Robotics"},{"location":"aig240/#aig240-lab-manual","text":"Labs: Lab 1 : Intro to ROS and TurtleSim Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions Lab 3 : ROS Workspace, Package, Publisher and Subscriber Project 1 [10%] Lab 4 : Robot Model and Gazebo Project 2 [10%] Lab 5 : JetAuto Robot Project 3 [10%] Reference Document: JetAuto User Manual","title":"AIG240 Lab Manual"},{"location":"aig240/lab1/","text":"Lab 1: Introduction to ROS and TurtleSim Seneca Polytechnic AIG240 Robotics Introduction In this course, you'll be using the JetAuto Pro ROS Robot Car as the base platform for development. The JetAuto robot uses the NVIDIA Jetson Nano embedded computing board as its controller. The robot comes with various accessories and add-ons for robotics applications, all of which can be controlled using the Robot Operating System (ROS) as the core framework. However, before working with the physical robot, we will first learn how to use ROS and Gazebo to simulate the robot and its environment. During the design phase of any robotics project, testing your code and robot functionality in a simulated environment is a crucial part of the development cycle. In some industrial settings (such as robots deployed in remote locations), physical access to the robot may be limited or impossible. In such cases, simulating the robot's actions and performance is the only way to ensure mission success. What is ROS? Per the ROS website: The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it's all open source. The above description may sound abstract, so let\u2019s look at a practical example. Figure 1.1 Robotics Arm (Source: Hiwonder) A robotics system usually consists of various sensors, actuators, and controllers. The system in Figure 1.1 includes the following: A servo gripper at the end of the arm A servo revolute joint that rotates the gripper A servo revolute joint for link 3\u20132 A servo revolute joint for link 4\u20133 A servo revolute joint for link 5\u20134 A servo revolute joint that rotates the base A stationary camera supervising the workspace To pick up an object, the robot might: Use the camera to determine the object's position Command the arm to move to the object's location Once in position, command the gripper to close around the object To achieve this, we break the process into smaller tasks. In robotics, this typically means having independent low-level control loops, each responsible for a single function: A control loop for each joint that, given a position or velocity command, controls the power applied to the joint motor based on position sensor measurements A control loop for the gripper, which turns the gripper motor on and off and adjusts power to avoid crushing objects A sensing loop that reads images from the camera These low-level loops are then coordinated via a high-level supervisory control module: Request an image from the camera sensing loop Use a vision algorithm to calculate the target object's location Calculate joint angles to move the arm to the location Send commands to the joint control loops Signal the gripper control loop to close An important feature of this architecture is modularity: the supervisor need not understand the implementation of any control loop. It communicates with each via simple control messages. This abstraction makes it easier to reuse code across platforms. In ROS, each control loop is implemented as a node \u2014a software process performing a specific task. Nodes communicate by publishing and subscribing to topics or using services (concepts covered later in this lab). Nodes can be written in many languages (including Python and C++), and ROS handles data conversion and message passing seamlessly. We can visualize this system using a computation graph : Figure 1.2 Example computation graph Nodes are shown as ovals (e.g., /usb_cam or /ar_track_alvar ) Topics are shown as rectangles (e.g., /usb_cam/camera_info , /usb_cam/image_raw ) Arrows show the direction of data flow between nodes and topics. For example, /usb_cam publishes to /usb_cam/camera_info and /usb_cam/image_raw , which are subscribed to by /ar_track_alvar Services, not shown here, are represented by dotted arrows Procedures Ubuntu Installation For this course, we'll use Ubuntu 18.04 LTS (Bionic Beaver) . If you're using Windows or macOS, ensure Ubuntu 18.04 is running on a virtual machine, as this matches the JetAuto platform. You can also refer to this Installation Video . Install Ubuntu 18.04 on your computer or virtual machine (VirtualBox recommended). OS Image: ubuntu-18.04.6-desktop-amd64.iso Allocate at least 4 CPU cores, 4 GB RAM, and 20 GB of storage to emulate a Jetson Nano Use the username: jetauto to maintain code compatibility If using an ARM-based laptop, install the ARM64 server image and then manually add a desktop interface On Windows, some students have used wsl to run Ubuntu and ROS Add jetauto User as Sudoer and Install Desktop GUI Run in the Ubuntu Machine Depending on how the Ubuntu OS was installed, your active user jetauto may not have sudoer permission. If that's the case, you'll need to switch to the root user and add jetauto into the sudoer group Open a terminal and switch to the root user: su root Change the jetauto user into the sudoer group: usermod -a -G sudo jetauto Log out then re-login (or restart) to the jetauto user. You may now verify if you have sudo permission by: sudo -v If it gives you a permission error, that means you are not a sudoer yet Now that you are a sudoer, let's perform a system update and upgrade. DO NOT upgrade to Ubuntu 20 or higher when prompted \u2014we need Ubuntu 18: sudo apt update && sudo apt upgrade If you didn't install the desktop version of Ubuntu, install the Ubuntu GNOME desktop (or similar). We need the GUI: sudo apt install ubuntu-gnome-desktop After the install is complete, restart the system: reboot The Ubuntu GNOME desktop should run after the system restart Lastly, ensure you can open a terminal from the GUI. If the terminal fails to start, go to Settings and change the language to \"English (CA)\" and save. You may switch it back afterward. It's a bug with a missing attribute in the Ubuntu desktop ROS Installation Run in the Ubuntu Machine Note: You may also follow the official ROS Melodic Installation instructions to install the ROS Desktop-Full package into your system. You do NOT need to install the Bare Bones or Individual Package Set up your computer to accept software from packages.ros.org. sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Set up your keys If you haven't already installed curl: sudo apt install curl Add the key: curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Now, make sure your system package index is up-to-date: sudo apt update Next, we'll install the full desktop version of ROS with rqt, rviz, robot-generic libraries, 2D/3D simulators and 2D/3D perception, etc.: sudo apt install ros-melodic-desktop-full Later, if you need to install other ROS packages, you can use the following command: sudo apt install ros-melodic-<PACKAGE> e.g. sudo apt install ros-melodic-slam-gmapping . To find available packages, use: apt search ros-melodic Since we want our terminal to load the ROS source every time it starts, add the source command to .bashrc so the ROS environment variables are automatically added to your bash session every time a new shell is launched: echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc Or use vi , vim , or any editor to open ~/.bashrc in your user's home directory then add the following code at the end. source /opt/ros/melodic/setup.bash After ROS installation and setting up .bashrc , we'll also want to install a few tools to help build ROS packages. To install this tool and other dependencies for building ROS packages, run: sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential Before you can use many ROS tools, you will need to initialize rosdep . rosdep enables you to easily install system dependencies for source you want to compile and is required to run some core components in ROS. With the following, you can initialize rosdep . sudo rosdep init rosdep update Since Melodic is no longer a supported distro, we'll need to explicitly update it. rosdep update --rosdistro=melodic Turtlesim Test Turtlesim is a lightweight simulator for learning ROS. It illustrates what ROS does at the most basic level to give you an idea of what you will do with a real robot or a robot simulation later on. Using roscore roscore is the first thing you should run when using ROS. It starts the ROS master node, the centralized server for managing nodes, topics, services, communication, and more. It is typically the main entry point and the first for running any ROS system. In a terminal, run: roscore You will see something similar to: ... logging to ~/.ros/log/9cf88ce4-b14d-11df-8a75-00251148e8cf/roslaunch-machine_name-13039.log Checking log directory for disk usage. This may take awhile. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is <1GB. started roslaunch server http://machine_name:33919/ ros_comm version 1.4.7 SUMMARY ====== PARAMETERS * /rosversion * /rosdistro NODES auto-starting new master process[master]: started with pid [13054] ROS_MASTER_URI=http://machine_name:11311/ setting /run_id to 9cf88ce4-b14d-11df-8a75-00251148e8cf process[rosout-1]: started with pid [13067] started core service [/rosout] Using rosrun The command rosrun allows you to use the package name to directly run a node within a package (without having to know the package path). Usage: rosrun [package_name] [node_name] . So now we can run the turtlesim_node in the turtlesim package. In a new terminal: rosrun turtlesim turtlesim_node The simulator window should appear, with a random turtle in the center. Figure 1.3 TurtleSim Open a new terminal to run a new node to control the turtle in the first node. If you didn't add the source code in .bashrc , you'll need to source ROS again. rosrun turtlesim turtle_teleop_key At this point you should have four windows open: a terminal running roscore , a terminal running turtlesim_node , a terminal running turtle_teleop_key , and the \"turtlesim window\". Arrange these windows so that you can see the turtlesim window but also have the terminal running turtle_teleop_key active so that you can control the turtle in turtlesim. Use the arrow keys on your keyboard to control the turtle. It will move around the screen, using its attached \u201cpen\u201d to draw the path it followed so far. Figure 1.4 TurtleSim Use rqt rqt is a graphical user interface (GUI) tool for ROS. Everything done in rqt can be done on the command line, but rqt provides a more user-friendly way to manipulate ROS elements. Open a new terminal and run rqt. rqt When running rqt for the first time, the window will be blank. No worries; just select Plugins > Services > Service Caller from the menu bar at the top. Figure 1.5 rqt Use the refresh button to the left of the Service dropdown list to ensure all the services of your turtlesim node are available. Click on the Service dropdown list to see turtlesim\u2019s services and select the /spawn service to spawn another turtle. Give the new turtle a unique name, like turtle2 , by double-clicking between the empty single quotes in the Expression column. You can see that this expression corresponds to the value of name and is of type string . Next, enter some valid coordinates at which to spawn the new turtle, like x = 1.0 and y = 1.0 . Figure 1.5 rqt spawn If you try to spawn a new turtle with the same name as an existing turtle, you will get an error message in the terminal running turtlesim_node . Call the spawn service by clicking the Call button on the upper right side of the rqt window. You should see a new turtle (with a random design) spawn at the coordinates you input for x and y. Refresh the service list in rqt and you will also see that now there are services related to the new turtle, /turtle2/... , in addition to /turtle1/... . Next, we'll give turtle1 a unique pen using the /set_pen service and have turtle1 draw with a distinct red line by changing the value of r to 255 , and the value of width to 5 . Don\u2019t forget to call the service after updating the values. Figure 1.6 rqt set_pen Return to the terminal where turtle_teleop_key is running and press the arrow keys, you will see turtle1 \u2019s pen has changed. Figure 1.7 TurtleSim Turtles Remapping turtle_teleop_key To control turtle2 , you need a second teleop node. However, if you try to run the same command as before, you will notice that this one also controls turtle1 . The way to change this behavior is by remapping the cmd_vel topic and provide a new name for the node. In a new terminal, source ROS, and run: rosrun turtlesim turtle_teleop_key turtle1/cmd_vel:=turtle2/cmd_vel __name:=teleop_turtle2 Now, you can move turtle2 when this terminal is active, and turtle1 when the other terminal running turtle_teleop_key is active. Figure 1.8 TurtleSim Turtles Lab Exercise Create a third turtle that you can control in turtlesim with green (g = 255) as the pen line colour. Reference ROS Tutorials EECS 106A Labs","title":"Lab 1: Introduction to ROS and TurtleSim"},{"location":"aig240/lab1/#lab-1-introduction-to-ros-and-turtlesim","text":"Seneca Polytechnic AIG240 Robotics","title":"Lab 1: Introduction to ROS and TurtleSim"},{"location":"aig240/lab1/#introduction","text":"In this course, you'll be using the JetAuto Pro ROS Robot Car as the base platform for development. The JetAuto robot uses the NVIDIA Jetson Nano embedded computing board as its controller. The robot comes with various accessories and add-ons for robotics applications, all of which can be controlled using the Robot Operating System (ROS) as the core framework. However, before working with the physical robot, we will first learn how to use ROS and Gazebo to simulate the robot and its environment. During the design phase of any robotics project, testing your code and robot functionality in a simulated environment is a crucial part of the development cycle. In some industrial settings (such as robots deployed in remote locations), physical access to the robot may be limited or impossible. In such cases, simulating the robot's actions and performance is the only way to ensure mission success.","title":"Introduction"},{"location":"aig240/lab1/#what-is-ros","text":"Per the ROS website: The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it's all open source. The above description may sound abstract, so let\u2019s look at a practical example. Figure 1.1 Robotics Arm (Source: Hiwonder) A robotics system usually consists of various sensors, actuators, and controllers. The system in Figure 1.1 includes the following: A servo gripper at the end of the arm A servo revolute joint that rotates the gripper A servo revolute joint for link 3\u20132 A servo revolute joint for link 4\u20133 A servo revolute joint for link 5\u20134 A servo revolute joint that rotates the base A stationary camera supervising the workspace To pick up an object, the robot might: Use the camera to determine the object's position Command the arm to move to the object's location Once in position, command the gripper to close around the object To achieve this, we break the process into smaller tasks. In robotics, this typically means having independent low-level control loops, each responsible for a single function: A control loop for each joint that, given a position or velocity command, controls the power applied to the joint motor based on position sensor measurements A control loop for the gripper, which turns the gripper motor on and off and adjusts power to avoid crushing objects A sensing loop that reads images from the camera These low-level loops are then coordinated via a high-level supervisory control module: Request an image from the camera sensing loop Use a vision algorithm to calculate the target object's location Calculate joint angles to move the arm to the location Send commands to the joint control loops Signal the gripper control loop to close An important feature of this architecture is modularity: the supervisor need not understand the implementation of any control loop. It communicates with each via simple control messages. This abstraction makes it easier to reuse code across platforms. In ROS, each control loop is implemented as a node \u2014a software process performing a specific task. Nodes communicate by publishing and subscribing to topics or using services (concepts covered later in this lab). Nodes can be written in many languages (including Python and C++), and ROS handles data conversion and message passing seamlessly. We can visualize this system using a computation graph : Figure 1.2 Example computation graph Nodes are shown as ovals (e.g., /usb_cam or /ar_track_alvar ) Topics are shown as rectangles (e.g., /usb_cam/camera_info , /usb_cam/image_raw ) Arrows show the direction of data flow between nodes and topics. For example, /usb_cam publishes to /usb_cam/camera_info and /usb_cam/image_raw , which are subscribed to by /ar_track_alvar Services, not shown here, are represented by dotted arrows","title":"What is ROS?"},{"location":"aig240/lab1/#procedures","text":"","title":"Procedures"},{"location":"aig240/lab1/#ubuntu-installation","text":"For this course, we'll use Ubuntu 18.04 LTS (Bionic Beaver) . If you're using Windows or macOS, ensure Ubuntu 18.04 is running on a virtual machine, as this matches the JetAuto platform. You can also refer to this Installation Video . Install Ubuntu 18.04 on your computer or virtual machine (VirtualBox recommended). OS Image: ubuntu-18.04.6-desktop-amd64.iso Allocate at least 4 CPU cores, 4 GB RAM, and 20 GB of storage to emulate a Jetson Nano Use the username: jetauto to maintain code compatibility If using an ARM-based laptop, install the ARM64 server image and then manually add a desktop interface On Windows, some students have used wsl to run Ubuntu and ROS","title":"Ubuntu Installation"},{"location":"aig240/lab1/#add-jetauto-user-as-sudoer-and-install-desktop-gui","text":"Run in the Ubuntu Machine Depending on how the Ubuntu OS was installed, your active user jetauto may not have sudoer permission. If that's the case, you'll need to switch to the root user and add jetauto into the sudoer group Open a terminal and switch to the root user: su root Change the jetauto user into the sudoer group: usermod -a -G sudo jetauto Log out then re-login (or restart) to the jetauto user. You may now verify if you have sudo permission by: sudo -v If it gives you a permission error, that means you are not a sudoer yet Now that you are a sudoer, let's perform a system update and upgrade. DO NOT upgrade to Ubuntu 20 or higher when prompted \u2014we need Ubuntu 18: sudo apt update && sudo apt upgrade If you didn't install the desktop version of Ubuntu, install the Ubuntu GNOME desktop (or similar). We need the GUI: sudo apt install ubuntu-gnome-desktop After the install is complete, restart the system: reboot The Ubuntu GNOME desktop should run after the system restart Lastly, ensure you can open a terminal from the GUI. If the terminal fails to start, go to Settings and change the language to \"English (CA)\" and save. You may switch it back afterward. It's a bug with a missing attribute in the Ubuntu desktop","title":"Add jetauto User as Sudoer and Install Desktop GUI"},{"location":"aig240/lab1/#ros-installation","text":"Run in the Ubuntu Machine Note: You may also follow the official ROS Melodic Installation instructions to install the ROS Desktop-Full package into your system. You do NOT need to install the Bare Bones or Individual Package Set up your computer to accept software from packages.ros.org. sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Set up your keys If you haven't already installed curl: sudo apt install curl Add the key: curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Now, make sure your system package index is up-to-date: sudo apt update Next, we'll install the full desktop version of ROS with rqt, rviz, robot-generic libraries, 2D/3D simulators and 2D/3D perception, etc.: sudo apt install ros-melodic-desktop-full Later, if you need to install other ROS packages, you can use the following command: sudo apt install ros-melodic-<PACKAGE> e.g. sudo apt install ros-melodic-slam-gmapping . To find available packages, use: apt search ros-melodic Since we want our terminal to load the ROS source every time it starts, add the source command to .bashrc so the ROS environment variables are automatically added to your bash session every time a new shell is launched: echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc Or use vi , vim , or any editor to open ~/.bashrc in your user's home directory then add the following code at the end. source /opt/ros/melodic/setup.bash After ROS installation and setting up .bashrc , we'll also want to install a few tools to help build ROS packages. To install this tool and other dependencies for building ROS packages, run: sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential Before you can use many ROS tools, you will need to initialize rosdep . rosdep enables you to easily install system dependencies for source you want to compile and is required to run some core components in ROS. With the following, you can initialize rosdep . sudo rosdep init rosdep update Since Melodic is no longer a supported distro, we'll need to explicitly update it. rosdep update --rosdistro=melodic","title":"ROS Installation"},{"location":"aig240/lab1/#turtlesim-test","text":"Turtlesim is a lightweight simulator for learning ROS. It illustrates what ROS does at the most basic level to give you an idea of what you will do with a real robot or a robot simulation later on.","title":"Turtlesim Test"},{"location":"aig240/lab1/#using-roscore","text":"roscore is the first thing you should run when using ROS. It starts the ROS master node, the centralized server for managing nodes, topics, services, communication, and more. It is typically the main entry point and the first for running any ROS system. In a terminal, run: roscore You will see something similar to: ... logging to ~/.ros/log/9cf88ce4-b14d-11df-8a75-00251148e8cf/roslaunch-machine_name-13039.log Checking log directory for disk usage. This may take awhile. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is <1GB. started roslaunch server http://machine_name:33919/ ros_comm version 1.4.7 SUMMARY ====== PARAMETERS * /rosversion * /rosdistro NODES auto-starting new master process[master]: started with pid [13054] ROS_MASTER_URI=http://machine_name:11311/ setting /run_id to 9cf88ce4-b14d-11df-8a75-00251148e8cf process[rosout-1]: started with pid [13067] started core service [/rosout]","title":"Using roscore"},{"location":"aig240/lab1/#using-rosrun","text":"The command rosrun allows you to use the package name to directly run a node within a package (without having to know the package path). Usage: rosrun [package_name] [node_name] . So now we can run the turtlesim_node in the turtlesim package. In a new terminal: rosrun turtlesim turtlesim_node The simulator window should appear, with a random turtle in the center. Figure 1.3 TurtleSim Open a new terminal to run a new node to control the turtle in the first node. If you didn't add the source code in .bashrc , you'll need to source ROS again. rosrun turtlesim turtle_teleop_key At this point you should have four windows open: a terminal running roscore , a terminal running turtlesim_node , a terminal running turtle_teleop_key , and the \"turtlesim window\". Arrange these windows so that you can see the turtlesim window but also have the terminal running turtle_teleop_key active so that you can control the turtle in turtlesim. Use the arrow keys on your keyboard to control the turtle. It will move around the screen, using its attached \u201cpen\u201d to draw the path it followed so far. Figure 1.4 TurtleSim","title":"Using rosrun"},{"location":"aig240/lab1/#use-rqt","text":"rqt is a graphical user interface (GUI) tool for ROS. Everything done in rqt can be done on the command line, but rqt provides a more user-friendly way to manipulate ROS elements. Open a new terminal and run rqt. rqt When running rqt for the first time, the window will be blank. No worries; just select Plugins > Services > Service Caller from the menu bar at the top. Figure 1.5 rqt Use the refresh button to the left of the Service dropdown list to ensure all the services of your turtlesim node are available. Click on the Service dropdown list to see turtlesim\u2019s services and select the /spawn service to spawn another turtle. Give the new turtle a unique name, like turtle2 , by double-clicking between the empty single quotes in the Expression column. You can see that this expression corresponds to the value of name and is of type string . Next, enter some valid coordinates at which to spawn the new turtle, like x = 1.0 and y = 1.0 . Figure 1.5 rqt spawn If you try to spawn a new turtle with the same name as an existing turtle, you will get an error message in the terminal running turtlesim_node . Call the spawn service by clicking the Call button on the upper right side of the rqt window. You should see a new turtle (with a random design) spawn at the coordinates you input for x and y. Refresh the service list in rqt and you will also see that now there are services related to the new turtle, /turtle2/... , in addition to /turtle1/... . Next, we'll give turtle1 a unique pen using the /set_pen service and have turtle1 draw with a distinct red line by changing the value of r to 255 , and the value of width to 5 . Don\u2019t forget to call the service after updating the values. Figure 1.6 rqt set_pen Return to the terminal where turtle_teleop_key is running and press the arrow keys, you will see turtle1 \u2019s pen has changed. Figure 1.7 TurtleSim Turtles","title":"Use rqt"},{"location":"aig240/lab1/#remapping-turtle_teleop_key","text":"To control turtle2 , you need a second teleop node. However, if you try to run the same command as before, you will notice that this one also controls turtle1 . The way to change this behavior is by remapping the cmd_vel topic and provide a new name for the node. In a new terminal, source ROS, and run: rosrun turtlesim turtle_teleop_key turtle1/cmd_vel:=turtle2/cmd_vel __name:=teleop_turtle2 Now, you can move turtle2 when this terminal is active, and turtle1 when the other terminal running turtle_teleop_key is active. Figure 1.8 TurtleSim Turtles","title":"Remapping turtle_teleop_key"},{"location":"aig240/lab1/#lab-exercise","text":"Create a third turtle that you can control in turtlesim with green (g = 255) as the pen line colour.","title":"Lab Exercise"},{"location":"aig240/lab1/#reference","text":"ROS Tutorials EECS 106A Labs","title":"Reference"},{"location":"aig240/lab2/","text":"Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions Seneca Polytechnic AIG240 Robotics Introduction An overview of some computation graph concepts: Node: an executable representing an individual ROS software process Topic: nodes can publish messages to a topic and/or subscribe to a topic to receive messages Message: a ROS datatype used to exchange data between nodes Nodes in ROS Each node in ROS should be responsible for a single, modular purpose, i.e., controlling the wheel motors or publishing the sensor data from a laser range-finder. Each node can send and receive data from other nodes via topics, services, actions, or parameters. A full robotic system is comprised of many nodes working in concert. Figure 2.1 ROS Nodes Graph Topics in ROS ROS breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages. Figure 2.2 ROS Topic Graph A node may publish data to any number of topics and simultaneously have subscriptions to any number of topics. Figure 2.3 ROS Topic Graph (One-to-Many) Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system. Service in ROS Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model versus the publisher-subscriber model of topics. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. Figure 2.4 ROS Service Single Node Figure 2.5 ROS Service Multiple Node Parameter in ROS A parameter is a configuration value of a node. You can think of parameters as node settings. A node can store parameters as integers, floats, booleans, strings, and lists. In ROS, each node maintains its own parameters. Procedures Understanding ROS Nodes Open a terminal to run ROS using roscore and another terminal to run turtlesim. The command rosrun [package_name] [node_name] launches an executable from a package. We need the package name to be turtlesim and the executable name to be turtlesim_node . roscore Then, in a new terminal: rosrun turtlesim turtlesim_node To find the node names, the rosnode list can be used. rosnode list will show you the names of all running nodes. This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them. Open a new terminal while /rosout and /turtlesim is still running and enter the following command: rosnode list The terminal will return the node name: /rosout /turtlesim Open another new terminal and start the teleop node with the command: rosrun turtlesim turtle_teleop_key Return to the terminal where you ran rosnode list and run it again. You will now see the names of three active nodes: /rosout /turtlesim /teleop_turtle Remapping allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values. Let\u2019s open another /turtlesim node and reassign the name to /my_turtle . In a new terminal, run the following command: rosrun turtlesim turtlesim_node __name:=my_turtle Return to the terminal where you ran rosnode list , and run it again, you will see four node names: /my_turtle /rosout /turtlesim /teleop_turtle To access more information about a node, use the following command: rosnode info [node_name] . To examine your latest node, my_turtle , run the following command: rosnode info /my_turtle rosnode info returns a list of subscribers, publishers, services, and actions. i.e. the ROS graph connections that interact with that node. The output should look like this: -------------------------------------------------------------------------------- Node [/my_turtle] Publications: * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose] Subscriptions: * /turtle1/cmd_vel [geometry_msgs/Twist] Services: * /clear * /kill * /my_turtle/get_loggers * /my_turtle/set_logger_level * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative Run the same command on the /teleop_turtle node and see the difference. Understanding ROS Topics Close the /my_turtle terminal so only the /turtlesim and /teleop_turtle are open. We will use rqt_graph to visualize the changing nodes and topics, as well as the connections between them. Open a new terminal and enter the command: rqt_graph You can also open rqt_graph by opening rqt and selecting Plugins > Introspection > Node Graph . Figure 2.6 ROS rqt_graph You should see the above nodes and topics, as well as two actions around the periphery of the graph (let\u2019s ignore those for now). If you don't see the nodes and topics, click the refresh button. If you hover your mouse over the topic in the center, you\u2019ll see the colour highlighting like in the image above. The graph shows how the /turtlesim node and the /teleop_turtle node are communicating with each other over a topic. The /teleop_turtle node is publishing data (the keystrokes you enter to move the turtle around) to the /turtle1/cmd_vel topic, and the /turtlesim node is subscribed to that topic to receive the data. The highlighting feature of rqt_graph is very helpful when examining more complex systems with many nodes and topics connected in many different ways. rqt_graph is a graphical introspection tool. Now we\u2019ll look at some command line tools for introspecting topics. Open another terminal and run the rostopic list command to return a list of all the topics currently active in the system: /rosout /rosout_agg /statistics /turtle1/cmd_vel /turtle1/color_sensor /turtle1/pose Running the code with an additional argument rostopic list -v will return more details on the topics with the topic type appended in brackets: Published topics: * /turtle1/color_sensor [turtlesim/Color] 2 publishers * /turtle1/cmd_vel [geometry_msgs/Twist] 1 publisher * /rosout [rosgraph_msgs/Log] 4 publishers * /rosout_agg [rosgraph_msgs/Log] 1 publisher * /turtle1/pose [turtlesim/Pose] 2 publishers Subscribed topics: * /turtle1/cmd_vel [geometry_msgs/Twist] 2 subscribers * /rosout [rosgraph_msgs/Log] 1 subscriber * /statistics [rosgraph_msgs/TopicStatistics] 1 subscriber These attributes, particularly the type, are how nodes know they\u2019re talking about the same information as it moves over topics. If you\u2019re wondering where all these topics are in rqt_graph , you can uncheck all the boxes under Hide : Figure 2.7 ROS rqt_graph with everything unhidden To see the data being published on a topic, use: rostopic echo [topic] . Since we know that /teleop_turtle publishes data to /turtlesim over the /turtle1/cmd_vel topic, let\u2019s use echo to introspect that topic: rostopic echo /turtle1/cmd_vel Return to the terminal where turtle_teleop_key is running and use the arrows to move the turtle around. Watch the terminal where your echo is running at the same time, and you\u2019ll see position data being published for every movement you make: linear: x: 2.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.0 --- Return to rqt_graph and unhide the Debug box, hide everything else, then refresh. Figure 2.8 ROS rqt_graph with debug node A new node /rostopic_XXXXX is created by the echo command we just ran (the number might be different). Now you can see that the publisher is publishing data over the cmd_vel topic, and two subscribers are subscribed to it (the two arrows with /turtle/cmd_vel ). Nodes send data over topics using messages. Publishers and subscribers must send and receive the same type of message to communicate. The topic types we saw earlier after running rostopic list -v let us know what message type is used on each topic. Recall that the cmd_vel topic has the type geometry_msgs/Twist . This means that in the package geometry_msgs there is a type called Twist . Alternatively, We can run rostopic type [topic] to see the topic type. We can also run rosmsg show [msg type] on the type to learn its details. Specifically, what structure of data the message expects. rostopic type /turtle1/cmd_vel You should get: geometry_msgs/Twist Look at the details of the message using rosmsg : rosmsg show geometry_msgs/Twist For the message type from above, you should see: geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z This tells you that the /turtlesim node is expecting a message with two vectors, linear and angular , of three elements each. If you recall the data we saw /teleop_turtle passing to /turtlesim with the echo command earlier. Now that you have the message structure, you can publish data to a topic directly from the command line using: rostopic pub [topic] [msg_type] [args] . The [args] argument is the actual data you\u2019ll pass to the topic, in the structure you just discovered in the previous section. It\u2019s important to note that this argument needs to be input in YAML syntax. Input the full command like so: rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' --once is an optional argument meaning \u201cpublish one message then exit\u201d. You will see your turtle move like so: Figure 2.9 The turtle starts moving in a circle This is a pretty complicated example, so lets look at each argument in detail. This command will publish messages to a given topic: rostopic pub This option (dash-one) causes rostopic to only publish one message then exit: -1 This is the name of the topic to publish to: /turtle1/cmd_vel This is the message type to use when publishing to the topic: geometry_msgs/Twist This option (double-dash) tells the option parser that none of the following arguments is an option. This is required in cases where your arguments have a leading dash -, like negative numbers. -- As noted before, a geometry_msgs/Twist msg has two vectors of three floating point elements each: linear and angular . In this case, '[2.0, 0.0, 0.0]' becomes the linear value with x=2.0 , y=0.0 , and z=0.0 , and '[0.0, 0.0, 1.8]' is the angular value with x=0.0 , y=0.0 , and z=1.8 . These arguments are actually in YAML syntax, which is described more in the YAML command line documentation . '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' In order to continuously operate the turtle (and commonly a real robot which it is meant to emulate) require a steady stream of commands. So, to get the turtle to keep moving, you can run: rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' The difference here is the removal of the -1 (for --once ) option and the addition of the -r 1 (for --rate 1 ) option, which tells rostopic pub to publish the command in a steady stream at 1 Hz. Figure 2.10 The turtle moving in a circle Refresh rqt_graph to see what\u2019s happening graphically. You will see a new rostopic pub ... node ( /rostopic_3330 in the figure) is publishing over the /turtle1/cmd_vel topic, which is being received by both the rostopic echo ... node ( /rostopic_3663 in the figure) and the /turtlesim node now. Figure 2.11 ROS rqt_graph of turtle moving in a circle Next, in a new terminal, run echo on the pose topic and recheck rqt_graph : rosopic echo /turtle1/pose Figure 2.12 ROS rqt_graph of turtle moving in a circle with pose You can see that the /turtlesim node is also publishing to the pose topic, which the new echo node has subscribed to. Understanding ROS Services Leave roscore , rosrun turtlesim turtlesim_node and rosrun turtlesim turtle_teleop_key open and close all the other terminal. Open a new terminal and run the rosservice list command to return a list of all the services currently active in the system: /clear /kill /reset /rosout/get_loggers /rosout/set_logger_level /spawn /teleop_turtle/get_loggers /teleop_turtle/set_logger_level /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/get_loggers /turtlesim/set_logger_level Let's look more closely at the turtlesim-specific services, /clear , /kill , /reset , /spawn , /turtle1/set_pen , /turtle1/teleport_absolute , and /turtle1/teleport_relative . You may recall interacting with some of these services using rqt. Services have types that describe how the request and response data of a service is structured. Service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response. To find out the type of a service, use the command: rosservice type [service] Let\u2019s take a look at turtlesim\u2019s /clear service. In a new terminal, enter the command: rosservice type /clear Which should return: std_srvs/Empty The std_srvs/Empty type means the service call sends no data when making a request and receives no data when receiving a response. If you want to find all the services of a specific type, you can use the command: rosservice find [type_name] . For example, you can find all the Empty typed services like this: rosservice find std_srvs/Empty Which will return: /clear /reset You can call services from the command line, but first you need to know the structure of the input arguments by using rossrv show [type_name] . Try this on the /clear service\u2019s type, std_srvs/Empty : rossrv show std_srvs/Empty Which will return: --- The --- separates the request structure (above) from the response structure (below). But, as you learned earlier, the std_srvs/Empty type doesn\u2019t send or receive any data. So, naturally, its structure is blank. Let\u2019s introspect a service with a type that sends and receives data, like /spawn . From the results of rosservice type /spawn , we know /spawn \u2019s type is turtlesim/Spawn . To see the request and response arguments of the /spawn service, we can pass the return value of the rosservice command to the rossrv command by running the command: rosservice type /spawn | rossrv show Which will return: float32 x float32 y float32 theta string name --- string name The information above the --- line tells us the arguments needed to call /spawn . x , y and theta determine the 2D pose of the spawned turtle, and name is optional. The information below the --- line isn\u2019t something you need to know in this case, but it can help you understand the data type of the response you get from the call. Now that you know what a service type is, how to find a service\u2019s type, and how to find the structure of that type\u2019s arguments, you can call a service using: rosservice call [service_name] [service_type] [arguments] . The [arguments] part is optional. For example, you know that Empty typed services don\u2019t have any arguments: rosservice call /clear This command will clear the turtlesim window of any lines your turtle has drawn. Figure 2.13 Turtlesim with line Figure 2.14 Turtlesim cleared Now let\u2019s spawn a new turtle by calling /spawn and setting arguments. Input [arguments] in a service call from the command-line need to be in YAML syntax. Enter the command: rosservice call /spawn 2 2 0.2 \"\" You will get this service response: name: turtle2 Your turtlesim window will update with the newly spawned turtle right away: Figure 2.15 Turtlesim Spawn Understanding ROS Parameters rosparam allows you to store and manipulate data on the ROS Parameter Server . The Parameter Server can store integers, floats, boolean, dictionaries, and lists. rosparam uses the YAML markup language for syntax. In simple cases, YAML looks very natural: 1 is an integer, 1.0 is a float, one is a string, true is a boolean, [1, 2, 3] is a list of integers, and {a: b, c: d} is a dictionary. rosparam has many commands that can be used on parameters, as shown below: Usage: rosparam set set parameter rosparam get get parameter rosparam load load parameters from file rosparam dump dump parameters to file rosparam delete delete parameter rosparam list list parameter names To see the parameters belonging to your nodes, enter the command: rosparam list You will see the node namespaces, /teleop_turtle and /turtlesim , followed by each node\u2019s parameters: /rosdistro /roslaunch/uris/host_ubuntu_18__37467 /rosversion /run_id /turtlesim/background_b /turtlesim/background_g /turtlesim/background_r Based on their names, it looks like /turtlesim \u2019s parameters determine the background color of the turtlesim window using RGB color values. To display the type and current value of a parameter, use the command: rosparam get [param_name] . Let\u2019s find out the current value of /turtlesim \u2019s parameter background_g : rosparam get /turtlesim/background_g Which will return the value: 86 Now you know background_g holds an integer value. If you run the same command on background_r and background_b , you will get the values 69 and 255 , respectively. To change a parameter\u2019s value at runtime, use the command: rosparam set [param_name] . Let\u2019s change /turtlesim \u2019s background color: rosparam set /turtlesim/background_r 150 This changes the parameter value, now we have to call the clear service for the parameter change to take effect: rosservice call /clear And the background of your turtlesim window should change colors: Figure 2.16 Turtlesim Purple Lab Exercise Change the background of turtlesim to orange or cyan. Create another turtle into turtlesim . Command the first turtle to move in a large circle in the clockwise direction continuously. At the same time as the first turtle is moving, command the second turtle to move in a smaller circle in the counter-clockwise direction for one full circle only. Reference ROS Tutorials EECS 106A Labs","title":"Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions"},{"location":"aig240/lab2/#lab-2-ros-nodes-topics-services-parameters-actions","text":"Seneca Polytechnic AIG240 Robotics","title":"Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions"},{"location":"aig240/lab2/#introduction","text":"An overview of some computation graph concepts: Node: an executable representing an individual ROS software process Topic: nodes can publish messages to a topic and/or subscribe to a topic to receive messages Message: a ROS datatype used to exchange data between nodes","title":"Introduction"},{"location":"aig240/lab2/#nodes-in-ros","text":"Each node in ROS should be responsible for a single, modular purpose, i.e., controlling the wheel motors or publishing the sensor data from a laser range-finder. Each node can send and receive data from other nodes via topics, services, actions, or parameters. A full robotic system is comprised of many nodes working in concert. Figure 2.1 ROS Nodes Graph","title":"Nodes in ROS"},{"location":"aig240/lab2/#topics-in-ros","text":"ROS breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages. Figure 2.2 ROS Topic Graph A node may publish data to any number of topics and simultaneously have subscriptions to any number of topics. Figure 2.3 ROS Topic Graph (One-to-Many) Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system.","title":"Topics in ROS"},{"location":"aig240/lab2/#service-in-ros","text":"Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model versus the publisher-subscriber model of topics. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. Figure 2.4 ROS Service Single Node Figure 2.5 ROS Service Multiple Node","title":"Service in ROS"},{"location":"aig240/lab2/#parameter-in-ros","text":"A parameter is a configuration value of a node. You can think of parameters as node settings. A node can store parameters as integers, floats, booleans, strings, and lists. In ROS, each node maintains its own parameters.","title":"Parameter in ROS"},{"location":"aig240/lab2/#procedures","text":"","title":"Procedures"},{"location":"aig240/lab2/#understanding-ros-nodes","text":"Open a terminal to run ROS using roscore and another terminal to run turtlesim. The command rosrun [package_name] [node_name] launches an executable from a package. We need the package name to be turtlesim and the executable name to be turtlesim_node . roscore Then, in a new terminal: rosrun turtlesim turtlesim_node To find the node names, the rosnode list can be used. rosnode list will show you the names of all running nodes. This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them. Open a new terminal while /rosout and /turtlesim is still running and enter the following command: rosnode list The terminal will return the node name: /rosout /turtlesim Open another new terminal and start the teleop node with the command: rosrun turtlesim turtle_teleop_key Return to the terminal where you ran rosnode list and run it again. You will now see the names of three active nodes: /rosout /turtlesim /teleop_turtle Remapping allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values. Let\u2019s open another /turtlesim node and reassign the name to /my_turtle . In a new terminal, run the following command: rosrun turtlesim turtlesim_node __name:=my_turtle Return to the terminal where you ran rosnode list , and run it again, you will see four node names: /my_turtle /rosout /turtlesim /teleop_turtle To access more information about a node, use the following command: rosnode info [node_name] . To examine your latest node, my_turtle , run the following command: rosnode info /my_turtle rosnode info returns a list of subscribers, publishers, services, and actions. i.e. the ROS graph connections that interact with that node. The output should look like this: -------------------------------------------------------------------------------- Node [/my_turtle] Publications: * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose] Subscriptions: * /turtle1/cmd_vel [geometry_msgs/Twist] Services: * /clear * /kill * /my_turtle/get_loggers * /my_turtle/set_logger_level * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative Run the same command on the /teleop_turtle node and see the difference.","title":"Understanding ROS Nodes"},{"location":"aig240/lab2/#understanding-ros-topics","text":"Close the /my_turtle terminal so only the /turtlesim and /teleop_turtle are open. We will use rqt_graph to visualize the changing nodes and topics, as well as the connections between them. Open a new terminal and enter the command: rqt_graph You can also open rqt_graph by opening rqt and selecting Plugins > Introspection > Node Graph . Figure 2.6 ROS rqt_graph You should see the above nodes and topics, as well as two actions around the periphery of the graph (let\u2019s ignore those for now). If you don't see the nodes and topics, click the refresh button. If you hover your mouse over the topic in the center, you\u2019ll see the colour highlighting like in the image above. The graph shows how the /turtlesim node and the /teleop_turtle node are communicating with each other over a topic. The /teleop_turtle node is publishing data (the keystrokes you enter to move the turtle around) to the /turtle1/cmd_vel topic, and the /turtlesim node is subscribed to that topic to receive the data. The highlighting feature of rqt_graph is very helpful when examining more complex systems with many nodes and topics connected in many different ways. rqt_graph is a graphical introspection tool. Now we\u2019ll look at some command line tools for introspecting topics. Open another terminal and run the rostopic list command to return a list of all the topics currently active in the system: /rosout /rosout_agg /statistics /turtle1/cmd_vel /turtle1/color_sensor /turtle1/pose Running the code with an additional argument rostopic list -v will return more details on the topics with the topic type appended in brackets: Published topics: * /turtle1/color_sensor [turtlesim/Color] 2 publishers * /turtle1/cmd_vel [geometry_msgs/Twist] 1 publisher * /rosout [rosgraph_msgs/Log] 4 publishers * /rosout_agg [rosgraph_msgs/Log] 1 publisher * /turtle1/pose [turtlesim/Pose] 2 publishers Subscribed topics: * /turtle1/cmd_vel [geometry_msgs/Twist] 2 subscribers * /rosout [rosgraph_msgs/Log] 1 subscriber * /statistics [rosgraph_msgs/TopicStatistics] 1 subscriber These attributes, particularly the type, are how nodes know they\u2019re talking about the same information as it moves over topics. If you\u2019re wondering where all these topics are in rqt_graph , you can uncheck all the boxes under Hide : Figure 2.7 ROS rqt_graph with everything unhidden To see the data being published on a topic, use: rostopic echo [topic] . Since we know that /teleop_turtle publishes data to /turtlesim over the /turtle1/cmd_vel topic, let\u2019s use echo to introspect that topic: rostopic echo /turtle1/cmd_vel Return to the terminal where turtle_teleop_key is running and use the arrows to move the turtle around. Watch the terminal where your echo is running at the same time, and you\u2019ll see position data being published for every movement you make: linear: x: 2.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.0 --- Return to rqt_graph and unhide the Debug box, hide everything else, then refresh. Figure 2.8 ROS rqt_graph with debug node A new node /rostopic_XXXXX is created by the echo command we just ran (the number might be different). Now you can see that the publisher is publishing data over the cmd_vel topic, and two subscribers are subscribed to it (the two arrows with /turtle/cmd_vel ). Nodes send data over topics using messages. Publishers and subscribers must send and receive the same type of message to communicate. The topic types we saw earlier after running rostopic list -v let us know what message type is used on each topic. Recall that the cmd_vel topic has the type geometry_msgs/Twist . This means that in the package geometry_msgs there is a type called Twist . Alternatively, We can run rostopic type [topic] to see the topic type. We can also run rosmsg show [msg type] on the type to learn its details. Specifically, what structure of data the message expects. rostopic type /turtle1/cmd_vel You should get: geometry_msgs/Twist Look at the details of the message using rosmsg : rosmsg show geometry_msgs/Twist For the message type from above, you should see: geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z This tells you that the /turtlesim node is expecting a message with two vectors, linear and angular , of three elements each. If you recall the data we saw /teleop_turtle passing to /turtlesim with the echo command earlier. Now that you have the message structure, you can publish data to a topic directly from the command line using: rostopic pub [topic] [msg_type] [args] . The [args] argument is the actual data you\u2019ll pass to the topic, in the structure you just discovered in the previous section. It\u2019s important to note that this argument needs to be input in YAML syntax. Input the full command like so: rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' --once is an optional argument meaning \u201cpublish one message then exit\u201d. You will see your turtle move like so: Figure 2.9 The turtle starts moving in a circle This is a pretty complicated example, so lets look at each argument in detail. This command will publish messages to a given topic: rostopic pub This option (dash-one) causes rostopic to only publish one message then exit: -1 This is the name of the topic to publish to: /turtle1/cmd_vel This is the message type to use when publishing to the topic: geometry_msgs/Twist This option (double-dash) tells the option parser that none of the following arguments is an option. This is required in cases where your arguments have a leading dash -, like negative numbers. -- As noted before, a geometry_msgs/Twist msg has two vectors of three floating point elements each: linear and angular . In this case, '[2.0, 0.0, 0.0]' becomes the linear value with x=2.0 , y=0.0 , and z=0.0 , and '[0.0, 0.0, 1.8]' is the angular value with x=0.0 , y=0.0 , and z=1.8 . These arguments are actually in YAML syntax, which is described more in the YAML command line documentation . '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' In order to continuously operate the turtle (and commonly a real robot which it is meant to emulate) require a steady stream of commands. So, to get the turtle to keep moving, you can run: rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' The difference here is the removal of the -1 (for --once ) option and the addition of the -r 1 (for --rate 1 ) option, which tells rostopic pub to publish the command in a steady stream at 1 Hz. Figure 2.10 The turtle moving in a circle Refresh rqt_graph to see what\u2019s happening graphically. You will see a new rostopic pub ... node ( /rostopic_3330 in the figure) is publishing over the /turtle1/cmd_vel topic, which is being received by both the rostopic echo ... node ( /rostopic_3663 in the figure) and the /turtlesim node now. Figure 2.11 ROS rqt_graph of turtle moving in a circle Next, in a new terminal, run echo on the pose topic and recheck rqt_graph : rosopic echo /turtle1/pose Figure 2.12 ROS rqt_graph of turtle moving in a circle with pose You can see that the /turtlesim node is also publishing to the pose topic, which the new echo node has subscribed to.","title":"Understanding ROS Topics"},{"location":"aig240/lab2/#understanding-ros-services","text":"Leave roscore , rosrun turtlesim turtlesim_node and rosrun turtlesim turtle_teleop_key open and close all the other terminal. Open a new terminal and run the rosservice list command to return a list of all the services currently active in the system: /clear /kill /reset /rosout/get_loggers /rosout/set_logger_level /spawn /teleop_turtle/get_loggers /teleop_turtle/set_logger_level /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/get_loggers /turtlesim/set_logger_level Let's look more closely at the turtlesim-specific services, /clear , /kill , /reset , /spawn , /turtle1/set_pen , /turtle1/teleport_absolute , and /turtle1/teleport_relative . You may recall interacting with some of these services using rqt. Services have types that describe how the request and response data of a service is structured. Service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response. To find out the type of a service, use the command: rosservice type [service] Let\u2019s take a look at turtlesim\u2019s /clear service. In a new terminal, enter the command: rosservice type /clear Which should return: std_srvs/Empty The std_srvs/Empty type means the service call sends no data when making a request and receives no data when receiving a response. If you want to find all the services of a specific type, you can use the command: rosservice find [type_name] . For example, you can find all the Empty typed services like this: rosservice find std_srvs/Empty Which will return: /clear /reset You can call services from the command line, but first you need to know the structure of the input arguments by using rossrv show [type_name] . Try this on the /clear service\u2019s type, std_srvs/Empty : rossrv show std_srvs/Empty Which will return: --- The --- separates the request structure (above) from the response structure (below). But, as you learned earlier, the std_srvs/Empty type doesn\u2019t send or receive any data. So, naturally, its structure is blank. Let\u2019s introspect a service with a type that sends and receives data, like /spawn . From the results of rosservice type /spawn , we know /spawn \u2019s type is turtlesim/Spawn . To see the request and response arguments of the /spawn service, we can pass the return value of the rosservice command to the rossrv command by running the command: rosservice type /spawn | rossrv show Which will return: float32 x float32 y float32 theta string name --- string name The information above the --- line tells us the arguments needed to call /spawn . x , y and theta determine the 2D pose of the spawned turtle, and name is optional. The information below the --- line isn\u2019t something you need to know in this case, but it can help you understand the data type of the response you get from the call. Now that you know what a service type is, how to find a service\u2019s type, and how to find the structure of that type\u2019s arguments, you can call a service using: rosservice call [service_name] [service_type] [arguments] . The [arguments] part is optional. For example, you know that Empty typed services don\u2019t have any arguments: rosservice call /clear This command will clear the turtlesim window of any lines your turtle has drawn. Figure 2.13 Turtlesim with line Figure 2.14 Turtlesim cleared Now let\u2019s spawn a new turtle by calling /spawn and setting arguments. Input [arguments] in a service call from the command-line need to be in YAML syntax. Enter the command: rosservice call /spawn 2 2 0.2 \"\" You will get this service response: name: turtle2 Your turtlesim window will update with the newly spawned turtle right away: Figure 2.15 Turtlesim Spawn","title":"Understanding ROS Services"},{"location":"aig240/lab2/#understanding-ros-parameters","text":"rosparam allows you to store and manipulate data on the ROS Parameter Server . The Parameter Server can store integers, floats, boolean, dictionaries, and lists. rosparam uses the YAML markup language for syntax. In simple cases, YAML looks very natural: 1 is an integer, 1.0 is a float, one is a string, true is a boolean, [1, 2, 3] is a list of integers, and {a: b, c: d} is a dictionary. rosparam has many commands that can be used on parameters, as shown below: Usage: rosparam set set parameter rosparam get get parameter rosparam load load parameters from file rosparam dump dump parameters to file rosparam delete delete parameter rosparam list list parameter names To see the parameters belonging to your nodes, enter the command: rosparam list You will see the node namespaces, /teleop_turtle and /turtlesim , followed by each node\u2019s parameters: /rosdistro /roslaunch/uris/host_ubuntu_18__37467 /rosversion /run_id /turtlesim/background_b /turtlesim/background_g /turtlesim/background_r Based on their names, it looks like /turtlesim \u2019s parameters determine the background color of the turtlesim window using RGB color values. To display the type and current value of a parameter, use the command: rosparam get [param_name] . Let\u2019s find out the current value of /turtlesim \u2019s parameter background_g : rosparam get /turtlesim/background_g Which will return the value: 86 Now you know background_g holds an integer value. If you run the same command on background_r and background_b , you will get the values 69 and 255 , respectively. To change a parameter\u2019s value at runtime, use the command: rosparam set [param_name] . Let\u2019s change /turtlesim \u2019s background color: rosparam set /turtlesim/background_r 150 This changes the parameter value, now we have to call the clear service for the parameter change to take effect: rosservice call /clear And the background of your turtlesim window should change colors: Figure 2.16 Turtlesim Purple","title":"Understanding ROS Parameters"},{"location":"aig240/lab2/#lab-exercise","text":"Change the background of turtlesim to orange or cyan. Create another turtle into turtlesim . Command the first turtle to move in a large circle in the clockwise direction continuously. At the same time as the first turtle is moving, command the second turtle to move in a smaller circle in the counter-clockwise direction for one full circle only.","title":"Lab Exercise"},{"location":"aig240/lab2/#reference","text":"ROS Tutorials EECS 106A Labs","title":"Reference"},{"location":"aig240/lab3/","text":"Lab 3 : ROS Workspace, Package, Publisher and Subscriber Seneca Polytechnic AIG240 Robotics Introduction ROS Workspace A workspace is a directory containing ROS packages. Before using ROS, it\u2019s necessary to source your ROS installation workspace in the terminal you plan to work in. This makes ROS\u2019s packages available for you to use in that terminal. ROS Package A package is an organizational unit for your ROS code. If you want to be able to install your code or share it with others, then you\u2019ll need it organized in a package. With packages, you can release your ROS work and allow others to build and use it easily. For a package to be considered a catkin package it must meet a few requirements: The package must contain a catkin compliant package.xml file. That package.xml file provides meta information about the package. The package must contain a CMakeLists.txt which uses catkin. If it is a catkin metapackage it must have the relevant boilerplate CMakeLists.txt file. Each package must have its own directory This means no nested packages nor multiple packages sharing the same directory. The simplest possible package may have a file structure that looks like: my_package/ CMakeLists.txt package.xml A single workspace can contain as many packages as you want, each in their own directory. You can also have packages of different build types in one workspace (CMake, Python, etc.). You cannot have nested packages. Best practice is to have a src directory within your workspace, and to create your packages in there. This keeps the top level of the workspace \u201cclean\u201d. A trivial workspace might look like: workspace_directory/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n Procedures Create a Workspace directory Best practice is to create a new directory for every new workspace. The name doesn\u2019t matter, but it is helpful to have it indicate the purpose of the workspace. Let\u2019s choose the directory name ros_ws , for \u201cdevelopment workspace\u201d. Open a new terminal and run: mkdir -p ~/ros_ws/src cd ~/ros_ws/ catkin_make The catkin_make command is a convenience tool for working with catkin workspaces. When running it for the first time in your workspace, it will create a CMakeLists.txt link in your src directory. Another best practice is to put any packages in your workspace into the src directory. The above code creates a src directory inside ros_ws . Additionally, if you look in your current directory you should now have a 'build' and 'devel' directory. Inside the 'devel' directory you can see that there are now several setup files. Sourcing any of these files will overlay this workspace on top of your environment. Before continuing source your new setup.sh file: source devel/setup.bash To make sure your workspace is properly overlayed by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the directory you're in. echo $ROS_PACKAGE_PATH You should see: /home/jetauto/ros_ws/src:/opt/ros/melodic/share And other path(s) if you have them added to your source. Create a C++ Package Navigate into ros_ws/src , and run the package creation command to create a simple C++ publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg cpp_pubsub std_msgs roscpp Your terminal will return a message verifying the creation of your package cpp_pubsub and all its necessary files and directories. catkin_create_pkg requires that you give it a package_name and optionally a list of dependencies on which that package depends: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] More details on package creation can be found here . Write the publisher node Navigate into ros_ws/src/cpp_pubsub/src . This is the directory in any CMake package where the source files containing executables belong. cd ~/ros_ws/src/cpp_pubsub/src Download the example talker code by entering the following command: wget -O talker.cpp https://raw.githubusercontent.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp Now there will be a new file named talker.cpp . Open the file using your preferred text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include <sstream> /** * This tutorial demonstrates simple sending of messages over the ROS system. */ int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"talker\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The advertise() function is how you tell ROS that you want to * publish on a given topic name. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. After this advertise() call is made, the master * node will notify anyone who is trying to subscribe to this topic name, * and they will in turn negotiate a peer-to-peer connection with this * node. advertise() returns a Publisher object which allows you to * publish messages on that topic through a call to publish(). Once * all copies of the returned Publisher object are destroyed, the topic * will be automatically unadvertised. * * The second parameter to advertise() is the size of the message queue * used for publishing messages. If messages are published more quickly * than we can send them, the number here specifies how many messages to * buffer up before throwing some away. */ ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); ros::Rate loop_rate(10); /** * A count of how many messages we have sent. This is used to create * a unique string for each message. */ int count = 0; while (ros::ok()) { /** * This is a message object. You stuff it with data, and then publish it. */ std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); ROS_INFO(\"%s\", msg.data.c_str()); /** * The publish() function is how you send messages. The parameter * is the message object. The type of this object must agree with the type * given as a template parameter to the advertise<>() call, as was done * in the constructor above. */ chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } return 0; } The Code Explained Now, let's break the code down. #include \"ros/ros.h\" ros/ros.h is a convenience include that includes all the headers necessary to use the most common public pieces of the ROS system. #include \"std_msgs/String.h\" This includes the std_msgs/String message, which resides in the std_msgs package. This is a header generated automatically from the String.msg file in that package. For more information on message definitions, see the msg page. ros::init(argc, argv, \"talker\"); Initialize ROS. This allows ROS to do name remapping through the command line -- not important for now. This is also where we specify the name of our node. Node names must be unique in a running system. The name used here must be a base name, i.e., it cannot have a / in it. ros::NodeHandle n; Create a handle to this process' node. The first NodeHandle created will actually do the initialization of the node, and the last one destructed will cleanup any resources the node was using. ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); Tell the master that we are going to be publishing a message of type std_msgs/String on the topic chatter . This lets the master tell any nodes listening on chatter that we are going to publish data on that topic. The second argument is the size of our publishing queue. In this case if we are publishing too quickly it will buffer up a maximum of 1000 messages before beginning to throw away old ones. NodeHandle::advertise() returns a ros::Publisher object, which serves two purposes: 1) it contains a publish() method that lets you publish messages onto the topic it was created with, and 2) when it goes out of scope, it will automatically unadvertise. ros::Rate loop_rate(10); A ros::Rate object allows you to specify a frequency that you would like to loop at. It will keep track of how long it has been since the last call to Rate::sleep() , and sleep for the correct amount of time. In this case we tell it we want to run at 10Hz. int count = 0; while (ros::ok()) { By default roscpp will install a SIGINT handler which provides Ctrl-C handling which will cause ros::ok() to return false if that happens. ros::ok() will return false if: a SIGINT is received (Ctrl-C) we have been kicked off the network by another node with the same name ros::shutdown() has been called by another part of the application. all ros::NodeHandles have been destroyed Once ros::ok() returns false, all ROS calls will fail. std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); We broadcast a message on ROS using a message-adapted class, generally generated from a msg file. More complicated datatypes are possible, but for now we're going to use the standard String message, which has one member: \"data\". chatter_pub.publish(msg); Now we actually broadcast the message to anyone who is connected. ROS_INFO(\"%s\", msg.data.c_str()); ROS_INFO and friends are our replacement for printf/cout . See the rosconsole documentation for more information. ros::spinOnce(); Calling ros::spinOnce() here is not necessary for this simple program, because we are not receiving any callbacks. However, if you were to add a subscription into this application, and did not have ros::spinOnce() here, your callbacks would never get called. So, add it for good measure. loop_rate.sleep(); Now we use the ros::Rate object to sleep for the time remaining to let us hit our 10Hz publish rate. Here's the condensed version of what's going on: Initialize the ROS system Advertise that we are going to be publishing std_msgs/String messages on the chatter topic to the master Loop while publishing messages to chatter 10 times a second Write the subscriber node Now we need to write a node to receive the messsages. Return to ros_ws/src/cpp_pubsub/src to create the next node. Enter the following code in your terminal to download the subscriber: wget -O listener.cpp https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp Check to ensure that these files exist inside the ros_ws/src/cpp_pubsub/src folder: talker.cpp listener.cpp Open the listener.cpp with your text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" /** * This tutorial demonstrates simple receipt of messages over the ROS system. */ void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"listener\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The subscribe() call is how you tell ROS that you want to receive messages * on a given topic. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. Messages are passed to a callback function, here * called chatterCallback. subscribe() returns a Subscriber object that you * must hold on to until you want to unsubscribe. When all copies of the Subscriber * object go out of scope, this callback will automatically be unsubscribed from * this topic. * * The second parameter to the subscribe() function is the size of the message * queue. If messages are arriving faster than they are being processed, this * is the number of messages that will be buffered up before beginning to throw * away the oldest ones. */ ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); /** * ros::spin() will enter a loop, pumping callbacks. With this version, all * callbacks will be called from within this thread (the main one). ros::spin() * will exit when Ctrl-C is pressed, or the node is shutdown by the master. */ ros::spin(); return 0; } The Code Explained Now, let's break it down piece by piece, ignoring some pieces that have already been explained above. void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } This is the callback function that will get called when a new message has arrived on the chatter topic. The message is passed in a boost shared_ptr , which means you can store it off if you want, without worrying about it getting deleted underneath you, and without copying the underlying data. ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); Subscribe to the chatter topic with the master. ROS will call the chatterCallback() function whenever a new message arrives. The 2nd argument is the queue size, in case we are not able to process messages fast enough. In this case, if the queue reaches 1000 messages, we will start throwing away old messages as new ones arrive. NodeHandle::subscribe() returns a ros::Subscriber object, that you must hold on to until you want to unsubscribe. When the Subscriber object is destructed, it will automatically unsubscribe from the chatter topic. There are versions of the NodeHandle::subscribe() function which allow you to specify a class member function, or even anything callable by a Boost.Function object. The roscpp overview contains more information. ros::spin(); ros::spin() enters a loop, calling message callbacks as fast as possible. Don't worry though, if there's nothing for it to do it won't use much CPU. ros::spin() will exit once ros::ok() returns false, which means ros::shutdown() has been called, either by the default Ctrl-C handler, the master telling us to shutdown, or it being called manually. Again, here's a condensed version of what's going on: Initialize the ROS system Subscribe to the chatter topic Spin, waiting for messages to arrive When a message arrives, the chatterCallback() function is called Build and Run C++ Package Now, go back to the cpp_pubsub package and open up ros_ws/src/cpp_pubsub/CMakeLists.txt and ensure the following lines are in there and not commented out. Note: Some of the functions are currently commented out and some are missing. If the folder cpp_pubsub does not exist, that means you have not created the C++ package. Go back to the previous section to create the package. cmake_minimum_required(VERSION 3.0.2) project(cpp_pubsub) ## Find catkin and any catkin packages find_package(catkin REQUIRED COMPONENTS roscpp std_msgs genmsg) ## Generate added messages and services generate_messages(DEPENDENCIES std_msgs) ## Declare a catkin package catkin_package() ## Build talker and listener include_directories( include ${catkin_INCLUDE_DIRS} ) add_executable(talker src/talker.cpp) target_link_libraries(talker ${catkin_LIBRARIES}) add_dependencies(talker cpp_pubsub_generate_messages_cpp) add_executable(listener src/listener.cpp) target_link_libraries(listener ${catkin_LIBRARIES}) add_dependencies(listener cpp_pubsub_generate_messages_cpp) This will create two executables, talker and listener , which by default will go into the package directory of your devel space, located by default at ~/ros_ws/devel/lib/<package name> . Note that you have to add dependencies for the executable targets to message the generation targets: add_dependencies(talker cpp_pubsub_generate_messages_cpp) This makes sure message headers of this package are generated before being used. If you use messages from other packages inside your catkin workspace, you need to add dependencies to their respective generation targets as well, because catkin builds all projects in parallel. The following variable to allow you to depend on all necessary targets: target_link_libraries(talker ${catkin_LIBRARIES}) You can invoke executables directly or you can use rosrun to invoke them. They are not placed in <prefix>/bin because that would pollute the PATH when installing your package to the system. If you wish for your executable to be on the PATH at installation time, you can setup an install target, see: catkin/CMakeLists.txt Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Now run catkin_make in your catkin workspace: cd ~/ros_ws catkin_make Note: Or if you're adding as new pkg, you may need to tell catkin to force making by --force-cmake option. Now you have written a simple publisher and subscriber. Run ROS master. roscore In a new terminal, source the setup files: cd ~/ros_ws source ./devel/setup.bash Now run the talker node from ros_ws : rosrun cpp_pubsub talker The terminal should start publishing info messages every 0.5 seconds, like so: [ INFO] [1727906572.247429209]: hello world 0 [ INFO] [1727906572.347872260]: hello world 1 [ INFO] [1727906572.448580826]: hello world 2 [ INFO] [1727906572.548227290]: hello world 3 [ INFO] [1727906572.650658485]: hello world 4 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: cd ~/ros_ws . devel/setup.bash rosrun cpp_pubsub listener The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [ INFO] [1727906765.424901599]: I heard: [hello world 10] [ INFO] [1727906765.525323426]: I heard: [hello world 11] [ INFO] [1727906765.625240241]: I heard: [hello world 12] [ INFO] [1727906765.728040103]: I heard: [hello world 13] [ INFO] [1727906765.824066051]: I heard: [hello world 14] Enter Ctrl+C in each terminal to stop the nodes from spinning. Create a Python Package Navigate into ros_ws/src , and run the package creation command to create a simple Python publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg py_pubsub std_msgs rospy Your terminal will return a message verifying the creation of your package py_pubsub and all its necessary files and directories. Write the publisher node Navigate to your package ros_ws/src/py_pubsub and let's first create a scripts directories to store our Python scripts in and navigate into it: cd ~/ros_ws/src/py_pubsub Create a directory. mkdir scripts cd scripts Download the example talker code and make it executable by entering the following command: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/talker.py chmod +x talker.py Now there will be a new file named talker.py . Open the file using your preferred text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python # license removed for brevity import rospy from std_msgs.msg import String def talker(): pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) rate = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() if __name__ == '__main__': try: talker() except rospy.ROSInterruptException: pass The Code Explained Now, let's break the code down. #!/usr/bin/env python Every Python ROS Node will have this declaration at the top. The first line makes sure your script is executed as a Python script. import rospy from std_msgs.msg import String You need to import rospy if you are writing a ROS Node. The std_msgs.msg import is so that we can reuse the std_msgs/String message type (a simple string container) for publishing. pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) This section of code defines the talker's interface to the rest of ROS. pub = rospy.Publisher(\"chatter\", String, queue_size=10) declares that your node is publishing to the chatter topic using the message type String . String here is actually the class std_msgs.msg.String . The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. The next line, rospy.init_node(NAME, ...) , is very important as it tells rospy the name of your node -- until rospy has this information, it cannot start communicating with the ROS Master. In this case, your node will take on the name talker . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". anonymous = True ensures that your node has a unique name by adding random numbers to the end of NAME. Refer to Initialization and Shutdown - Initializing your ROS Node in the rospy documentation for more information about node initialization options. rate = rospy.Rate(10) # 10hz This line creates a Rate object rate . With the help of its method sleep() , it offers a convenient way for looping at the desired rate . With its argument of 10 , we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10th of a second!) while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() This loop is a fairly standard rospy construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(hello_str) that publishes a string to our chatter topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. (You may also run across rospy.sleep() which is similar to time.sleep() except that it works with simulated time as well (see Clock ).) This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. std_msgs.msg.String is a very simple message type, so you may be wondering what it looks like to publish more complicated types. The general rule of thumb is that constructor args are in the same order as in the .msg file . You can also pass in no arguments and initialize the fields directly, e.g. msg = String() msg.data = str or you can initialize some of the fields and leave the rest with default values: String(data=str) You may be wondering about the last little bit: try: talker() except rospy.ROSInterruptException: pass In addition to the standard Python __main__ check, this catches a rospy.ROSInterruptException exception, which can be thrown by rospy.sleep() and rospy.Rate.sleep() methods when Ctrl-C is pressed or your Node is otherwise shutdown. The reason this exception is raised is so that you don't accidentally continue executing code after the sleep() . Write the subscriber node Now we need to write a node to receive the messages. Return to ros_ws/src/py_pubsub/scripts to create the next node. Enter the following code in your terminal: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/listener.py chmod +x listener.py Now the directory should have these files: listener.py talker.py Open the listener.py with your text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python import rospy from std_msgs.msg import String def callback(data): rospy.loginfo(rospy.get_caller_id() + \"I heard %s\", data.data) def listener(): # In ROS, nodes are uniquely named. If two nodes with the same # name are launched, the previous one is kicked off. The # anonymous=True flag means that rospy will choose a unique # name for our 'listener' node so that multiple listeners can # run simultaneously. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() if __name__ == '__main__': listener() Add the following to your ros_ws/src/py_pubsub/CMakeLists.txt in the py_pubsub package. This makes sure the python scripts get installed properly, and uses the right python interpreter. You may just add this to the end of the CMakeLists.txt . catkin_install_python(PROGRAMS scripts/talker.py scripts/listener.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) The Code Explained The code for listener.py is similar to talker.py , except we've introduced a new callback-based mechanism for subscribing to messages. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() This declares that your node subscribes to the chatter topic which is of type std_msgs.msgs.String . When new messages are received, callback is invoked with the message as the first argument. We also changed up the call to rospy.init_node() somewhat. We've added the anonymous=True keyword argument. ROS requires that each node have a unique name. If a node with the same name comes up, it bumps the previous one. This is so that malfunctioning nodes can easily be kicked off the network. The anonymous=True flag tells rospy to generate a unique name for the node so that you can have multiple listener.py nodes run easily. The final addition, rospy.spin() simply keeps your node from exiting until the node has been shutdown. Unlike roscpp , rospy.spin() does not affect the subscriber callback functions, as those have their own threads. Build and run Python Package We use CMake as our build system and, yes, you have to use it even for Python nodes. This is to make sure that the autogenerated Python code for messages and services is created. Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Go to your catkin workspace and run catkin_make : cd ~/ros_ws catkin_make Run ROS master. roscore Open a new terminal, navigate to ros_ws , and source the setup files: cd ~/ros_ws source ./devel/setup.bash Now run the talker node: rosrun py_pubsub talker.py The terminal should start publishing info messages every 0.5 seconds, like so: [INFO] [1727910097.196673]: hello world 1727910097.2 [INFO] [1727910097.293260]: hello world 1727910097.29 [INFO] [1727910097.394363]: hello world 1727910097.39 [INFO] [1727910097.493223]: hello world 1727910097.49 [INFO] [1727910097.592866]: hello world 1727910097.59 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: cd ~/ros_ws . devel/setup.bash rosrun py_pubsub listener.py The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [INFO] [1727910166.665430]: /listener_5173_1727910161732I heard hello world 1727910166.66 [INFO] [1727910166.761804]: /listener_5173_1727910161732I heard hello world 1727910166.76 [INFO] [1727910166.870095]: /listener_5173_1727910161732I heard hello world 1727910166.87 [INFO] [1727910166.963474]: /listener_5173_1727910161732I heard hello world 1727910166.96 [INFO] [1727910167.071514]: /listener_5173_1727910161732I heard hello world 1727910167.07 Stop the listener and try to run the C++ listener from earlier: rosrun cpp_pubsub listener You should see a similar output. Press Ctrl+C in each terminal to stop the nodes from spinning. Lab Exercise ( Project 1 ) Write a new controller (C++ or Python) for turtlesim that replaces turtle_teleop_key . Since the turtlesim node is the subscriber in this example, you\u2019ll only need to write a single publisher node. Create a new package called lab3_turtlesim . You can create a new workspace called lab3_ws or use your existing workspace. The command to create the packages are given below depending on your preferred programming language. You'll need the geometry_msgs dependency to use the twist object. catkin_create_pkg lab3_turtlesim roscpp geometry_msgs or catkin_create_pkg lab3_turtlesim rospy geometry_msgs Your node should do the following: Accept a command line argument specifying the name of the turtle it should control. i.e., running rosrun lab3_turtlesim turtle_controller turtle1 will start a controller node that controls turtle1 . Use w , a , s , d (and q , e , c , and z ) to control the turtle by publish velocity control messages on the appropriate topic whenever the user presses those keys on the keyboard, as in the original turtle_teleop_key . The turtle should ONLY move when is key is pressed. When the key is released, the turtle should STOP moving. Option 1 (Easy) Single keypress: In addition to just forward/backward and turns, the turtle should move forward and turn left in a circular path if q is pressed and similar for e , c , and z in their corresponding direction. Option 2 (Hard) Multiple keypress: If you want to challenge your Python skills, make the controller so it listen to multiple keys. i.e., if w + a are pressed, the turtle should move forward and turn left in a circular path. If the keys pressed are contracdicting, there should be no movement. You'll need to install additional Python package to achieve this. Hint: You'll need to use the Twist message type in the geometry_msgs package. Hint: Find the turtle_teleop_key source code as a reference. teleop_turtle_key.cpp To test, spawn multiple turtles and open multiple instances of your new turtle controller node, each linked to a different turtle. Reference ROS Tutorials EECS 106A Labs","title":"Lab 3 : ROS Workspace, Package, Publisher and Subscriber"},{"location":"aig240/lab3/#lab-3-ros-workspace-package-publisher-and-subscriber","text":"Seneca Polytechnic AIG240 Robotics","title":"Lab 3 : ROS Workspace, Package, Publisher and Subscriber"},{"location":"aig240/lab3/#introduction","text":"","title":"Introduction"},{"location":"aig240/lab3/#ros-workspace","text":"A workspace is a directory containing ROS packages. Before using ROS, it\u2019s necessary to source your ROS installation workspace in the terminal you plan to work in. This makes ROS\u2019s packages available for you to use in that terminal.","title":"ROS Workspace"},{"location":"aig240/lab3/#ros-package","text":"A package is an organizational unit for your ROS code. If you want to be able to install your code or share it with others, then you\u2019ll need it organized in a package. With packages, you can release your ROS work and allow others to build and use it easily. For a package to be considered a catkin package it must meet a few requirements: The package must contain a catkin compliant package.xml file. That package.xml file provides meta information about the package. The package must contain a CMakeLists.txt which uses catkin. If it is a catkin metapackage it must have the relevant boilerplate CMakeLists.txt file. Each package must have its own directory This means no nested packages nor multiple packages sharing the same directory. The simplest possible package may have a file structure that looks like: my_package/ CMakeLists.txt package.xml A single workspace can contain as many packages as you want, each in their own directory. You can also have packages of different build types in one workspace (CMake, Python, etc.). You cannot have nested packages. Best practice is to have a src directory within your workspace, and to create your packages in there. This keeps the top level of the workspace \u201cclean\u201d. A trivial workspace might look like: workspace_directory/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n","title":"ROS Package"},{"location":"aig240/lab3/#procedures","text":"","title":"Procedures"},{"location":"aig240/lab3/#create-a-workspace-directory","text":"Best practice is to create a new directory for every new workspace. The name doesn\u2019t matter, but it is helpful to have it indicate the purpose of the workspace. Let\u2019s choose the directory name ros_ws , for \u201cdevelopment workspace\u201d. Open a new terminal and run: mkdir -p ~/ros_ws/src cd ~/ros_ws/ catkin_make The catkin_make command is a convenience tool for working with catkin workspaces. When running it for the first time in your workspace, it will create a CMakeLists.txt link in your src directory. Another best practice is to put any packages in your workspace into the src directory. The above code creates a src directory inside ros_ws . Additionally, if you look in your current directory you should now have a 'build' and 'devel' directory. Inside the 'devel' directory you can see that there are now several setup files. Sourcing any of these files will overlay this workspace on top of your environment. Before continuing source your new setup.sh file: source devel/setup.bash To make sure your workspace is properly overlayed by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the directory you're in. echo $ROS_PACKAGE_PATH You should see: /home/jetauto/ros_ws/src:/opt/ros/melodic/share And other path(s) if you have them added to your source.","title":"Create a Workspace directory"},{"location":"aig240/lab3/#create-a-c-package","text":"Navigate into ros_ws/src , and run the package creation command to create a simple C++ publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg cpp_pubsub std_msgs roscpp Your terminal will return a message verifying the creation of your package cpp_pubsub and all its necessary files and directories. catkin_create_pkg requires that you give it a package_name and optionally a list of dependencies on which that package depends: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] More details on package creation can be found here .","title":"Create a C++ Package"},{"location":"aig240/lab3/#write-the-publisher-node","text":"Navigate into ros_ws/src/cpp_pubsub/src . This is the directory in any CMake package where the source files containing executables belong. cd ~/ros_ws/src/cpp_pubsub/src Download the example talker code by entering the following command: wget -O talker.cpp https://raw.githubusercontent.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp Now there will be a new file named talker.cpp . Open the file using your preferred text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include <sstream> /** * This tutorial demonstrates simple sending of messages over the ROS system. */ int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"talker\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The advertise() function is how you tell ROS that you want to * publish on a given topic name. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. After this advertise() call is made, the master * node will notify anyone who is trying to subscribe to this topic name, * and they will in turn negotiate a peer-to-peer connection with this * node. advertise() returns a Publisher object which allows you to * publish messages on that topic through a call to publish(). Once * all copies of the returned Publisher object are destroyed, the topic * will be automatically unadvertised. * * The second parameter to advertise() is the size of the message queue * used for publishing messages. If messages are published more quickly * than we can send them, the number here specifies how many messages to * buffer up before throwing some away. */ ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); ros::Rate loop_rate(10); /** * A count of how many messages we have sent. This is used to create * a unique string for each message. */ int count = 0; while (ros::ok()) { /** * This is a message object. You stuff it with data, and then publish it. */ std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); ROS_INFO(\"%s\", msg.data.c_str()); /** * The publish() function is how you send messages. The parameter * is the message object. The type of this object must agree with the type * given as a template parameter to the advertise<>() call, as was done * in the constructor above. */ chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } return 0; }","title":"Write the publisher node"},{"location":"aig240/lab3/#the-code-explained","text":"Now, let's break the code down. #include \"ros/ros.h\" ros/ros.h is a convenience include that includes all the headers necessary to use the most common public pieces of the ROS system. #include \"std_msgs/String.h\" This includes the std_msgs/String message, which resides in the std_msgs package. This is a header generated automatically from the String.msg file in that package. For more information on message definitions, see the msg page. ros::init(argc, argv, \"talker\"); Initialize ROS. This allows ROS to do name remapping through the command line -- not important for now. This is also where we specify the name of our node. Node names must be unique in a running system. The name used here must be a base name, i.e., it cannot have a / in it. ros::NodeHandle n; Create a handle to this process' node. The first NodeHandle created will actually do the initialization of the node, and the last one destructed will cleanup any resources the node was using. ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); Tell the master that we are going to be publishing a message of type std_msgs/String on the topic chatter . This lets the master tell any nodes listening on chatter that we are going to publish data on that topic. The second argument is the size of our publishing queue. In this case if we are publishing too quickly it will buffer up a maximum of 1000 messages before beginning to throw away old ones. NodeHandle::advertise() returns a ros::Publisher object, which serves two purposes: 1) it contains a publish() method that lets you publish messages onto the topic it was created with, and 2) when it goes out of scope, it will automatically unadvertise. ros::Rate loop_rate(10); A ros::Rate object allows you to specify a frequency that you would like to loop at. It will keep track of how long it has been since the last call to Rate::sleep() , and sleep for the correct amount of time. In this case we tell it we want to run at 10Hz. int count = 0; while (ros::ok()) { By default roscpp will install a SIGINT handler which provides Ctrl-C handling which will cause ros::ok() to return false if that happens. ros::ok() will return false if: a SIGINT is received (Ctrl-C) we have been kicked off the network by another node with the same name ros::shutdown() has been called by another part of the application. all ros::NodeHandles have been destroyed Once ros::ok() returns false, all ROS calls will fail. std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); We broadcast a message on ROS using a message-adapted class, generally generated from a msg file. More complicated datatypes are possible, but for now we're going to use the standard String message, which has one member: \"data\". chatter_pub.publish(msg); Now we actually broadcast the message to anyone who is connected. ROS_INFO(\"%s\", msg.data.c_str()); ROS_INFO and friends are our replacement for printf/cout . See the rosconsole documentation for more information. ros::spinOnce(); Calling ros::spinOnce() here is not necessary for this simple program, because we are not receiving any callbacks. However, if you were to add a subscription into this application, and did not have ros::spinOnce() here, your callbacks would never get called. So, add it for good measure. loop_rate.sleep(); Now we use the ros::Rate object to sleep for the time remaining to let us hit our 10Hz publish rate. Here's the condensed version of what's going on: Initialize the ROS system Advertise that we are going to be publishing std_msgs/String messages on the chatter topic to the master Loop while publishing messages to chatter 10 times a second","title":"The Code Explained"},{"location":"aig240/lab3/#write-the-subscriber-node","text":"Now we need to write a node to receive the messsages. Return to ros_ws/src/cpp_pubsub/src to create the next node. Enter the following code in your terminal to download the subscriber: wget -O listener.cpp https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp Check to ensure that these files exist inside the ros_ws/src/cpp_pubsub/src folder: talker.cpp listener.cpp Open the listener.cpp with your text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" /** * This tutorial demonstrates simple receipt of messages over the ROS system. */ void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"listener\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The subscribe() call is how you tell ROS that you want to receive messages * on a given topic. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. Messages are passed to a callback function, here * called chatterCallback. subscribe() returns a Subscriber object that you * must hold on to until you want to unsubscribe. When all copies of the Subscriber * object go out of scope, this callback will automatically be unsubscribed from * this topic. * * The second parameter to the subscribe() function is the size of the message * queue. If messages are arriving faster than they are being processed, this * is the number of messages that will be buffered up before beginning to throw * away the oldest ones. */ ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); /** * ros::spin() will enter a loop, pumping callbacks. With this version, all * callbacks will be called from within this thread (the main one). ros::spin() * will exit when Ctrl-C is pressed, or the node is shutdown by the master. */ ros::spin(); return 0; }","title":"Write the subscriber node"},{"location":"aig240/lab3/#the-code-explained_1","text":"Now, let's break it down piece by piece, ignoring some pieces that have already been explained above. void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } This is the callback function that will get called when a new message has arrived on the chatter topic. The message is passed in a boost shared_ptr , which means you can store it off if you want, without worrying about it getting deleted underneath you, and without copying the underlying data. ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); Subscribe to the chatter topic with the master. ROS will call the chatterCallback() function whenever a new message arrives. The 2nd argument is the queue size, in case we are not able to process messages fast enough. In this case, if the queue reaches 1000 messages, we will start throwing away old messages as new ones arrive. NodeHandle::subscribe() returns a ros::Subscriber object, that you must hold on to until you want to unsubscribe. When the Subscriber object is destructed, it will automatically unsubscribe from the chatter topic. There are versions of the NodeHandle::subscribe() function which allow you to specify a class member function, or even anything callable by a Boost.Function object. The roscpp overview contains more information. ros::spin(); ros::spin() enters a loop, calling message callbacks as fast as possible. Don't worry though, if there's nothing for it to do it won't use much CPU. ros::spin() will exit once ros::ok() returns false, which means ros::shutdown() has been called, either by the default Ctrl-C handler, the master telling us to shutdown, or it being called manually. Again, here's a condensed version of what's going on: Initialize the ROS system Subscribe to the chatter topic Spin, waiting for messages to arrive When a message arrives, the chatterCallback() function is called","title":"The Code Explained"},{"location":"aig240/lab3/#build-and-run-c-package","text":"Now, go back to the cpp_pubsub package and open up ros_ws/src/cpp_pubsub/CMakeLists.txt and ensure the following lines are in there and not commented out. Note: Some of the functions are currently commented out and some are missing. If the folder cpp_pubsub does not exist, that means you have not created the C++ package. Go back to the previous section to create the package. cmake_minimum_required(VERSION 3.0.2) project(cpp_pubsub) ## Find catkin and any catkin packages find_package(catkin REQUIRED COMPONENTS roscpp std_msgs genmsg) ## Generate added messages and services generate_messages(DEPENDENCIES std_msgs) ## Declare a catkin package catkin_package() ## Build talker and listener include_directories( include ${catkin_INCLUDE_DIRS} ) add_executable(talker src/talker.cpp) target_link_libraries(talker ${catkin_LIBRARIES}) add_dependencies(talker cpp_pubsub_generate_messages_cpp) add_executable(listener src/listener.cpp) target_link_libraries(listener ${catkin_LIBRARIES}) add_dependencies(listener cpp_pubsub_generate_messages_cpp) This will create two executables, talker and listener , which by default will go into the package directory of your devel space, located by default at ~/ros_ws/devel/lib/<package name> . Note that you have to add dependencies for the executable targets to message the generation targets: add_dependencies(talker cpp_pubsub_generate_messages_cpp) This makes sure message headers of this package are generated before being used. If you use messages from other packages inside your catkin workspace, you need to add dependencies to their respective generation targets as well, because catkin builds all projects in parallel. The following variable to allow you to depend on all necessary targets: target_link_libraries(talker ${catkin_LIBRARIES}) You can invoke executables directly or you can use rosrun to invoke them. They are not placed in <prefix>/bin because that would pollute the PATH when installing your package to the system. If you wish for your executable to be on the PATH at installation time, you can setup an install target, see: catkin/CMakeLists.txt Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Now run catkin_make in your catkin workspace: cd ~/ros_ws catkin_make Note: Or if you're adding as new pkg, you may need to tell catkin to force making by --force-cmake option. Now you have written a simple publisher and subscriber. Run ROS master. roscore In a new terminal, source the setup files: cd ~/ros_ws source ./devel/setup.bash Now run the talker node from ros_ws : rosrun cpp_pubsub talker The terminal should start publishing info messages every 0.5 seconds, like so: [ INFO] [1727906572.247429209]: hello world 0 [ INFO] [1727906572.347872260]: hello world 1 [ INFO] [1727906572.448580826]: hello world 2 [ INFO] [1727906572.548227290]: hello world 3 [ INFO] [1727906572.650658485]: hello world 4 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: cd ~/ros_ws . devel/setup.bash rosrun cpp_pubsub listener The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [ INFO] [1727906765.424901599]: I heard: [hello world 10] [ INFO] [1727906765.525323426]: I heard: [hello world 11] [ INFO] [1727906765.625240241]: I heard: [hello world 12] [ INFO] [1727906765.728040103]: I heard: [hello world 13] [ INFO] [1727906765.824066051]: I heard: [hello world 14] Enter Ctrl+C in each terminal to stop the nodes from spinning.","title":"Build and Run C++ Package"},{"location":"aig240/lab3/#create-a-python-package","text":"Navigate into ros_ws/src , and run the package creation command to create a simple Python publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg py_pubsub std_msgs rospy Your terminal will return a message verifying the creation of your package py_pubsub and all its necessary files and directories.","title":"Create a Python Package"},{"location":"aig240/lab3/#write-the-publisher-node_1","text":"Navigate to your package ros_ws/src/py_pubsub and let's first create a scripts directories to store our Python scripts in and navigate into it: cd ~/ros_ws/src/py_pubsub Create a directory. mkdir scripts cd scripts Download the example talker code and make it executable by entering the following command: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/talker.py chmod +x talker.py Now there will be a new file named talker.py . Open the file using your preferred text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python # license removed for brevity import rospy from std_msgs.msg import String def talker(): pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) rate = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() if __name__ == '__main__': try: talker() except rospy.ROSInterruptException: pass","title":"Write the publisher node"},{"location":"aig240/lab3/#the-code-explained_2","text":"Now, let's break the code down. #!/usr/bin/env python Every Python ROS Node will have this declaration at the top. The first line makes sure your script is executed as a Python script. import rospy from std_msgs.msg import String You need to import rospy if you are writing a ROS Node. The std_msgs.msg import is so that we can reuse the std_msgs/String message type (a simple string container) for publishing. pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) This section of code defines the talker's interface to the rest of ROS. pub = rospy.Publisher(\"chatter\", String, queue_size=10) declares that your node is publishing to the chatter topic using the message type String . String here is actually the class std_msgs.msg.String . The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. The next line, rospy.init_node(NAME, ...) , is very important as it tells rospy the name of your node -- until rospy has this information, it cannot start communicating with the ROS Master. In this case, your node will take on the name talker . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". anonymous = True ensures that your node has a unique name by adding random numbers to the end of NAME. Refer to Initialization and Shutdown - Initializing your ROS Node in the rospy documentation for more information about node initialization options. rate = rospy.Rate(10) # 10hz This line creates a Rate object rate . With the help of its method sleep() , it offers a convenient way for looping at the desired rate . With its argument of 10 , we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10th of a second!) while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() This loop is a fairly standard rospy construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(hello_str) that publishes a string to our chatter topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. (You may also run across rospy.sleep() which is similar to time.sleep() except that it works with simulated time as well (see Clock ).) This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. std_msgs.msg.String is a very simple message type, so you may be wondering what it looks like to publish more complicated types. The general rule of thumb is that constructor args are in the same order as in the .msg file . You can also pass in no arguments and initialize the fields directly, e.g. msg = String() msg.data = str or you can initialize some of the fields and leave the rest with default values: String(data=str) You may be wondering about the last little bit: try: talker() except rospy.ROSInterruptException: pass In addition to the standard Python __main__ check, this catches a rospy.ROSInterruptException exception, which can be thrown by rospy.sleep() and rospy.Rate.sleep() methods when Ctrl-C is pressed or your Node is otherwise shutdown. The reason this exception is raised is so that you don't accidentally continue executing code after the sleep() .","title":"The Code Explained"},{"location":"aig240/lab3/#write-the-subscriber-node_1","text":"Now we need to write a node to receive the messages. Return to ros_ws/src/py_pubsub/scripts to create the next node. Enter the following code in your terminal: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/listener.py chmod +x listener.py Now the directory should have these files: listener.py talker.py Open the listener.py with your text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python import rospy from std_msgs.msg import String def callback(data): rospy.loginfo(rospy.get_caller_id() + \"I heard %s\", data.data) def listener(): # In ROS, nodes are uniquely named. If two nodes with the same # name are launched, the previous one is kicked off. The # anonymous=True flag means that rospy will choose a unique # name for our 'listener' node so that multiple listeners can # run simultaneously. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() if __name__ == '__main__': listener() Add the following to your ros_ws/src/py_pubsub/CMakeLists.txt in the py_pubsub package. This makes sure the python scripts get installed properly, and uses the right python interpreter. You may just add this to the end of the CMakeLists.txt . catkin_install_python(PROGRAMS scripts/talker.py scripts/listener.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} )","title":"Write the subscriber node"},{"location":"aig240/lab3/#the-code-explained_3","text":"The code for listener.py is similar to talker.py , except we've introduced a new callback-based mechanism for subscribing to messages. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() This declares that your node subscribes to the chatter topic which is of type std_msgs.msgs.String . When new messages are received, callback is invoked with the message as the first argument. We also changed up the call to rospy.init_node() somewhat. We've added the anonymous=True keyword argument. ROS requires that each node have a unique name. If a node with the same name comes up, it bumps the previous one. This is so that malfunctioning nodes can easily be kicked off the network. The anonymous=True flag tells rospy to generate a unique name for the node so that you can have multiple listener.py nodes run easily. The final addition, rospy.spin() simply keeps your node from exiting until the node has been shutdown. Unlike roscpp , rospy.spin() does not affect the subscriber callback functions, as those have their own threads.","title":"The Code Explained"},{"location":"aig240/lab3/#build-and-run-python-package","text":"We use CMake as our build system and, yes, you have to use it even for Python nodes. This is to make sure that the autogenerated Python code for messages and services is created. Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Go to your catkin workspace and run catkin_make : cd ~/ros_ws catkin_make Run ROS master. roscore Open a new terminal, navigate to ros_ws , and source the setup files: cd ~/ros_ws source ./devel/setup.bash Now run the talker node: rosrun py_pubsub talker.py The terminal should start publishing info messages every 0.5 seconds, like so: [INFO] [1727910097.196673]: hello world 1727910097.2 [INFO] [1727910097.293260]: hello world 1727910097.29 [INFO] [1727910097.394363]: hello world 1727910097.39 [INFO] [1727910097.493223]: hello world 1727910097.49 [INFO] [1727910097.592866]: hello world 1727910097.59 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: cd ~/ros_ws . devel/setup.bash rosrun py_pubsub listener.py The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [INFO] [1727910166.665430]: /listener_5173_1727910161732I heard hello world 1727910166.66 [INFO] [1727910166.761804]: /listener_5173_1727910161732I heard hello world 1727910166.76 [INFO] [1727910166.870095]: /listener_5173_1727910161732I heard hello world 1727910166.87 [INFO] [1727910166.963474]: /listener_5173_1727910161732I heard hello world 1727910166.96 [INFO] [1727910167.071514]: /listener_5173_1727910161732I heard hello world 1727910167.07 Stop the listener and try to run the C++ listener from earlier: rosrun cpp_pubsub listener You should see a similar output. Press Ctrl+C in each terminal to stop the nodes from spinning.","title":"Build and run Python Package"},{"location":"aig240/lab3/#lab-exercise-project-1","text":"Write a new controller (C++ or Python) for turtlesim that replaces turtle_teleop_key . Since the turtlesim node is the subscriber in this example, you\u2019ll only need to write a single publisher node. Create a new package called lab3_turtlesim . You can create a new workspace called lab3_ws or use your existing workspace. The command to create the packages are given below depending on your preferred programming language. You'll need the geometry_msgs dependency to use the twist object. catkin_create_pkg lab3_turtlesim roscpp geometry_msgs or catkin_create_pkg lab3_turtlesim rospy geometry_msgs Your node should do the following: Accept a command line argument specifying the name of the turtle it should control. i.e., running rosrun lab3_turtlesim turtle_controller turtle1 will start a controller node that controls turtle1 . Use w , a , s , d (and q , e , c , and z ) to control the turtle by publish velocity control messages on the appropriate topic whenever the user presses those keys on the keyboard, as in the original turtle_teleop_key . The turtle should ONLY move when is key is pressed. When the key is released, the turtle should STOP moving. Option 1 (Easy) Single keypress: In addition to just forward/backward and turns, the turtle should move forward and turn left in a circular path if q is pressed and similar for e , c , and z in their corresponding direction. Option 2 (Hard) Multiple keypress: If you want to challenge your Python skills, make the controller so it listen to multiple keys. i.e., if w + a are pressed, the turtle should move forward and turn left in a circular path. If the keys pressed are contracdicting, there should be no movement. You'll need to install additional Python package to achieve this. Hint: You'll need to use the Twist message type in the geometry_msgs package. Hint: Find the turtle_teleop_key source code as a reference. teleop_turtle_key.cpp To test, spawn multiple turtles and open multiple instances of your new turtle controller node, each linked to a different turtle.","title":"Lab Exercise (Project 1)"},{"location":"aig240/lab3/#reference","text":"ROS Tutorials EECS 106A Labs","title":"Reference"},{"location":"aig240/lab4/","text":"Lab 4: Robot Model and Gazebo Seneca Polytechnic AIG240 Robotics Introduction URDF URDF (Unified Robot Description Format) is an XML format for representing a robot model. URDF is commonly used in Robot Operating System (ROS) tools such as RViz (ROS Visualization tool) and Gazebo simulator. It is essentially a 3D model with information about joints, motors, mass, etc. The files are then run through the Robot Operating System (ROS). The data from the file informs the human operator what the robot looks like and is capable of before they begin operating the robot. More details on the URDF specification can be found here . Many robotic manufacturers have URDF models of their devices available for download. These include the Segway RMP , TurtleBot , and AR10 . More Models: Agility Robotics Digit ANYbotics Anymal Boston Dynamics Spot (via Clearpath ROS Driver) Clearpath Jackal Clearpath Dingo Clearpath Husky Clearpath TurtleBot Unitree Go1 Universal Robots URDF vs XACRO URDF (Unified Robot Description Format) and XACRO (XML Macros) are both used in ROS (Robot Operating System) for robot modeling, but they have distinct roles. URDF is a straightforward XML format that describes the physical structure of a robot, detailing its links and joints, as well as their properties like geometry and dynamics. It is ideal for simpler robot designs where the model's complexity is limited. In contrast, XACRO is an extension of URDF that incorporates macros, allowing for parameterization and reducing redundancy in model descriptions. This makes XACRO particularly useful for complex robots or those with interchangeable components, as it facilitates easier maintenance and enhances readability. Typically, XACRO files are processed into URDF files before they are utilized in simulations or applications, combining the flexibility of XACRO with the straightforwardness of URDF. RViz RViz, or Robot Visualization, is a powerful 3D visualization tool used primarily in robotics and the Robot Operating System (ROS). It enables developers to visualize and interpret a wide array of sensor data, such as point clouds, maps, and robot models, in real-time. With its interactive features, users can manipulate objects and adjust visual settings to enhance understanding of robot behavior and performance. RViz's plugin architecture allows for extensibility, accommodating various data types and visualization needs. This makes it an invaluable resource for debugging algorithms, simulating scenarios, and gaining insights into robotic systems, ultimately aiding in the development and refinement of robotics applications. Gazebo Gazebo is an open-source robotics simulation tool that provides a highly realistic environment for testing and developing robotic systems. It allows users to simulate robots in complex 3D environments, complete with detailed physics interactions, which include gravity, collisions, and friction. Gazebo supports a variety of sensors, such as cameras and LIDAR, enabling the generation of realistic sensor data for developing perception algorithms. Its seamless integration with the Robot Operating System (ROS) enhances its functionality, allowing developers to leverage ROS tools and libraries for robot control and communication. With a flexible plugin architecture, Gazebo can be customized to meet specific simulation needs, making it an essential platform for researchers and engineers in the field of robotics. Preparation JetAuto Robot In preparation for using the JetAuto robot, please be familiar with the user manual and the basic lesson provided by the manufacturer found here: JetAuto User Manual JetAuto & JetAuto Pro Resources Procedures Install Gazebo and other ROS packages After becoming familiar with ROS, we'll now install the Gazebo simulation environment. Install Gazebo version 9.X to be used with ROS Melodic. Each Gazebo version works with a specific version of ROS. More details about the installation can be found here . sudo apt install gazebo9 libgazebo9-dev Once installed, start Gazebo with the following command to ensure it is functional: gazebo Figure 4.1 Gazebo Running Lastly, ensure the following ROS Gazebo packages are installed: sudo apt install ros-melodic-gazebo-dev ros-melodic-gazebo-msgs ros-melodic-gazebo-plugins ros-melodic-gazebo-ros ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller ros-melodic-moveit ros-melodic-trac-ik-kinematics-plugin ros-melodic-slam-gmapping Download the JetAuto Workspace to Local Machine for Simulation For this lab, we'll use the JetAuto workspace jetauto_ws on our local virtual machine so we can test the robot locally in a simulation before programming the actual robot. Download jetauto_ws.zip and unzip it to the jetauto user's directory: /home/jetauto/ If you downloaded the file on your host machine instead of your virtual machine, you may use WinSCP to transfer the file over to your virtual machine. On your virtual machine: Open a terminal and ensure openssh-server is installed. sudo apt-get install openssh-server Enable and start SSH as necessary: sudo systemctl enable ssh sudo systemctl start ssh On your host machine: Open WinSCP and connect to: 127.0.0.1 port 22. Copy the jetauto_ws folder from jetauto_ws.zip into /home/jetauto/ . Once jetauto_ws is on your virtual machine's jetauto user directory, let's add it as a source in ~/.bashrc . First, we need to change the workspace setup script to be an executable: sudo chmod +x /home/jetauto/jetauto_ws/devel/_setup_util.py Then: echo \"source /home/jetauto/jetauto_ws/devel/setup.bash\" >> ~/.bashrc Use nano to check if the source line got added to the end of ~/.bashrc nano ~/.bashrc JetAuto Robot Model Now that the JetAuto robot workspace is on the virtual machine, let's try to simulate it in Gazebo. A robot model in URDF consists of links that are joined together to form a robot assembly. Each link has its given geometry, mass, and collision parameters. The geometry can be provided as a simple shape or a complex shape using a solid model. Before we start, let's ensure (double-check) we have the required packages installed (if you haven't installed them from the beginning of this lab) to view and test our robot model: sudo apt install ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller Next, we need to set some environment variables that our launch script will look for. Edit the system's environment variables: sudo gedit /etc/environment We'll add the following in the environment: LIDAR_TYPE=\"A1\" DEPTH_CAMERA_TYPE=\"AstraProPlus\" MACHINE_TYPE=\"JetAutoPro\" HOST=\"/\" MASTER=\"/\" Restart your virtual machine in order for the changes to take effect. Now, let's have a quick view of the URDF model. We can use RViz for visualization. A launch file allows us to start multiple nodes at once as well as define other attributes. roslaunch jetauto_description display.launch model:=urdf/jetauto.urdf You may inspect this particular launch file at the following location: ~/jetauto_ws/src/jetauto_simulations/jetauto_description/launch/display.launch In it, you'll find it starts three nodes: joint_state_publisher_gui robot_state_publisher rviz You can find more information about roslaunch and .launch files in the official ROS tutorials: roslaunch and Roslaunch tips for large projects . Once RViz is started, you can use the joint_state_publisher_gui to adjust the arm angle. Figure 4.3 JetAuto in RViz (Note: The original image caption said \"JetAuto in Gazebo\", but the context and image refer to RViz) Let's open up the JetAuto URDF model file to take a closer look at it. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto_car.urdf.xacro Here, we see a file in XML format: <robot name=\"jetauto\" xmlns:xacro=\"http://ros.org/wiki/xacro\" > <xacro:property name=\"M_PI\" value=\"3.1415926535897931\"/> <xacro:property name=\"base_link_mass\" value=\"1.6\" /> <xacro:property name=\"base_link_w\" value=\"0.297\"/> <xacro:property name=\"base_link_h\" value=\"0.145\"/> <xacro:property name=\"base_link_d\" value=\"0.11255\"/> <xacro:property name=\"wheel_link_mass\" value=\"0.1\" /> <xacro:property name=\"wheel_link_radius\" value=\"0.049\"/> <xacro:property name=\"wheel_link_length\" value=\"0.04167\"/> The first few lines define the robot's name and the basic parameters of the JetAuto's body. M_PI defines the value of \u03c0. base_link_mass defines the mass of the JetAuto\u2019s body model. base_link_w defines the width of the JetAuto\u2019s body model. base_link_h defines the height of the JetAuto\u2019s body model. base_link_d defines the length of the JetAuto\u2019s body model. wheel_link_mass defines the mass of each Mecanum wheel. wheel_link_radius defines the radius of each Mecanum wheel. The name of the robot is also defined as jetauto . <link name=\"base_footprint\"/> <joint name=\"base_joint\" type=\"fixed\"> <parent link=\"base_footprint\"/> <child link=\"base_link\"/> <origin xyz=\"0.0 0.0 0.0\" rpy=\"0 0 0\"/> </joint> base_footprint is defined as the top parent link (part) of the JetAuto model to create an overall envelope that sits at the origin. base_link is the base part of the robot that houses the battery and motor. In the URDF model, it is connected to base_footprint as a child link. This envelope configuration ensures the wheels of the robot will always be above the origin (ground). <link name=\"base_link\"> <xacro:box_inertial m=\"${base_link_mass}\" w=\"${base_link_w}\" h=\"${base_link_h}\" d=\"${base_link_d}\"/> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/base_link.stl\" /> </geometry> <material name=\"green\"/> </visual> <collision> <origin xyz=\"${base_link_w/2.0 - 0.14810} 0 ${0.126437/2 + 0.02362364}\" rpy=\"0 0 0\" /> <geometry> <box size=\"${base_link_w} ${base_link_h} ${base_link_d}\" /> </geometry> </collision> </link> Next is the link/part base_link along with its elements. The mass and inertial information of the part is defined as an XACRO element. The geometry sub-element in the visual element is provided by an stl mesh file from the jetauto_description package. The collision element is also defined as a box relative to the specified XYZ coordinate. Figure 4.4 JetAuto base_link STL <link name=\"back_shell_link\"> <inertial> <origin xyz=\"-1.22838595456587E-05 0.00218574826309681 -0.0500522861933898\" rpy=\"0 0 0\" /> <mass value=\"0.0663478534899862\" /> <inertia ixx=\"5.65277934912267E-05\" ixy=\"-5.13394387877366E-11\" ixz=\"-4.07561372273553E-11\" iyy=\"4.33740893441632E-05\" iyz=\"-5.43059341238134E-06\" izz=\"6.86642544694324E-05\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> <material name=\"black\"> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> </collision> </link> <joint name=\"back_shell_joint\" type=\"fixed\"> <origin xyz=\"-0.076481 0 0.082796\" rpy=\"-3.1416 0 1.5708\" /> <parent link=\"base_link\" /> <child link=\"back_shell_link\" /> <axis xyz=\"0 0 0\" /> </joint> The back_shell_link is the part that houses the Jetson Nano, the expansion board, and mounts the antenna. All the elements are defined in a similar manner as base_link , and it is defined as a child link of base_link with its relative position defined in joint . The wheel_XXX_link are all defined in a similar manner. The JetAuto URDF model file above only defines the mechanical structure of the robot. If we take a look at the URDF file for simulating the robot in Gazebo, we will find more links that are used and defined in other URDF files within the same package. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto.xacro If you are interested in building a URDF from scratch, visit the ROS tutorial here . Close all terminals. Running JetAuto robot in Gazebo In a terminal, launch: roslaunch jetauto_gazebo worlds.launch Gazebo should run, and you should see the JetAuto robot in the simulation environment. Figure 4.5 JetAuto in Gazebo With Gazebo and ROS running, we can now control the virtual robot the same way as the physical robot. Let's try publishing to the cmd_vel topic. Open a new terminal and run: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Stop the robot: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Do you notice the JetAuto robot listens to the same cmd_vel topics and uses the same Twist message as TurtleSim ? Let's inspect the source code of the motion controller to take a closer look. Open the file at the following path: ~/jetauto_ws/src/jetauto_driver/jetauto_controller/scripts/jetauto_controller_main.py As we can see in the controller code: linear_x = self.go_factor*msg.linear.x linear_y = self.go_factor*msg.linear.y angular_z = self.turn_factor*msg.angular.z speed_up = False if abs(self.last_linear_x - linear_x) > 0.2 or abs(self.last_linear_y - linear_y) > 0.2 or abs(self.last_angular_z - angular_z) > 1: speed_up = True self.last_linear_x = linear_x self.last_linear_y = linear_y self.last_angular_z = angular_z linear_x_, linear_y_ = linear_x * 1000.0, linear_y * 1000.0 #mm to m speed = math.sqrt(linear_x_ ** 2 + linear_y_ ** 2) direction = math.atan2(linear_y_, linear_x_) direction = math.pi * 2 + direction if direction < 0 else direction self.mecanum.set_velocity(speed, direction, angular_z, speed_up=speed_up) The Twist message from cmd_vel provides the necessary information to calculate speed , direction , and angular_z for controlling the Mecanum wheels using the MecanumChassis object. Refer to JetAuto & JetAuto Pro Resources chapter 7.3 for the working principle of the Mecanum wheel. Try other various combinations of motion commands to gain a better understanding of the robot's movement, such as changing the linear values for both x and y as well as the angular values. Next, we'll try controlling the JetAuto robot using keyboard input. In a new/other terminal, run: roslaunch jetauto_peripherals teleop_key_control.launch robot_name:=\"/\" Use w, a, s, d to control the robot. Troubleshooting: If you get a No module named 'rospkg' error, it means there are some errors with the python interpretor and the ROS package. First, ensure rospkg is installed: sudo apt install python-rospkg Troubleshooting: If the problem presist, try removing python-rospkg which will also remove a long list of ros modules. Then re-install ROS. sudo apt remove python-rospkg sudo apt install ros-melodic-desktop-full Make sure you re-install all the dependency at the start of this lab as well. Inspect the source code of the teleop controller to understand its operation by opening the file at: ~/jetauto_ws/src/jetauto_peripherals/scripts/teleop_key_control.py Lab Question Modify the controller you created from lab3 (or create a new one) so it will publish to the /jetauto_controller/cmd_vel topic for controlling the JetAuto robot in Gazebo. Hint: You can follow the same approach as Lab 3 by creating a new package called lab4_jetauto_control in your ros_ws . catkin_create_pkg lab4_jetauto_control rospy geometry_msgs Refer to the teleop_key_control.py controller you used in this lab on how to publish to the JetAuto nodes. Reference ROS Tutorials What is the Unified Robotics Description Format (URDF)? EECS 106A Labs","title":"Lab 4: Robot Model and Gazebo"},{"location":"aig240/lab4/#lab-4-robot-model-and-gazebo","text":"Seneca Polytechnic AIG240 Robotics","title":"Lab 4: Robot Model and Gazebo"},{"location":"aig240/lab4/#introduction","text":"","title":"Introduction"},{"location":"aig240/lab4/#urdf","text":"URDF (Unified Robot Description Format) is an XML format for representing a robot model. URDF is commonly used in Robot Operating System (ROS) tools such as RViz (ROS Visualization tool) and Gazebo simulator. It is essentially a 3D model with information about joints, motors, mass, etc. The files are then run through the Robot Operating System (ROS). The data from the file informs the human operator what the robot looks like and is capable of before they begin operating the robot. More details on the URDF specification can be found here . Many robotic manufacturers have URDF models of their devices available for download. These include the Segway RMP , TurtleBot , and AR10 . More Models: Agility Robotics Digit ANYbotics Anymal Boston Dynamics Spot (via Clearpath ROS Driver) Clearpath Jackal Clearpath Dingo Clearpath Husky Clearpath TurtleBot Unitree Go1 Universal Robots","title":"URDF"},{"location":"aig240/lab4/#urdf-vs-xacro","text":"URDF (Unified Robot Description Format) and XACRO (XML Macros) are both used in ROS (Robot Operating System) for robot modeling, but they have distinct roles. URDF is a straightforward XML format that describes the physical structure of a robot, detailing its links and joints, as well as their properties like geometry and dynamics. It is ideal for simpler robot designs where the model's complexity is limited. In contrast, XACRO is an extension of URDF that incorporates macros, allowing for parameterization and reducing redundancy in model descriptions. This makes XACRO particularly useful for complex robots or those with interchangeable components, as it facilitates easier maintenance and enhances readability. Typically, XACRO files are processed into URDF files before they are utilized in simulations or applications, combining the flexibility of XACRO with the straightforwardness of URDF.","title":"URDF vs XACRO"},{"location":"aig240/lab4/#rviz","text":"RViz, or Robot Visualization, is a powerful 3D visualization tool used primarily in robotics and the Robot Operating System (ROS). It enables developers to visualize and interpret a wide array of sensor data, such as point clouds, maps, and robot models, in real-time. With its interactive features, users can manipulate objects and adjust visual settings to enhance understanding of robot behavior and performance. RViz's plugin architecture allows for extensibility, accommodating various data types and visualization needs. This makes it an invaluable resource for debugging algorithms, simulating scenarios, and gaining insights into robotic systems, ultimately aiding in the development and refinement of robotics applications.","title":"RViz"},{"location":"aig240/lab4/#gazebo","text":"Gazebo is an open-source robotics simulation tool that provides a highly realistic environment for testing and developing robotic systems. It allows users to simulate robots in complex 3D environments, complete with detailed physics interactions, which include gravity, collisions, and friction. Gazebo supports a variety of sensors, such as cameras and LIDAR, enabling the generation of realistic sensor data for developing perception algorithms. Its seamless integration with the Robot Operating System (ROS) enhances its functionality, allowing developers to leverage ROS tools and libraries for robot control and communication. With a flexible plugin architecture, Gazebo can be customized to meet specific simulation needs, making it an essential platform for researchers and engineers in the field of robotics.","title":"Gazebo"},{"location":"aig240/lab4/#preparation","text":"","title":"Preparation"},{"location":"aig240/lab4/#jetauto-robot","text":"In preparation for using the JetAuto robot, please be familiar with the user manual and the basic lesson provided by the manufacturer found here: JetAuto User Manual JetAuto & JetAuto Pro Resources","title":"JetAuto Robot"},{"location":"aig240/lab4/#procedures","text":"","title":"Procedures"},{"location":"aig240/lab4/#install-gazebo-and-other-ros-packages","text":"After becoming familiar with ROS, we'll now install the Gazebo simulation environment. Install Gazebo version 9.X to be used with ROS Melodic. Each Gazebo version works with a specific version of ROS. More details about the installation can be found here . sudo apt install gazebo9 libgazebo9-dev Once installed, start Gazebo with the following command to ensure it is functional: gazebo Figure 4.1 Gazebo Running Lastly, ensure the following ROS Gazebo packages are installed: sudo apt install ros-melodic-gazebo-dev ros-melodic-gazebo-msgs ros-melodic-gazebo-plugins ros-melodic-gazebo-ros ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller ros-melodic-moveit ros-melodic-trac-ik-kinematics-plugin ros-melodic-slam-gmapping","title":"Install Gazebo and other ROS packages"},{"location":"aig240/lab4/#download-the-jetauto-workspace-to-local-machine-for-simulation","text":"For this lab, we'll use the JetAuto workspace jetauto_ws on our local virtual machine so we can test the robot locally in a simulation before programming the actual robot. Download jetauto_ws.zip and unzip it to the jetauto user's directory: /home/jetauto/ If you downloaded the file on your host machine instead of your virtual machine, you may use WinSCP to transfer the file over to your virtual machine. On your virtual machine: Open a terminal and ensure openssh-server is installed. sudo apt-get install openssh-server Enable and start SSH as necessary: sudo systemctl enable ssh sudo systemctl start ssh On your host machine: Open WinSCP and connect to: 127.0.0.1 port 22. Copy the jetauto_ws folder from jetauto_ws.zip into /home/jetauto/ . Once jetauto_ws is on your virtual machine's jetauto user directory, let's add it as a source in ~/.bashrc . First, we need to change the workspace setup script to be an executable: sudo chmod +x /home/jetauto/jetauto_ws/devel/_setup_util.py Then: echo \"source /home/jetauto/jetauto_ws/devel/setup.bash\" >> ~/.bashrc Use nano to check if the source line got added to the end of ~/.bashrc nano ~/.bashrc","title":"Download the JetAuto Workspace to Local Machine for Simulation"},{"location":"aig240/lab4/#jetauto-robot-model","text":"Now that the JetAuto robot workspace is on the virtual machine, let's try to simulate it in Gazebo. A robot model in URDF consists of links that are joined together to form a robot assembly. Each link has its given geometry, mass, and collision parameters. The geometry can be provided as a simple shape or a complex shape using a solid model. Before we start, let's ensure (double-check) we have the required packages installed (if you haven't installed them from the beginning of this lab) to view and test our robot model: sudo apt install ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller Next, we need to set some environment variables that our launch script will look for. Edit the system's environment variables: sudo gedit /etc/environment We'll add the following in the environment: LIDAR_TYPE=\"A1\" DEPTH_CAMERA_TYPE=\"AstraProPlus\" MACHINE_TYPE=\"JetAutoPro\" HOST=\"/\" MASTER=\"/\" Restart your virtual machine in order for the changes to take effect. Now, let's have a quick view of the URDF model. We can use RViz for visualization. A launch file allows us to start multiple nodes at once as well as define other attributes. roslaunch jetauto_description display.launch model:=urdf/jetauto.urdf You may inspect this particular launch file at the following location: ~/jetauto_ws/src/jetauto_simulations/jetauto_description/launch/display.launch In it, you'll find it starts three nodes: joint_state_publisher_gui robot_state_publisher rviz You can find more information about roslaunch and .launch files in the official ROS tutorials: roslaunch and Roslaunch tips for large projects . Once RViz is started, you can use the joint_state_publisher_gui to adjust the arm angle. Figure 4.3 JetAuto in RViz (Note: The original image caption said \"JetAuto in Gazebo\", but the context and image refer to RViz) Let's open up the JetAuto URDF model file to take a closer look at it. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto_car.urdf.xacro Here, we see a file in XML format: <robot name=\"jetauto\" xmlns:xacro=\"http://ros.org/wiki/xacro\" > <xacro:property name=\"M_PI\" value=\"3.1415926535897931\"/> <xacro:property name=\"base_link_mass\" value=\"1.6\" /> <xacro:property name=\"base_link_w\" value=\"0.297\"/> <xacro:property name=\"base_link_h\" value=\"0.145\"/> <xacro:property name=\"base_link_d\" value=\"0.11255\"/> <xacro:property name=\"wheel_link_mass\" value=\"0.1\" /> <xacro:property name=\"wheel_link_radius\" value=\"0.049\"/> <xacro:property name=\"wheel_link_length\" value=\"0.04167\"/> The first few lines define the robot's name and the basic parameters of the JetAuto's body. M_PI defines the value of \u03c0. base_link_mass defines the mass of the JetAuto\u2019s body model. base_link_w defines the width of the JetAuto\u2019s body model. base_link_h defines the height of the JetAuto\u2019s body model. base_link_d defines the length of the JetAuto\u2019s body model. wheel_link_mass defines the mass of each Mecanum wheel. wheel_link_radius defines the radius of each Mecanum wheel. The name of the robot is also defined as jetauto . <link name=\"base_footprint\"/> <joint name=\"base_joint\" type=\"fixed\"> <parent link=\"base_footprint\"/> <child link=\"base_link\"/> <origin xyz=\"0.0 0.0 0.0\" rpy=\"0 0 0\"/> </joint> base_footprint is defined as the top parent link (part) of the JetAuto model to create an overall envelope that sits at the origin. base_link is the base part of the robot that houses the battery and motor. In the URDF model, it is connected to base_footprint as a child link. This envelope configuration ensures the wheels of the robot will always be above the origin (ground). <link name=\"base_link\"> <xacro:box_inertial m=\"${base_link_mass}\" w=\"${base_link_w}\" h=\"${base_link_h}\" d=\"${base_link_d}\"/> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/base_link.stl\" /> </geometry> <material name=\"green\"/> </visual> <collision> <origin xyz=\"${base_link_w/2.0 - 0.14810} 0 ${0.126437/2 + 0.02362364}\" rpy=\"0 0 0\" /> <geometry> <box size=\"${base_link_w} ${base_link_h} ${base_link_d}\" /> </geometry> </collision> </link> Next is the link/part base_link along with its elements. The mass and inertial information of the part is defined as an XACRO element. The geometry sub-element in the visual element is provided by an stl mesh file from the jetauto_description package. The collision element is also defined as a box relative to the specified XYZ coordinate. Figure 4.4 JetAuto base_link STL <link name=\"back_shell_link\"> <inertial> <origin xyz=\"-1.22838595456587E-05 0.00218574826309681 -0.0500522861933898\" rpy=\"0 0 0\" /> <mass value=\"0.0663478534899862\" /> <inertia ixx=\"5.65277934912267E-05\" ixy=\"-5.13394387877366E-11\" ixz=\"-4.07561372273553E-11\" iyy=\"4.33740893441632E-05\" iyz=\"-5.43059341238134E-06\" izz=\"6.86642544694324E-05\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> <material name=\"black\"> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> </collision> </link> <joint name=\"back_shell_joint\" type=\"fixed\"> <origin xyz=\"-0.076481 0 0.082796\" rpy=\"-3.1416 0 1.5708\" /> <parent link=\"base_link\" /> <child link=\"back_shell_link\" /> <axis xyz=\"0 0 0\" /> </joint> The back_shell_link is the part that houses the Jetson Nano, the expansion board, and mounts the antenna. All the elements are defined in a similar manner as base_link , and it is defined as a child link of base_link with its relative position defined in joint . The wheel_XXX_link are all defined in a similar manner. The JetAuto URDF model file above only defines the mechanical structure of the robot. If we take a look at the URDF file for simulating the robot in Gazebo, we will find more links that are used and defined in other URDF files within the same package. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto.xacro If you are interested in building a URDF from scratch, visit the ROS tutorial here . Close all terminals.","title":"JetAuto Robot Model"},{"location":"aig240/lab4/#running-jetauto-robot-in-gazebo","text":"In a terminal, launch: roslaunch jetauto_gazebo worlds.launch Gazebo should run, and you should see the JetAuto robot in the simulation environment. Figure 4.5 JetAuto in Gazebo With Gazebo and ROS running, we can now control the virtual robot the same way as the physical robot. Let's try publishing to the cmd_vel topic. Open a new terminal and run: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Stop the robot: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Do you notice the JetAuto robot listens to the same cmd_vel topics and uses the same Twist message as TurtleSim ? Let's inspect the source code of the motion controller to take a closer look. Open the file at the following path: ~/jetauto_ws/src/jetauto_driver/jetauto_controller/scripts/jetauto_controller_main.py As we can see in the controller code: linear_x = self.go_factor*msg.linear.x linear_y = self.go_factor*msg.linear.y angular_z = self.turn_factor*msg.angular.z speed_up = False if abs(self.last_linear_x - linear_x) > 0.2 or abs(self.last_linear_y - linear_y) > 0.2 or abs(self.last_angular_z - angular_z) > 1: speed_up = True self.last_linear_x = linear_x self.last_linear_y = linear_y self.last_angular_z = angular_z linear_x_, linear_y_ = linear_x * 1000.0, linear_y * 1000.0 #mm to m speed = math.sqrt(linear_x_ ** 2 + linear_y_ ** 2) direction = math.atan2(linear_y_, linear_x_) direction = math.pi * 2 + direction if direction < 0 else direction self.mecanum.set_velocity(speed, direction, angular_z, speed_up=speed_up) The Twist message from cmd_vel provides the necessary information to calculate speed , direction , and angular_z for controlling the Mecanum wheels using the MecanumChassis object. Refer to JetAuto & JetAuto Pro Resources chapter 7.3 for the working principle of the Mecanum wheel. Try other various combinations of motion commands to gain a better understanding of the robot's movement, such as changing the linear values for both x and y as well as the angular values. Next, we'll try controlling the JetAuto robot using keyboard input. In a new/other terminal, run: roslaunch jetauto_peripherals teleop_key_control.launch robot_name:=\"/\" Use w, a, s, d to control the robot. Troubleshooting: If you get a No module named 'rospkg' error, it means there are some errors with the python interpretor and the ROS package. First, ensure rospkg is installed: sudo apt install python-rospkg Troubleshooting: If the problem presist, try removing python-rospkg which will also remove a long list of ros modules. Then re-install ROS. sudo apt remove python-rospkg sudo apt install ros-melodic-desktop-full Make sure you re-install all the dependency at the start of this lab as well. Inspect the source code of the teleop controller to understand its operation by opening the file at: ~/jetauto_ws/src/jetauto_peripherals/scripts/teleop_key_control.py","title":"Running JetAuto robot in Gazebo"},{"location":"aig240/lab4/#lab-question","text":"Modify the controller you created from lab3 (or create a new one) so it will publish to the /jetauto_controller/cmd_vel topic for controlling the JetAuto robot in Gazebo. Hint: You can follow the same approach as Lab 3 by creating a new package called lab4_jetauto_control in your ros_ws . catkin_create_pkg lab4_jetauto_control rospy geometry_msgs Refer to the teleop_key_control.py controller you used in this lab on how to publish to the JetAuto nodes.","title":"Lab Question"},{"location":"aig240/lab4/#reference","text":"ROS Tutorials What is the Unified Robotics Description Format (URDF)? EECS 106A Labs","title":"Reference"},{"location":"aig240/lab5/","text":"Lab 5 : JetAuto Robot Seneca Polytechnic AIG240 Robotics JetAuto Robot Inspection The robot we are using for this course is the JetAuto Pro assembled in the configuration: Figure 4.2 JetAuto Pro Before using the JetAuto robot, read the following: JetAuto User Manual Page 01: Guide to Battery Safety Page 03: JetAuto Pro Standard Kit Packing List Page 04-09: Installation Instruction (except for 1.4 LCD) Check all nuts and bolts to ensure confirm installation and security Page 10-11: Charging and Starting the Robot We will NOT be using the smartphone app for controlling the robot. Go through \"1.2 Install 3D Depth Camera\" on Page 4 to \"2. Start the Robot\" on Page 10-11. We will NOT be using the smartphone app for controlling the robot. NOTE: All the cables, nuts, and bolts are already installed. You are to validate that they are not missing or loose. SSH into the JetAuto Robot Copy this lab instruction somewhere on your computer as you'll lose connection to the internet! By default, the JetAuto is configured to be in Wifi AP mode. Power on the robot and connect to the robot's WiFi starting in \"HW-\". If you are unsure of which Wifi SSID is your robot broadcasting, open the \"Tool\" application on the robot and look for the AP name in the setting. Do NOT change any of the default settings. The password for the WiFi connection is: hiwonder Remember, the Wifi AP from the JetAuto have no access to the internet so it's alright to see \"No Internet\" or similar warning when connecting to it. If your robot is making a high pitch beeping sound, that means the battery voltage is low. Plugging the robot into it's charger should solve the problem but if the battery haven't been charged for a while, you might need to leave the robot off and charge it for 10-15 minutes before powering it on. Once connected, use terminal (or PuTTY) to SSH into the robot at \"192.168.149.1\". ssh jetauto@192.168.149.1 The user is: jetauto , and the password is: hiwonder Option 2: USB connection with the robot It is also possible to connect with the robot via USB using the Jetson Nano's micro-B USB port if you do not want to loose internet connection. However, you'll only be aable to use the command line interface with this method. Use screen or similar serial terminal application to connection with the robot. sudo apt-get install -y screen sudo screen /dev/ttyACM0 115200 NOTE: The port name may vary. Remote Desktop into the JetAuto Robot Only recommended to be used on within your virtual machine. For security, do not install NoMachine on your host computer and stop the NoMachine server after your installation. NoMachine is a tool that allows for remote desktop and access. It is a powerful tool that is pre-installed on the JetAuto image but use with caution as it will also automatically create a start a remote access server after installaion open up your machine for remote connection. Disconnect your computer from the JetAuto robot and re-connect to the internet to Download and Install NoMachine . After installing NoMachine, reconnect to JetAuto's Wifi AP and you should be able to search for the JetAuto robot from NoMachine. Once you are connected with the robot, the credential is the same as above. Now that you have two methods in connecting with the JetAuto robot, you may use either one to control the robot. Keep in mind, the SSH method is running off your virtual machine and connecting to JetAuto using command line where the NoMachine is connecting to JetAuto robot's actual desktop (remote desktop). GUI tools such as RViz will not work on command line interface. To conserve battery life, once you've connected to your robot, you may unplug the LCD screen but remember that the LCD screen must be plugged in during power on in order for the robot to detect it for displaying the desktop. JetAuto Robot Movement Ensure the battery charging cable is UNPLUGGED and all cables on the robot are secure. Ensure all structures, nuts and bolts on the robot are tightly fastened. Ensure the robot is on the ground and awy from any obstacles. In a terminal that's connected to the JetAuto robot using SSH or in JetAuto's terminal using remote desktop, stop the app service then start the jetauto_controller service: You must stop this service everytime you want to control the robot using your own script through ROS because the JetAuto robot automatically start an App service to allow for control using an Android or iOS application. sudo systemctl stop start_app_node.service Launch the robot controller for controlling the robot's hardware. roslaunch jetauto_controller jetauto_controller.launch Now that the controller service has started, we can publish move command as Twist message to the motion controller (similar to what we did in lab 4). Before publishing a command to the robot, remember you must issue a stop command for the robot to stop. Let's issue the stop command first so you can recall it faster. rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should not do anything. Place the robot on the ground and be ready to issue the stop command immediately after. Issue a move command to the robot in the x-direction (forward) at 0.3 m/s, x: 0.3 : rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should now start moving. Be ready to stop the robot by issuing (or up arrow twice): rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' DO NOT set the movement value above 0.7 m/s to keep the robot within its control limit. The linear values refer to the translation of the robot. Positive X is forward and positive Y is left. There is no Z-direction for this robot. Do not exceed 0.7 m/s. The angular values refer to the rotation of the robot. Only Z-rotation is considered with positive value as counter-clockwise. Do not exceed 3.5 rad/s. Next, try using the controller you created in Lab 4 to control the robot by copying you Lab 4 workspace over to the home directory on the JetAuto robot. You do not need to copy the jetauto_ws workspace as it's already on the JetAuto robot. You may use ssh, sftp, winscp, or any file transfer method. Once your new workspace is on the JetAuto robot, source it the same way as how you've done it in Lab 3 and Lab 4. Afterward, you'll be able to run the script just like how you've run it on Gazebo. Lab Question Using the code from Project 2, modify it so the JetAuto robot will move in a real-world roughly 1-meter square shape pattern as shown below. Remember, you'll be implementing it on the physical JetAuto robot so the dyanmics will not be the same. ie. You robot will most likely under or overshoot the movement. Figure 1 Square Movement Pattern Start: Move forward from (0, 0, 0\u00b0) to (1, 0, 0\u00b0) facing the direction of travel; then Move left sideway from (1, 0, 0\u00b0) to (1, 1, 0\u00b0) without turning, so the robot is facing the outside of the square; then Turn clockwise from (1, 1, 0\u00b0) to (1, 1, -90\u00b0) to face into the square; then Move right sideway from (1, 1, -90\u00b0) to (0, 1, -90\u00b0) facing the inside of the square; then Move forward and turn from (0, 1, -90\u00b0) to (0, 0, 0\u00b0) by rotating the robot while traveling. Repeat this 2 times after a start command (such as a keyboard input) is given. For example: after launching the JetAuto in Gazebo, when you run rosrun lab5_jetauto_control jetauto_control , it will ask for input before performing the above action. Hint: You can follow the same approach as Lab 3 by creating a new package called lab5_jetauto_control in your ros_ws . catkin_create_pkg lab5_jetauto_control rospy geometry_msgs Reference ROS Tutorials JetAuto User Manual EECS 106A Labs","title":"Lab 5 : JetAuto Robot"},{"location":"aig240/lab5/#lab-5-jetauto-robot","text":"Seneca Polytechnic AIG240 Robotics","title":"Lab 5 : JetAuto Robot"},{"location":"aig240/lab5/#jetauto-robot-inspection","text":"The robot we are using for this course is the JetAuto Pro assembled in the configuration: Figure 4.2 JetAuto Pro Before using the JetAuto robot, read the following: JetAuto User Manual Page 01: Guide to Battery Safety Page 03: JetAuto Pro Standard Kit Packing List Page 04-09: Installation Instruction (except for 1.4 LCD) Check all nuts and bolts to ensure confirm installation and security Page 10-11: Charging and Starting the Robot We will NOT be using the smartphone app for controlling the robot. Go through \"1.2 Install 3D Depth Camera\" on Page 4 to \"2. Start the Robot\" on Page 10-11. We will NOT be using the smartphone app for controlling the robot. NOTE: All the cables, nuts, and bolts are already installed. You are to validate that they are not missing or loose.","title":"JetAuto Robot Inspection"},{"location":"aig240/lab5/#ssh-into-the-jetauto-robot","text":"Copy this lab instruction somewhere on your computer as you'll lose connection to the internet! By default, the JetAuto is configured to be in Wifi AP mode. Power on the robot and connect to the robot's WiFi starting in \"HW-\". If you are unsure of which Wifi SSID is your robot broadcasting, open the \"Tool\" application on the robot and look for the AP name in the setting. Do NOT change any of the default settings. The password for the WiFi connection is: hiwonder Remember, the Wifi AP from the JetAuto have no access to the internet so it's alright to see \"No Internet\" or similar warning when connecting to it. If your robot is making a high pitch beeping sound, that means the battery voltage is low. Plugging the robot into it's charger should solve the problem but if the battery haven't been charged for a while, you might need to leave the robot off and charge it for 10-15 minutes before powering it on. Once connected, use terminal (or PuTTY) to SSH into the robot at \"192.168.149.1\". ssh jetauto@192.168.149.1 The user is: jetauto , and the password is: hiwonder","title":"SSH into the JetAuto Robot"},{"location":"aig240/lab5/#option-2-usb-connection-with-the-robot","text":"It is also possible to connect with the robot via USB using the Jetson Nano's micro-B USB port if you do not want to loose internet connection. However, you'll only be aable to use the command line interface with this method. Use screen or similar serial terminal application to connection with the robot. sudo apt-get install -y screen sudo screen /dev/ttyACM0 115200 NOTE: The port name may vary.","title":"Option 2: USB connection with the robot"},{"location":"aig240/lab5/#remote-desktop-into-the-jetauto-robot","text":"Only recommended to be used on within your virtual machine. For security, do not install NoMachine on your host computer and stop the NoMachine server after your installation. NoMachine is a tool that allows for remote desktop and access. It is a powerful tool that is pre-installed on the JetAuto image but use with caution as it will also automatically create a start a remote access server after installaion open up your machine for remote connection. Disconnect your computer from the JetAuto robot and re-connect to the internet to Download and Install NoMachine . After installing NoMachine, reconnect to JetAuto's Wifi AP and you should be able to search for the JetAuto robot from NoMachine. Once you are connected with the robot, the credential is the same as above. Now that you have two methods in connecting with the JetAuto robot, you may use either one to control the robot. Keep in mind, the SSH method is running off your virtual machine and connecting to JetAuto using command line where the NoMachine is connecting to JetAuto robot's actual desktop (remote desktop). GUI tools such as RViz will not work on command line interface. To conserve battery life, once you've connected to your robot, you may unplug the LCD screen but remember that the LCD screen must be plugged in during power on in order for the robot to detect it for displaying the desktop.","title":"Remote Desktop into the JetAuto Robot"},{"location":"aig240/lab5/#jetauto-robot-movement","text":"Ensure the battery charging cable is UNPLUGGED and all cables on the robot are secure. Ensure all structures, nuts and bolts on the robot are tightly fastened. Ensure the robot is on the ground and awy from any obstacles. In a terminal that's connected to the JetAuto robot using SSH or in JetAuto's terminal using remote desktop, stop the app service then start the jetauto_controller service: You must stop this service everytime you want to control the robot using your own script through ROS because the JetAuto robot automatically start an App service to allow for control using an Android or iOS application. sudo systemctl stop start_app_node.service Launch the robot controller for controlling the robot's hardware. roslaunch jetauto_controller jetauto_controller.launch Now that the controller service has started, we can publish move command as Twist message to the motion controller (similar to what we did in lab 4). Before publishing a command to the robot, remember you must issue a stop command for the robot to stop. Let's issue the stop command first so you can recall it faster. rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should not do anything. Place the robot on the ground and be ready to issue the stop command immediately after. Issue a move command to the robot in the x-direction (forward) at 0.3 m/s, x: 0.3 : rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should now start moving. Be ready to stop the robot by issuing (or up arrow twice): rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' DO NOT set the movement value above 0.7 m/s to keep the robot within its control limit. The linear values refer to the translation of the robot. Positive X is forward and positive Y is left. There is no Z-direction for this robot. Do not exceed 0.7 m/s. The angular values refer to the rotation of the robot. Only Z-rotation is considered with positive value as counter-clockwise. Do not exceed 3.5 rad/s. Next, try using the controller you created in Lab 4 to control the robot by copying you Lab 4 workspace over to the home directory on the JetAuto robot. You do not need to copy the jetauto_ws workspace as it's already on the JetAuto robot. You may use ssh, sftp, winscp, or any file transfer method. Once your new workspace is on the JetAuto robot, source it the same way as how you've done it in Lab 3 and Lab 4. Afterward, you'll be able to run the script just like how you've run it on Gazebo.","title":"JetAuto Robot Movement"},{"location":"aig240/lab5/#lab-question","text":"Using the code from Project 2, modify it so the JetAuto robot will move in a real-world roughly 1-meter square shape pattern as shown below. Remember, you'll be implementing it on the physical JetAuto robot so the dyanmics will not be the same. ie. You robot will most likely under or overshoot the movement. Figure 1 Square Movement Pattern Start: Move forward from (0, 0, 0\u00b0) to (1, 0, 0\u00b0) facing the direction of travel; then Move left sideway from (1, 0, 0\u00b0) to (1, 1, 0\u00b0) without turning, so the robot is facing the outside of the square; then Turn clockwise from (1, 1, 0\u00b0) to (1, 1, -90\u00b0) to face into the square; then Move right sideway from (1, 1, -90\u00b0) to (0, 1, -90\u00b0) facing the inside of the square; then Move forward and turn from (0, 1, -90\u00b0) to (0, 0, 0\u00b0) by rotating the robot while traveling. Repeat this 2 times after a start command (such as a keyboard input) is given. For example: after launching the JetAuto in Gazebo, when you run rosrun lab5_jetauto_control jetauto_control , it will ask for input before performing the above action. Hint: You can follow the same approach as Lab 3 by creating a new package called lab5_jetauto_control in your ros_ws . catkin_create_pkg lab5_jetauto_control rospy geometry_msgs","title":"Lab Question"},{"location":"aig240/lab5/#reference","text":"ROS Tutorials JetAuto User Manual EECS 106A Labs","title":"Reference"},{"location":"aig240/project1/","text":"Project 1 - Setting up ROS1 and TurtleSim Seneca Polytechnic AIG240 Robotics Due: Sunday, Jun 1, 2025 at 11:59PM on Blackboard Weight: 10% Introduction In this project, you will demonstrate your achievement in setting up a ROS1 environment and creating a simple node to control a robot using TurtleSim. Objectives Set up the ROS1 environment. Create a simple ROS node to control a robot. Answer assessment questions. NOTE: This project must be completed individually. Seneca Academic Integrity Policy Seneca Generative Artificial Intelligence (GenAI) Policy Step 1: Set Up Your ROS Environment Install ROS1 as per the Lab 1 instructions. Create your ROS workspace as per the Lab 3 instructions. Step 2: Create and Run a Simple ROS Node Use open-source code, AI-generated code, or your own code to create a controller as described below (and in Lab 3 ) to make the robot move in TurtleSim. Your node should do the following: Accept a command line argument specifying the name of the turtle it should control. i.e., running rosrun lab3_turtlesim turtle_controller turtle1 will start a controller node that controls turtle1 . Use w , a , s , d (and q , e , c , and z ) to control the turtle by publish velocity control messages on the appropriate topic whenever the user presses those keys on the keyboard, as in the original turtle_teleop_key . The turtle should ONLY move when is key is pressed. When the key is released, the turtle should STOP moving. Option 1 (Easy) Single keypress: In addition to just forward/backward and turns, the turtle should move forward and turn left in a circular path if q is pressed and similar for e , c , and z in their corresponding direction. Option 2 (Hard) Multiple keypress: If you want to challenge your Python skills, make the controller so it listen to multiple keys. i.e., if w + a are pressed, the turtle should move forward and turn left in a circular path. If the keys pressed are contracdicting, there should be no movement. You'll need to install additional Python package to achieve this. Hint: You'll need to use the Twist message type in the geometry_msgs package. Hint: Refer to the turtle_teleop_key source code as a reference. Assessment Questions What command did you use to create a ROS package? Explain why and how you used ROS messages in your program. Describe the steps to launch ROS, TurtleSim, and your ROS node simultaneously. How do you verify that your ROS node is publishing messages correctly? Submission A link to your project folder (e.g., on GitHub (private) or Google Drive) containing all the necessary files and code. A video showing your code running in TurtleSim and the robot moving. A text file containing the answers to the questions for every group member. Late Submission Penalty A 25% reduction from the full mark will be applied for every 24 hours the submission is late after the deadline.","title":"Project 1 - Setting up ROS1 and TurtleSim"},{"location":"aig240/project1/#project-1-setting-up-ros1-and-turtlesim","text":"Seneca Polytechnic AIG240 Robotics Due: Sunday, Jun 1, 2025 at 11:59PM on Blackboard Weight: 10%","title":"Project 1 - Setting up ROS1 and TurtleSim"},{"location":"aig240/project1/#introduction","text":"In this project, you will demonstrate your achievement in setting up a ROS1 environment and creating a simple node to control a robot using TurtleSim.","title":"Introduction"},{"location":"aig240/project1/#objectives","text":"Set up the ROS1 environment. Create a simple ROS node to control a robot. Answer assessment questions. NOTE: This project must be completed individually. Seneca Academic Integrity Policy Seneca Generative Artificial Intelligence (GenAI) Policy","title":"Objectives"},{"location":"aig240/project1/#step-1-set-up-your-ros-environment","text":"Install ROS1 as per the Lab 1 instructions. Create your ROS workspace as per the Lab 3 instructions.","title":"Step 1: Set Up Your ROS Environment"},{"location":"aig240/project1/#step-2-create-and-run-a-simple-ros-node","text":"Use open-source code, AI-generated code, or your own code to create a controller as described below (and in Lab 3 ) to make the robot move in TurtleSim. Your node should do the following: Accept a command line argument specifying the name of the turtle it should control. i.e., running rosrun lab3_turtlesim turtle_controller turtle1 will start a controller node that controls turtle1 . Use w , a , s , d (and q , e , c , and z ) to control the turtle by publish velocity control messages on the appropriate topic whenever the user presses those keys on the keyboard, as in the original turtle_teleop_key . The turtle should ONLY move when is key is pressed. When the key is released, the turtle should STOP moving. Option 1 (Easy) Single keypress: In addition to just forward/backward and turns, the turtle should move forward and turn left in a circular path if q is pressed and similar for e , c , and z in their corresponding direction. Option 2 (Hard) Multiple keypress: If you want to challenge your Python skills, make the controller so it listen to multiple keys. i.e., if w + a are pressed, the turtle should move forward and turn left in a circular path. If the keys pressed are contracdicting, there should be no movement. You'll need to install additional Python package to achieve this. Hint: You'll need to use the Twist message type in the geometry_msgs package. Hint: Refer to the turtle_teleop_key source code as a reference.","title":"Step 2: Create and Run a Simple ROS Node"},{"location":"aig240/project1/#assessment-questions","text":"What command did you use to create a ROS package? Explain why and how you used ROS messages in your program. Describe the steps to launch ROS, TurtleSim, and your ROS node simultaneously. How do you verify that your ROS node is publishing messages correctly?","title":"Assessment Questions"},{"location":"aig240/project1/#submission","text":"A link to your project folder (e.g., on GitHub (private) or Google Drive) containing all the necessary files and code. A video showing your code running in TurtleSim and the robot moving. A text file containing the answers to the questions for every group member.","title":"Submission"},{"location":"aig240/project1/#late-submission-penalty","text":"A 25% reduction from the full mark will be applied for every 24 hours the submission is late after the deadline.","title":"Late Submission Penalty"},{"location":"aig240/project2/","text":"Project 2 - Moving JetAuto in Gazebo Seneca Polytechnic AIG240 Robotics Due: Sunday, June 15, 2025 at 11:59 PM on Blackboard Weight: 10% Introduction In this project, you will demonstrate your achievement in setting up a ROS1 environment and creating a simple node to control a robot using Gazebo. Objectives Set up the Gazebo environment to work with ROS. Create a simple ROS node to control a robot in Gazebo. Answer assessment questions. NOTE: This project must be completed individually. Seneca Academic Integrity Policy Seneca Generative Artificial Intelligence (GenAI) Policy Step 1: Set Up Your Gazebo Environment Install Gazebo as per the Lab 4 instructions. Create your new ROS workspace (or use the same one) as per the Lab 3 instructions. Step 2: Create and Run a Simple ROS Node Use open-source code, AI-generated code, or your own code to create a control script as described below to make the JetAuto robot move according to a pattern in Gazebo. Write code that will move the JetAuto robot in a roughly 1-meter square shape pattern as follows: Figure 1 Square Movement Pattern Start: Move forward from (0, 0, 0\u00b0) to (1, 0, 0\u00b0) facing the direction of travel; then Move left sideway from (1, 0, 0\u00b0) to (1, 1, 0\u00b0) without turning, so the robot is facing the outside of the square; then Turn clockwise from (1, 1, 0\u00b0) to (1, 1, -90\u00b0) to face into the square; then Move right sideway from (1, 1, -90\u00b0) to (0, 1, -90\u00b0) facing the inside of the square; then Move forward and turn from (0, 1, -90\u00b0) to (0, 0, 0\u00b0) by rotating the robot while traveling. Repeat this 2 times after a start command (such as a keyboard input) is given. For example: after launching the JetAuto in Gazebo, when you run rosrun lab4_jetauto_control jetauto_control , it will ask for input before performing the above action. Hint: You can follow the same approach as Lab 3 by creating a new package called lab4_jetauto_control in your ros_ws . catkin_create_pkg lab4_jetauto_control rospy geometry_msgs Refer to the teleop_key_control.py controller you used in lab4 on how to publish to the JetAuto nodes. Assessment Questions What command did you use to launch the JetAuto robot in Gazebo? Which two other launch files were called when you launched worlds.launch ? Hint: Inspect the launch files in jetauto_ws/src/jetauto_simulation/jetauto_gazebo/launch . Describe the process of setting up the ROS workspace and creating the package. How do you estimate that the robot moved roughly 1 meter in each of the steps? What challenges did you face with making the robot move in a straight line while turning, and how did you overcome them? Submission A link to your project folder (e.g., on GitHub (private) or Google Drive) containing all the necessary files and code. A video showing your code running in Gazebo and the robot moving. A text file containing the answers to the questions for every group member. Late Submission Penalty A 25% reduction from the full mark will be applied for every 24 hours the submission is late after the deadline.","title":"Project 2 - Moving JetAuto in Gazebo"},{"location":"aig240/project2/#project-2-moving-jetauto-in-gazebo","text":"Seneca Polytechnic AIG240 Robotics Due: Sunday, June 15, 2025 at 11:59 PM on Blackboard Weight: 10%","title":"Project 2 - Moving JetAuto in Gazebo"},{"location":"aig240/project2/#introduction","text":"In this project, you will demonstrate your achievement in setting up a ROS1 environment and creating a simple node to control a robot using Gazebo.","title":"Introduction"},{"location":"aig240/project2/#objectives","text":"Set up the Gazebo environment to work with ROS. Create a simple ROS node to control a robot in Gazebo. Answer assessment questions. NOTE: This project must be completed individually. Seneca Academic Integrity Policy Seneca Generative Artificial Intelligence (GenAI) Policy","title":"Objectives"},{"location":"aig240/project2/#step-1-set-up-your-gazebo-environment","text":"Install Gazebo as per the Lab 4 instructions. Create your new ROS workspace (or use the same one) as per the Lab 3 instructions.","title":"Step 1: Set Up Your Gazebo Environment"},{"location":"aig240/project2/#step-2-create-and-run-a-simple-ros-node","text":"Use open-source code, AI-generated code, or your own code to create a control script as described below to make the JetAuto robot move according to a pattern in Gazebo. Write code that will move the JetAuto robot in a roughly 1-meter square shape pattern as follows: Figure 1 Square Movement Pattern Start: Move forward from (0, 0, 0\u00b0) to (1, 0, 0\u00b0) facing the direction of travel; then Move left sideway from (1, 0, 0\u00b0) to (1, 1, 0\u00b0) without turning, so the robot is facing the outside of the square; then Turn clockwise from (1, 1, 0\u00b0) to (1, 1, -90\u00b0) to face into the square; then Move right sideway from (1, 1, -90\u00b0) to (0, 1, -90\u00b0) facing the inside of the square; then Move forward and turn from (0, 1, -90\u00b0) to (0, 0, 0\u00b0) by rotating the robot while traveling. Repeat this 2 times after a start command (such as a keyboard input) is given. For example: after launching the JetAuto in Gazebo, when you run rosrun lab4_jetauto_control jetauto_control , it will ask for input before performing the above action. Hint: You can follow the same approach as Lab 3 by creating a new package called lab4_jetauto_control in your ros_ws . catkin_create_pkg lab4_jetauto_control rospy geometry_msgs Refer to the teleop_key_control.py controller you used in lab4 on how to publish to the JetAuto nodes.","title":"Step 2: Create and Run a Simple ROS Node"},{"location":"aig240/project2/#assessment-questions","text":"What command did you use to launch the JetAuto robot in Gazebo? Which two other launch files were called when you launched worlds.launch ? Hint: Inspect the launch files in jetauto_ws/src/jetauto_simulation/jetauto_gazebo/launch . Describe the process of setting up the ROS workspace and creating the package. How do you estimate that the robot moved roughly 1 meter in each of the steps? What challenges did you face with making the robot move in a straight line while turning, and how did you overcome them?","title":"Assessment Questions"},{"location":"aig240/project2/#submission","text":"A link to your project folder (e.g., on GitHub (private) or Google Drive) containing all the necessary files and code. A video showing your code running in Gazebo and the robot moving. A text file containing the answers to the questions for every group member.","title":"Submission"},{"location":"aig240/project2/#late-submission-penalty","text":"A 25% reduction from the full mark will be applied for every 24 hours the submission is late after the deadline.","title":"Late Submission Penalty"},{"location":"aig240/project3/","text":"Project 3 - Moving JetAuto in Real World Seneca Polytechnic AIG240 Robotics Due: Wednesday, July 9, 2025 at 11:59 PM on Blackboard Weight: 10% Introduction In this project, you will demonstrate your achievement in programming a real robot to navigate a fixed pattern. This project will help you understand how to communicate and program a real robot. Objectives Set up the physical robot. Create a simple ROS node to control a robot in real world. Answer assessment questions. NOTE: This project must be completed individually. Seneca Academic Integrity Policy Seneca Generative Artificial Intelligence (GenAI) Policy Step 1: Set Up and Inspect JetAuto Robot In groups of up to 3 students, set Up and Inspect JetAuto Robot. Follow the instruction provided by the instructor. Step 2: Create and Run a Simple ROS Node Use open-source code, AI-generated code, or your own code to create a control script as described below to make the physical JetAuto robot move according to a pattern. Write code that will move the JetAuto robot in a roughly 1-meter square shape pattern as follows: Figure 1 Square Movement Pattern Start: Move forward from (0, 0, 0\u00b0) to (1, 0, 0\u00b0) facing the direction of travel; then Move left sideway from (1, 0, 0\u00b0) to (1, 1, 0\u00b0) without turning, so the robot is facing the outside of the square; then Turn clockwise from (1, 1, 0\u00b0) to (1, 1, -90\u00b0) to face into the square; then Move right sideway from (1, 1, -90\u00b0) to (0, 1, -90\u00b0) facing the inside of the square; then Move forward and turn from (0, 1, -90\u00b0) to (0, 0, 0\u00b0) by rotating the robot while traveling. Repeat this 2 times after a start command (such as a keyboard input) is given. Run this on the real world robot. Assessment Questions How did you establish communication with the robot? How different is controlling the robot in Gazebo vs the real world? How do you control that the robot moved roughly 1 meter in each of the steps? What challenges did you face making the robot move in the real physical world? Submission A link to your project folder (e.g., on GitHub (private) or Google Drive) containing all the necessary files and code. A video showing your code running in Gazebo and the robot moving. A text file containing the answers to the questions for every group member. Late Submission Penalty A 25% reduction from the full mark will be applied for every 24 hours the submission is late after the deadline.","title":"Project 3 - Moving JetAuto in Real World"},{"location":"aig240/project3/#project-3-moving-jetauto-in-real-world","text":"Seneca Polytechnic AIG240 Robotics Due: Wednesday, July 9, 2025 at 11:59 PM on Blackboard Weight: 10%","title":"Project 3 - Moving JetAuto in Real World"},{"location":"aig240/project3/#introduction","text":"In this project, you will demonstrate your achievement in programming a real robot to navigate a fixed pattern. This project will help you understand how to communicate and program a real robot.","title":"Introduction"},{"location":"aig240/project3/#objectives","text":"Set up the physical robot. Create a simple ROS node to control a robot in real world. Answer assessment questions. NOTE: This project must be completed individually. Seneca Academic Integrity Policy Seneca Generative Artificial Intelligence (GenAI) Policy","title":"Objectives"},{"location":"aig240/project3/#step-1-set-up-and-inspect-jetauto-robot","text":"In groups of up to 3 students, set Up and Inspect JetAuto Robot. Follow the instruction provided by the instructor.","title":"Step 1: Set Up and Inspect JetAuto Robot"},{"location":"aig240/project3/#step-2-create-and-run-a-simple-ros-node","text":"Use open-source code, AI-generated code, or your own code to create a control script as described below to make the physical JetAuto robot move according to a pattern. Write code that will move the JetAuto robot in a roughly 1-meter square shape pattern as follows: Figure 1 Square Movement Pattern Start: Move forward from (0, 0, 0\u00b0) to (1, 0, 0\u00b0) facing the direction of travel; then Move left sideway from (1, 0, 0\u00b0) to (1, 1, 0\u00b0) without turning, so the robot is facing the outside of the square; then Turn clockwise from (1, 1, 0\u00b0) to (1, 1, -90\u00b0) to face into the square; then Move right sideway from (1, 1, -90\u00b0) to (0, 1, -90\u00b0) facing the inside of the square; then Move forward and turn from (0, 1, -90\u00b0) to (0, 0, 0\u00b0) by rotating the robot while traveling. Repeat this 2 times after a start command (such as a keyboard input) is given. Run this on the real world robot.","title":"Step 2: Create and Run a Simple ROS Node"},{"location":"aig240/project3/#assessment-questions","text":"How did you establish communication with the robot? How different is controlling the robot in Gazebo vs the real world? How do you control that the robot moved roughly 1 meter in each of the steps? What challenges did you face making the robot move in the real physical world?","title":"Assessment Questions"},{"location":"aig240/project3/#submission","text":"A link to your project folder (e.g., on GitHub (private) or Google Drive) containing all the necessary files and code. A video showing your code running in Gazebo and the robot moving. A text file containing the answers to the questions for every group member.","title":"Submission"},{"location":"aig240/project3/#late-submission-penalty","text":"A 25% reduction from the full mark will be applied for every 24 hours the submission is late after the deadline.","title":"Late Submission Penalty"},{"location":"sea700/","text":"SEA700 Lab Manual Labs: Lab Safety Lab 1 : Intro to ROS and TurtleSim Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions Lab 3 : ROS Workspace, Package, Publisher and Subscriber Lab 4 : Robot Model, Gazebo and JetAuto Lab 5 : Robotic Arm and SLAM Reference Document: JetAuto User Manual","title":"SEA700 Robotics for Engineer"},{"location":"sea700/#sea700-lab-manual","text":"Labs: Lab Safety Lab 1 : Intro to ROS and TurtleSim Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions Lab 3 : ROS Workspace, Package, Publisher and Subscriber Lab 4 : Robot Model, Gazebo and JetAuto Lab 5 : Robotic Arm and SLAM Reference Document: JetAuto User Manual","title":"SEA700 Lab Manual"},{"location":"sea700/extra/","text":"Jetson Nano Board Go through all the Chapter 6 lesson in the JetAuto & JetAuto Pro Resources to understand more functionality of the Jetson Nano board. roslaunch jetauto_peripherals imu.launch rostopic echo /imu_data roslaunch jetauto_controller odom_publish.launch rostopic echo /odom_raw","title":"Extra"},{"location":"sea700/extra/#jetson-nano-board","text":"Go through all the Chapter 6 lesson in the JetAuto & JetAuto Pro Resources to understand more functionality of the Jetson Nano board. roslaunch jetauto_peripherals imu.launch rostopic echo /imu_data roslaunch jetauto_controller odom_publish.launch rostopic echo /odom_raw","title":"Jetson Nano Board"},{"location":"sea700/lab-safety/","text":"Lab Safety Seneca Polytechnic SEA700 Robotics for Software Engineers Objectives Review of Laboratory First Aid and Safety Procedures Emergency Contact In case of life threatening emergency: Call 911 for fire, medical, or police Then call campus security: 416-764-0911 for assistance Laboratory First Aid and Safety Procedures Lab Safety Presentation Slides","title":"Lab Safety"},{"location":"sea700/lab-safety/#lab-safety","text":"Seneca Polytechnic SEA700 Robotics for Software Engineers","title":"Lab Safety"},{"location":"sea700/lab-safety/#objectives","text":"Review of Laboratory First Aid and Safety Procedures","title":"Objectives"},{"location":"sea700/lab-safety/#emergency-contact","text":"In case of life threatening emergency: Call 911 for fire, medical, or police Then call campus security: 416-764-0911 for assistance","title":"Emergency Contact"},{"location":"sea700/lab-safety/#laboratory-first-aid-and-safety-procedures","text":"Lab Safety Presentation Slides","title":"Laboratory First Aid and Safety Procedures"},{"location":"sea700/lab1/","text":"Lab 1 : Intro to ROS and TurtleSim Seneca Polytechnic SEA700 Robotics for Software Engineers Introduction In this course, you'll be using the JetAuto Pro ROS Robot Car as the base platform for development. The JetAuto robot uses the NVIDIA Jetson Nano embedded computing boards as its controller. The robot comes with various accessories and add-ons for robotics applications and they can all be controlled using Robot Operating System (ROS) as the backbone application. However, before jumping into using the physical, we will be learning how to use ROS and Gazebo to simulate the robot and it's environmental. During the design phase of any robotics project, testing the functionality of your code and the robot is a key step of project cycle. In some industrial settings (such as robot in remote location), physical access to the robot are limited or impossible. In such a case, simulating the robot's action and performance is the only way to ensure mission success. What is ROS? Per the ROS website: The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it's all open source. The above statement isn't exactly clear so let's take a look at an example. Figure 1.1 Robotics Arm (Source: Hiwonder) A robotics system usually consist of various sensors, actuators, and controllers. The system in Figure 1.1 have the following: a servo gripper at the end of the arm a servo revolute joint that rotate the gripper a servo revolute joint for link 3-2 a servo revolute joint for link 4-3 a servo revolute joint for link 5-4 a servo revolute joint that rotate the base a stationary camera supervise the workspace To pick up an object, the robot might: Use the camera to measure the position of the object Command the arm to move toward the object's position Once in position, command the gripper to close around the object To approach this problem, we'll need to break it down into smaller task. In robotics, that usually means having independent low-level control loops, each controlling a single task. A control loop for each joint that, given a position or velocity command, controls the power applied to the joint motor based on position sensor measurements at the joint. Another control loop that receives commands to open or close the gripper, then switches the gripper motor on and off while controlling the power applied to it to avoid crushing objects. A sensing loop that reads individual images from the camera With the above structure, we then couple these low-level loops together via a single high-level module that performs supervisory control of the whole system: Query the camera sensing loop for a single image Use a vision algorithm to compute the location of the object to grasp Compute the joint angles necessary to move the manipulator arm to this location Sends position commands to each of the joint control loops telling them to move to this position Signal the gripper control loop to close the gripper to grab the object An important feature of this design is that the supervisor need not know the implementation details of any of the low-level control loops: it interacts with each only through simple control messages. This encapsulation of functionality makes the system modular, making it easier to reuse code across robotic platforms. In ROS, each individual control loop is known as a node, an individual software process that performs a specific task. Nodes exchange control messages, sensor readings, and other data by publishing or subscribing to topics or by sending requests to services offered by other nodes (these concepts will be discussed in detail later in the lab). Nodes can be written in a variety of languages (including Python and C++), and ROS transparently handles the details of converting between different datatypes, exchanging messages between nodes, etc. We can then visualize the communication and interaction between different software components via a computation graph, where: Figure 1.2 Example computation graph Nodes are represented by ovals (ie. /usb_cam or /ar_track_alvar ). Topics are represented by rectangles (ie. /usb_cam/camera_info and /usb_cam/image_raw ). The flow of information to and from topics and represented by arrows. In the above example, /usb_cam publishes to the topics /usb_cam/camera_info and /usb_cam/image_raw , which are subscribed to by /ar_track_alvar . While not shown here, services would be represented by dotted arrows. Procedures Ubuntu Installation For this course, we'll be using the following software environment Ubuntu 18.04 LTS (Bionic Beaver) . If you are using Windows or macOS, ensure Ubuntu 18.04 LTS (Bionic Beaver) and ROS Melodic is installed as it is the version used by the JetAuto robot. Install Ubuntu 18.04 LTS (Bionic Beaver) on your computer or virtual machine (VirtualBox recommended). OS Image: ubuntu-18.04.6-desktop-amd64.iso Ensure there are at least 2 processor core, 4GB of memory, and 20GB of disk drive Ensure to use username: jetauto as this is the username used by the JetAuto robot to maximize compartibility of code ROS Installation Follow the ROS Melodic Installation instruction to install the ROS Desktop-Full package into your system. You do NOT need to install the Bare Bones or Individual Package Since we want our terminal to load the ROS source everytime it start, add the source command to .bashrc . echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc Or use vi , vim or any editor to open ~/.bashrc in your user's home directory then add the following code at the end. source /opt/ros/melodic/setup.bash After ROS installation and setting up .bashrc , we'll also want to install a few tools to help build ROS packages. To install this tool and other dependencies for building ROS packages, run: sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential Before you can use many ROS tools, you will need to initialize rosdep . rosdep enables you to easily install system dependencies for source you want to compile and is required to run some core components in ROS. With the following, you can initialize rosdep . sudo rosdep init rosdep update Since Melodic is not longer a support distro, we'll need to explicitly update it. rosdep update --rosdistro=melodic Turtlesim Test Turtlesim is a lightweight simulator for learning ROS. It illustrates what ROS does at the most basic level to give you an idea of what you will do with a real robot or a robot simulation later on. Using roscore roscore is the first thing you should run when using ROS. It starts the ROS master node, the centralized server for managing nodes, topics, services, communication, and more. It is typically the main entry point and the first for running any ROS system. In a terminal, run: roscore You will see something similar to: ... logging to ~/.ros/log/9cf88ce4-b14d-11df-8a75-00251148e8cf/roslaunch-machine_name-13039.log Checking log directory for disk usage. This may take awhile. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is <1GB. started roslaunch server http://machine_name:33919/ ros_comm version 1.4.7 SUMMARY ====== PARAMETERS * /rosversion * /rosdistro NODES auto-starting new master process[master]: started with pid [13054] ROS_MASTER_URI=http://machine_name:11311/ setting /run_id to 9cf88ce4-b14d-11df-8a75-00251148e8cf process[rosout-1]: started with pid [13067] started core service [/rosout] Using rosrun The command rosrun allows you to use the package name to directly run a node within a package (without having to know the package path). Usage: rosrun [package_name] [node_name] . So now we can run the turtlesim_node in the turtlesim package. In a new terminal: rosrun turtlesim turtlesim_node The simulator window should appear, with a random turtle in the center. Figure 1.3 TurtleSim Open a new terminal to run a new node to control the turtle in the first node. If you didn't add the source code in .bashrc , you'll need to source ROS again. rosrun turtlesim turtle_teleop_key At this point you should have four windows open: a terminal running roscore , a terminal running turtlesim_node , a terminal running turtle_teleop_key and the \"turtlesim window\". Arrange these windows so that you can see the turtlesim window, but also have the terminal running turtle_teleop_key active so that you can control the turtle in turtlesim. Use the arrow keys on your keyboard to control the turtle. It will move around the screen, using its attached \u201cpen\u201d to draw the path it followed so far. Figure 1.4 TurtleSim Use rqt rqt is a graphical user interface (GUI) tool for ROS. Everything done in rqt can be done on the command line, but rqt provides a more user-friendly way to manipulate ROS elements. Open a new terminal and run rqt. rqt When running rqt for the first time, the window will be blank. No worries; just select Plugins > Services > Service Caller from the menu bar at the top. Figure 1.5 rqt Use the refresh button to the left of the Service dropdown list to ensure all the services of your turtlesim node are available. Click on the Service dropdown list to see turtlesim\u2019s services, and select the /spawn service to spawn another turtle. Give the new turtle a unique name, like turtle2 , by double-clicking between the empty single quotes in the Expression column. You can see that this expression corresponds to the value of name and is of type string . Next enter some valid coordinates at which to spawn the new turtle, like x = 1.0 and y = 1.0 . Figure 1.5 rqt spawn If you try to spawn a new turtle with the same name as an existing turtle, you will get an error message in the terminal running turtlesim_node . Call the spawn service by clicking the Call button on the upper right side of the rqt window. You should see a new turtle (with a random design) spawn at the coordinates you input for x and y. Refresh the service list in rqt and you will also see that now there are services related to the new turtle, /turtle2/... , in addition to /turtle1/... . Next, we'll give turtle1 an unique pen using the /set_pen service and have turtle1 draw with a distinct red line by changing the value of r to 255 , and the value of width to 5 . Don\u2019t forget to call the service after updating the values. Figure 1.6 rqt set_pen Return to the terminal where turtle_teleop_key is running and press the arrow keys, you will see turtle1 \u2019s pen has changed. Figure 1.7 TurtleSim Turtles Remapping turtle_teleop_key To control turtle2 , you need a second teleop node. However, if you try to run the same command as before, you will notice that this one also controls turtle1. The way to change this behavior is by remapping the cmd_vel topic. In a new terminal, source ROS, and run: rosrun turtlesim turtle_teleop_key turtle1/cmd_vel:=turtle2/cmd_vel Now, you can move turtle2 when this terminal is active, and turtle1 when the other terminal running turtle_teleop_key is active. Figure 1.8 TurtleSim Turtles Lab Question Create a third turtle that you can control in turtlesim with green (g = 255) as the pen line colour. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab. Reference ROS Tutorials EECS 106A Labs","title":"Lab 1 : Intro to ROS and TurtleSim"},{"location":"sea700/lab1/#lab-1-intro-to-ros-and-turtlesim","text":"Seneca Polytechnic SEA700 Robotics for Software Engineers","title":"Lab 1 : Intro to ROS and TurtleSim"},{"location":"sea700/lab1/#introduction","text":"In this course, you'll be using the JetAuto Pro ROS Robot Car as the base platform for development. The JetAuto robot uses the NVIDIA Jetson Nano embedded computing boards as its controller. The robot comes with various accessories and add-ons for robotics applications and they can all be controlled using Robot Operating System (ROS) as the backbone application. However, before jumping into using the physical, we will be learning how to use ROS and Gazebo to simulate the robot and it's environmental. During the design phase of any robotics project, testing the functionality of your code and the robot is a key step of project cycle. In some industrial settings (such as robot in remote location), physical access to the robot are limited or impossible. In such a case, simulating the robot's action and performance is the only way to ensure mission success.","title":"Introduction"},{"location":"sea700/lab1/#what-is-ros","text":"Per the ROS website: The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it's all open source. The above statement isn't exactly clear so let's take a look at an example. Figure 1.1 Robotics Arm (Source: Hiwonder) A robotics system usually consist of various sensors, actuators, and controllers. The system in Figure 1.1 have the following: a servo gripper at the end of the arm a servo revolute joint that rotate the gripper a servo revolute joint for link 3-2 a servo revolute joint for link 4-3 a servo revolute joint for link 5-4 a servo revolute joint that rotate the base a stationary camera supervise the workspace To pick up an object, the robot might: Use the camera to measure the position of the object Command the arm to move toward the object's position Once in position, command the gripper to close around the object To approach this problem, we'll need to break it down into smaller task. In robotics, that usually means having independent low-level control loops, each controlling a single task. A control loop for each joint that, given a position or velocity command, controls the power applied to the joint motor based on position sensor measurements at the joint. Another control loop that receives commands to open or close the gripper, then switches the gripper motor on and off while controlling the power applied to it to avoid crushing objects. A sensing loop that reads individual images from the camera With the above structure, we then couple these low-level loops together via a single high-level module that performs supervisory control of the whole system: Query the camera sensing loop for a single image Use a vision algorithm to compute the location of the object to grasp Compute the joint angles necessary to move the manipulator arm to this location Sends position commands to each of the joint control loops telling them to move to this position Signal the gripper control loop to close the gripper to grab the object An important feature of this design is that the supervisor need not know the implementation details of any of the low-level control loops: it interacts with each only through simple control messages. This encapsulation of functionality makes the system modular, making it easier to reuse code across robotic platforms. In ROS, each individual control loop is known as a node, an individual software process that performs a specific task. Nodes exchange control messages, sensor readings, and other data by publishing or subscribing to topics or by sending requests to services offered by other nodes (these concepts will be discussed in detail later in the lab). Nodes can be written in a variety of languages (including Python and C++), and ROS transparently handles the details of converting between different datatypes, exchanging messages between nodes, etc. We can then visualize the communication and interaction between different software components via a computation graph, where: Figure 1.2 Example computation graph Nodes are represented by ovals (ie. /usb_cam or /ar_track_alvar ). Topics are represented by rectangles (ie. /usb_cam/camera_info and /usb_cam/image_raw ). The flow of information to and from topics and represented by arrows. In the above example, /usb_cam publishes to the topics /usb_cam/camera_info and /usb_cam/image_raw , which are subscribed to by /ar_track_alvar . While not shown here, services would be represented by dotted arrows.","title":"What is ROS?"},{"location":"sea700/lab1/#procedures","text":"","title":"Procedures"},{"location":"sea700/lab1/#ubuntu-installation","text":"For this course, we'll be using the following software environment Ubuntu 18.04 LTS (Bionic Beaver) . If you are using Windows or macOS, ensure Ubuntu 18.04 LTS (Bionic Beaver) and ROS Melodic is installed as it is the version used by the JetAuto robot. Install Ubuntu 18.04 LTS (Bionic Beaver) on your computer or virtual machine (VirtualBox recommended). OS Image: ubuntu-18.04.6-desktop-amd64.iso Ensure there are at least 2 processor core, 4GB of memory, and 20GB of disk drive Ensure to use username: jetauto as this is the username used by the JetAuto robot to maximize compartibility of code","title":"Ubuntu Installation"},{"location":"sea700/lab1/#ros-installation","text":"Follow the ROS Melodic Installation instruction to install the ROS Desktop-Full package into your system. You do NOT need to install the Bare Bones or Individual Package Since we want our terminal to load the ROS source everytime it start, add the source command to .bashrc . echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc Or use vi , vim or any editor to open ~/.bashrc in your user's home directory then add the following code at the end. source /opt/ros/melodic/setup.bash After ROS installation and setting up .bashrc , we'll also want to install a few tools to help build ROS packages. To install this tool and other dependencies for building ROS packages, run: sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential Before you can use many ROS tools, you will need to initialize rosdep . rosdep enables you to easily install system dependencies for source you want to compile and is required to run some core components in ROS. With the following, you can initialize rosdep . sudo rosdep init rosdep update Since Melodic is not longer a support distro, we'll need to explicitly update it. rosdep update --rosdistro=melodic","title":"ROS Installation"},{"location":"sea700/lab1/#turtlesim-test","text":"Turtlesim is a lightweight simulator for learning ROS. It illustrates what ROS does at the most basic level to give you an idea of what you will do with a real robot or a robot simulation later on.","title":"Turtlesim Test"},{"location":"sea700/lab1/#using-roscore","text":"roscore is the first thing you should run when using ROS. It starts the ROS master node, the centralized server for managing nodes, topics, services, communication, and more. It is typically the main entry point and the first for running any ROS system. In a terminal, run: roscore You will see something similar to: ... logging to ~/.ros/log/9cf88ce4-b14d-11df-8a75-00251148e8cf/roslaunch-machine_name-13039.log Checking log directory for disk usage. This may take awhile. Press Ctrl-C to interrupt Done checking log file disk usage. Usage is <1GB. started roslaunch server http://machine_name:33919/ ros_comm version 1.4.7 SUMMARY ====== PARAMETERS * /rosversion * /rosdistro NODES auto-starting new master process[master]: started with pid [13054] ROS_MASTER_URI=http://machine_name:11311/ setting /run_id to 9cf88ce4-b14d-11df-8a75-00251148e8cf process[rosout-1]: started with pid [13067] started core service [/rosout]","title":"Using roscore"},{"location":"sea700/lab1/#using-rosrun","text":"The command rosrun allows you to use the package name to directly run a node within a package (without having to know the package path). Usage: rosrun [package_name] [node_name] . So now we can run the turtlesim_node in the turtlesim package. In a new terminal: rosrun turtlesim turtlesim_node The simulator window should appear, with a random turtle in the center. Figure 1.3 TurtleSim Open a new terminal to run a new node to control the turtle in the first node. If you didn't add the source code in .bashrc , you'll need to source ROS again. rosrun turtlesim turtle_teleop_key At this point you should have four windows open: a terminal running roscore , a terminal running turtlesim_node , a terminal running turtle_teleop_key and the \"turtlesim window\". Arrange these windows so that you can see the turtlesim window, but also have the terminal running turtle_teleop_key active so that you can control the turtle in turtlesim. Use the arrow keys on your keyboard to control the turtle. It will move around the screen, using its attached \u201cpen\u201d to draw the path it followed so far. Figure 1.4 TurtleSim","title":"Using rosrun"},{"location":"sea700/lab1/#use-rqt","text":"rqt is a graphical user interface (GUI) tool for ROS. Everything done in rqt can be done on the command line, but rqt provides a more user-friendly way to manipulate ROS elements. Open a new terminal and run rqt. rqt When running rqt for the first time, the window will be blank. No worries; just select Plugins > Services > Service Caller from the menu bar at the top. Figure 1.5 rqt Use the refresh button to the left of the Service dropdown list to ensure all the services of your turtlesim node are available. Click on the Service dropdown list to see turtlesim\u2019s services, and select the /spawn service to spawn another turtle. Give the new turtle a unique name, like turtle2 , by double-clicking between the empty single quotes in the Expression column. You can see that this expression corresponds to the value of name and is of type string . Next enter some valid coordinates at which to spawn the new turtle, like x = 1.0 and y = 1.0 . Figure 1.5 rqt spawn If you try to spawn a new turtle with the same name as an existing turtle, you will get an error message in the terminal running turtlesim_node . Call the spawn service by clicking the Call button on the upper right side of the rqt window. You should see a new turtle (with a random design) spawn at the coordinates you input for x and y. Refresh the service list in rqt and you will also see that now there are services related to the new turtle, /turtle2/... , in addition to /turtle1/... . Next, we'll give turtle1 an unique pen using the /set_pen service and have turtle1 draw with a distinct red line by changing the value of r to 255 , and the value of width to 5 . Don\u2019t forget to call the service after updating the values. Figure 1.6 rqt set_pen Return to the terminal where turtle_teleop_key is running and press the arrow keys, you will see turtle1 \u2019s pen has changed. Figure 1.7 TurtleSim Turtles","title":"Use rqt"},{"location":"sea700/lab1/#remapping-turtle_teleop_key","text":"To control turtle2 , you need a second teleop node. However, if you try to run the same command as before, you will notice that this one also controls turtle1. The way to change this behavior is by remapping the cmd_vel topic. In a new terminal, source ROS, and run: rosrun turtlesim turtle_teleop_key turtle1/cmd_vel:=turtle2/cmd_vel Now, you can move turtle2 when this terminal is active, and turtle1 when the other terminal running turtle_teleop_key is active. Figure 1.8 TurtleSim Turtles","title":"Remapping turtle_teleop_key"},{"location":"sea700/lab1/#lab-question","text":"Create a third turtle that you can control in turtlesim with green (g = 255) as the pen line colour. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab Question"},{"location":"sea700/lab1/#reference","text":"ROS Tutorials EECS 106A Labs","title":"Reference"},{"location":"sea700/lab2/","text":"Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions Seneca Polytechnic SEA700 Robotics for Software Engineers Introduction A overview of some computation graph concepts: Node: an executable representing an individual ROS software process Topic: nodes can publish messages to a topic and/or subscribe to a topic to receive messages Message: a ROS datatype used to exchange data between nodes Nodes in ROS Each node in ROS should be responsible for a single, modular purpose, ie. controlling the wheel motors or publishing the sensor data from a laser range-finder. Each node can send and receive data from other nodes via topics, services, actions, or parameters. A full robotic system is comprised of many nodes working in concert. Figure 2.1 ROS Nodes Graph Topics in ROS ROS breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages. Figure 2.2 ROS Topic Graph A node may publish data to any number of topics and simultaneously have subscriptions to any number of topics. Figure 2.3 ROS Topic Graph (One-to-Many) Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system. Service in ROS Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model versus the publisher-subscriber model of topics. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. Figure 2.4 ROS Service Single Node Figure 2.5 ROS Service Multiple Node Parameter in ROS A parameter is a configuration value of a node. You can think of parameters as node settings. A node can store parameters as integers, floats, booleans, strings, and lists. In ROS, each node maintains its own parameters. Procedures Understanding ROS Nodes Open a terminal to run ROS using roscore and another tmerinal to run turtlesim. The command rosrun [package_name] [node_name] launches an executable from a package. We need the package name to be turtlesim and the executable name to be turtlesim_node . roscore Then, in a new terminal: rosrun turtlesim turtlesim_node To find the node names, the rosnode list can be used. rosnode list will show you the names of all running nodes. This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them. Open a new terminal while /rosout and /turtlesim is still running and enter the following command: rosnode list The terminal will return the node name: /rosout /turtlesim Open another new terminal and start the teleop node with the command: rosrun turtlesim turtle_teleop_keyy Return to the terminal where you ran rosnode list and run it again. You will now see the names of three active nodes: /rosout /turtlesim /teleop_turtle Remapping allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values. Let\u2019s open another /turtlesim node and reassign the name to /my_turtle . In a new terminal, run the following command: rosrun turtlesim turtlesim_node __name:=my_turtle Return to the terminal where you ran rosnode list , and run it again, you will see four node names: /my_turtle /rosout /turtlesim /teleop_turtle To access more information about a node, use the following command: rosnode info [node_name] . To examine your latest node, my_turtle , run the following command: rosnode info /my_turtle rosnode info returns a list of subscribers, publishers, services, and actions. i.e. the ROS graph connections that interact with that node. The output should look like this: -------------------------------------------------------------------------------- Node [/my_turtle] Publications: * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose] Subscriptions: * /turtle1/cmd_vel [geometry_msgs/Twist] Services: * /clear * /kill * /my_turtle/get_loggers * /my_turtle/set_logger_level * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative Run the same comand on the /teleop_turtle node and see the difference. Understanding ROS Topics Close the /my_turtle terminal so only the /turtlesim and /teleop_turtle are open. We will use rqt_graph to visualize the changing nodes and topics, as well as the connections between them. Open a new terminal and enter the command: rqt_graph You can also open rqt_graph by opening rqt and selecting Plugins > Introspection > Node Graph . Figure 2.6 ROS rqt_graph You should see the above nodes and topics, as well as two actions around the periphery of the graph (let\u2019s ignore those for now). If you don't see the the nodes and topics, click the refresh button. If you hover your mouse over the topic in the center, you\u2019ll see the colour highlighting like in the image above. The graph shows how the /turtlesim node and the /teleop_turtle node are communicating with each other over a topic. The /teleop_turtle node is publishing data (the keystrokes you enter to move the turtle around) to the /turtle1/cmd_vel topic, and the /turtlesim node is subscribed to that topic to receive the data. The highlighting feature of rqt_graph is very helpful when examining more complex systems with many nodes and topics connected in many different ways. rqt_graph is a graphical introspection tool. Now we\u2019ll look at some command line tools for introspecting topics. Open another terminal and run the rostopic list command to return a list of all the topics currently active in the system: /rosout /rosout_agg /statistics /turtle1/cmd_vel /turtle1/color_sensor /turtle1/pose Running the code with an additional argument rostopic list -v will return more details on the topics with the topic type appended in brackets: Published topics: * /turtle1/color_sensor [turtlesim/Color] 2 publishers * /turtle1/cmd_vel [geometry_msgs/Twist] 1 publisher * /rosout [rosgraph_msgs/Log] 4 publishers * /rosout_agg [rosgraph_msgs/Log] 1 publisher * /turtle1/pose [turtlesim/Pose] 2 publishers Subscribed topics: * /turtle1/cmd_vel [geometry_msgs/Twist] 2 subscribers * /rosout [rosgraph_msgs/Log] 1 subscriber * /statistics [rosgraph_msgs/TopicStatistics] 1 subscriber These attributes, particularly the type, are how nodes know they\u2019re talking about the same information as it moves over topics. If you\u2019re wondering where all these topics are in rqt_graph , you can uncheck all the boxes under Hide : Figure 2.7 ROS rqt_graph with everything unhidden To see the data being published on a topic, use: rostopic echo [topic] . Since we know that /teleop_turtle publishes data to /turtlesim over the /turtle1/cmd_vel topic, let\u2019s use echo to introspect that topic: rostopic echo /turtle1/cmd_vel Return to the terminal where turtle_teleop_key is running and use the arrows to move the turtle around. Watch the terminal where your echo is running at the same time, and you\u2019ll see position data being published for every movement you make: linear: x: 2.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.0 --- Return to rqt_graph and unhide the Debug box, hide everything else, then refresh. Figure 2.8 ROS rqt_graph with debug node A new node /rostopic_XXXXX is created by the echo command we just ran (the number might be different). Now you can see that the publisher is publishing data over the cmd_vel topic, and two subscribers are subscribed to it (the two arrows with /turtle/cmd_vel ). Nodes send data over topics using messages. Publishers and subscribers must send and receive the same type of message to communicate. The topic types we saw earlier after running rostopic list -v let us know what message type is used on each topic. Recall that the cmd_vel topic has the type geometry_msgs/Twist . This means that in the package geometry_msgs there is a type called Twist . Alternatively, We can run rostopic type [topic] to see the topic type. We can also run rosmsg show [msg type] on the type to learn its details. Specifically, what structure of data the message expects. rostopic type /turtle1/cmd_vel You should get: geometry_msgs/Twist Look at the details of the message using rosmsg : rosmsg show geometry_msgs/Twist For the message type from above, you should see: geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z This tells you that the /turtlesim node is expecting a message with two vectors, linear and angular , of three elements each. If you recall the data we saw /teleop_turtle passing to /turtlesim with the echo command earlier. Now that you have the message structure, you can publish data to a topic directly from the command line using: rostopic pub [topic] [msg_type] [args] . The [args] argument is the actual data you\u2019ll pass to the topic, in the structure you just discovered in the previous section. It\u2019s important to note that this argument needs to be input in YAML syntax. Input the full command like so: rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' --once is an optional argument meaning \u201cpublish one message then exit\u201d. You will see your turtle move like so: Figure 2.9 The turtle starts moving in a circle This is a pretty complicated example, so lets look at each argument in detail. This command will publish messages to a given topic: rostopic pub This option (dash-one) causes rostopic to only publish one message then exit: -1 This is the name of the topic to publish to: /turtle1/cmd_vel This is the message type to use when publishing to the topic: geometry_msgs/Twist This option (double-dash) tells the option parser that none of the following arguments is an option. This is required in cases where your arguments have a leading dash -, like negative numbers. -- As noted before, a geometry_msgs/Twist msg has two vectors of three floating point elements each: linear and angular . In this case, '[2.0, 0.0, 0.0]' becomes the linear value with x=2.0 , y=0.0 , and z=0.0 , and '[0.0, 0.0, 1.8]' is the angular value with x=0.0 , y=0.0 , and z=1.8 . These arguments are actually in YAML syntax, which is described more in the YAML command line documentation . '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' In order to continuously operate the turtle (and commonly a real robot which it is meant to emulate) require a steady stream of commands. So, to get the turtle to keep moving, you can run: rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' The difference here is the removal of the -1 (for --once ) option and the addition of the -r 1 (for --rate 1 ) option, which tells rostopic pub to publish the command in a steady stream at 1 Hz. Figure 2.10 The turtle moving in a circle Refresh rqt_graph to see what\u2019s happening graphically. You will see a new rostopic pub ... node ( /rostopic_3330 in the figure) is publishing over the /turtle1/cmd_vel topic, which is being received by both the rostopic echo ... node ( /rostopic_3663 in the figure) and the /turtlesim node now. Figure 2.11 ROS rqt_graph of turtle moving in a circle Next, in a new terminal, run echo on the pose topic and recheck rqt_graph : rosopic echo /turtle1/pose Figure 2.12 ROS rqt_graph of turtle moving in a circle with pose You can see that the /turtlesim node is also publishing to the pose topic, which the new echo node has subscribed to. Understanding ROS Services Leave roscore , rosrun turtlesim turtlesim_node and rosrun turtlesim turtle_teleop_key open and close all the other terminal. Open a new terminal and run the rosservice list command to return a list of all the services currently active in the system: /clear /kill /reset /rosout/get_loggers /rosout/set_logger_level /spawn /teleop_turtle/get_loggers /teleop_turtle/set_logger_level /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/get_loggers /turtlesim/set_logger_level Let's look more closely at the turtlesim-specific services, /clear , /kill , /reset , /spawn , /turtle1/set_pen , /turtle1/teleport_absolute , and /turtle1/teleport_relative . You may recall interacting with some of these services using rqt. Services have types that describe how the request and response data of a service is structured. Service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response. To find out the type of a service, use the command: rosservice type [service] Let\u2019s take a look at turtlesim\u2019s /clear service. In a new terminal, enter the command: rosservice type /clear Which should return: std_srvs/Empty The std_srvs/Empty type means the service call sends no data when making a request and receives no data when receiving a response. If you want to find all the services of a specific type, you can use the command: rosservice find [type_name] . For example, you can find all the Empty typed services like this: rosservice find std_srvs/Empty Which will return: /clear /reset You can call services from the command line, but first you need to know the structure of the input arguments by using rossrv show [type_name] . Try this on the /clear service\u2019s type, std_srvs/Empty : rossrv show std_srvs/Empty Which will return: --- The --- separates the request structure (above) from the response structure (below). But, as you learned earlier, the std_srvs/Empty type doesn\u2019t send or receive any data. So, naturally, its structure is blank. Let\u2019s introspect a service with a type that sends and receives data, like /spawn . From the results of rosservice type /spawn , we know /spawn \u2019s type is turtlesim/Spawn . To see the request and response arguments of the /spawn service, we can pass the return value of the rosservice command to the rossrv command by running the command: rosservice type /spawn | rossrv show Which will return: float32 x float32 y float32 theta string name --- string name The information above the --- line tells us the arguments needed to call /spawn . x , y and theta determine the 2D pose of the spawned turtle, and name is optional. The information below the --- line isn\u2019t something you need to know in this case, but it can help you understand the data type of the response you get from the call. Now that you know what a service type is, how to find a service\u2019s type, and how to find the structure of that type\u2019s arguments, you can call a service using: rosservice call [service_name] [service_type] [arguments] . The [arguments] part is optional. For example, you know that Empty typed services don\u2019t have any arguments: rosservice call /clear This command will clear the turtlesim window of any lines your turtle has drawn. Figure 2.13 Turtlesim with line Figure 2.14 Turtlesim cleared Now let\u2019s spawn a new turtle by calling /spawn and setting arguments. Input [arguments] in a service call from the command-line need to be in YAML syntax. Enter the command: rosservice call /spawn 2 2 0.2 \"\" You will get this service response: name: turtle2 Your turtlesim window will update with the newly spawned turtle right away: Figure 2.15 Turtlesim Spawn Understanding ROS Parameters rosparam allows you to store and manipulate data on the ROS Parameter Server . The Parameter Server can store integers, floats, boolean, dictionaries, and lists. rosparam uses the YAML markup language for syntax. In simple cases, YAML looks very natural: 1 is an integer, 1.0 is a float, one is a string, true is a boolean, [1, 2, 3] is a list of integers, and {a: b, c: d} is a dictionary. rosparam has many commands that can be used on parameters, as shown below: Usage: rosparam set set parameter rosparam get get parameter rosparam load load parameters from file rosparam dump dump parameters to file rosparam delete delete parameter rosparam list list parameter names To see the parameters belonging to your nodes, enter the command: rosparam list You will see the node namespaces, /teleop_turtle and /turtlesim , followed by each node\u2019s parameters: /rosdistro /roslaunch/uris/host_ubuntu_18__37467 /rosversion /run_id /turtlesim/background_b /turtlesim/background_g /turtlesim/background_r Based on their names, it looks like /turtlesim \u2019s parameters determine the background color of the turtlesim window using RGB color values. To display the type and current value of a parameter, use the command: rosparam get [param_name] . Let\u2019s find out the current value of /turtlesim \u2019s parameter background_g : rosparam get /turtlesim/background_g Which will return the value: 86 Now you know background_g holds an integer value. If you run the same command on background_r and background_b , you will get the values 69 and 255 , respectively. To change a parameter\u2019s value at runtime, use the command: rosparam set [param_name] . Let\u2019s change /turtlesim \u2019s background color: rosparam set /turtlesim/background_r 150 This changes the parameter value, now we have to call the clear service for the parameter change to take effect: rosservice call /clear And the background of your turtlesim window should change colors: Figure 2.16 Turtlesim Purple Understanding Recording and Playback rosbag is a command line tool for recording data published on topics in your system. It accumulates the data passed on any number of topics and saves it in a database. You can then replay the data to reproduce the results of your tests and experiments. Recording topics is also a great way to share your work and allow others to recreate it. rosbag can only record data from published messages in topics. Earlier in the lab, you learned that the /turtle_teleop node publishes commands on the /turtle1/cmd_vel topic to make the turtle move in turtlesim . Restart roscore , rosrun turtlesim turtlesim_node and ro run turtlesim turtle_teleop_key open and close all the other terminal. Let\u2019s also make a new directory to store our saved recordings, just as good practice. Open a new terminal and run: mkdir ~/bag_files cd ~/bag_files To record the data published to a topic use the command syntax: rosbag record [topic_name] . Run the command: rosbag record /turtle1/cmd_vel You will see the following messages in the terminal (the date and time will be different): [ INFO] [1727727815.120194012]: Subscribing to /turtle1/cmd_vel [ INFO] [1727727815.122105256]: Recording to '2024-09-30-16-23-35.bag'. Now rosbag is recording the data published on the /turtle1/cmd_vel topic. Return to the teleop terminal and move the turtle around again. The movements don\u2019t matter, but try to make a recognizable pattern to see when you replay the data later. Figure 2.17 Turtlesim Recording Press Ctrl+C to stop recording. The data will be accumulated in a new bag directory with a name in the pattern of year_month_day-hour-minute-second . You can also record multiple topics, as well as change the name of the file rosbag saves to. Run the following command: rosbag record -O subset /turtle1/cmd_vel /turtle1/pose The -O option allows you to choose a unique name for your bag file. The following string, in this case subset , is the file name. To record more than one topic at a time, simply list each topic separated by a space or you can use the -a to record all topics. You will see the following message, confirming that both topics are being recorded. [ INFO] [1727728178.421665012]: Subscribing to /turtle1/cmd_vel [ INFO] [1727728178.425904027]: Subscribing to /turtle1/pose [ INFO] [1727728178.430928233]: Recording to 'subset.bag'. You can move the turtle around and press Ctrl+C when you\u2019re finished. You can see details about your recording by running: rosbag info <bag_file_name> . Running this command on the subset bag file will return a list of information on the file: rosbag info subset.bag You should see something like: path: subset.bag version: 2.0 duration: 35.5s start: Sep 30 2024 16:29:38.64 (1727728178.64) end: Sep 30 2024 16:30:14.15 (1727728214.15) size: 184.7 KB messages: 2307 compression: none [1/1 chunks] types: geometry_msgs/Twist [9f195f881246fdfa2798d1d3eebca84a] turtlesim/Pose [863b248d5016ca62ea2e895ae5265cf9] topics: /turtle1/cmd_vel 92 msgs : geometry_msgs/Twist /turtle1/pose 2215 msgs : turtlesim/Pose Before replaying the bag file, enter Ctrl+C in the terminal where the teleop is running. Then make sure your turtlesim window is visible so you can see the bag file in action. Enter the command: rosbag play subset The terminal will return the message: [ INFO] [1727728462.171253911]: Opening subset.bag Waiting 0.2 seconds after advertising topics... done. Hit space to toggle paused, or 's' to step. [DELAYED] Bag Time: ... After some time, your turtle will follow the same path you entered while recording (though not 100% exactly; turtlesim is sensitive to small changes in the system\u2019s timing). Figure 2.18 Turtlesim Recording Because the subset file recorded the /turtle1/pose topic , the rosbag play command will be recording for as long as you had turtlesim running, even if you weren\u2019t moving. This is because as long as the /turtlesim node is active, it publishes data on the /turtle1/pose topic at regular intervals. You may have noticed in the rosbag info example result above that the /turtle1/cmd_vel topic\u2019s Count information was only 92; that\u2019s how many times we pressed the arrow keys while recording. Notice that /turtle1/pose has a Count value of over 2000; while we were recording, data was published on that topic over 2000 times. Lab Question Change the background of turtlesim to orange or cyan then create a recording of a turtle performing a \"Figure 8\" path (clockwise circle followed by counter-clockwise circle). Play it back. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab. Reference ROS Tutorials EECS 106A Labs","title":"Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions"},{"location":"sea700/lab2/#lab-2-ros-nodes-topics-services-parameters-actions","text":"Seneca Polytechnic SEA700 Robotics for Software Engineers","title":"Lab 2 : ROS Nodes, Topics, Services, Parameters, Actions"},{"location":"sea700/lab2/#introduction","text":"A overview of some computation graph concepts: Node: an executable representing an individual ROS software process Topic: nodes can publish messages to a topic and/or subscribe to a topic to receive messages Message: a ROS datatype used to exchange data between nodes","title":"Introduction"},{"location":"sea700/lab2/#nodes-in-ros","text":"Each node in ROS should be responsible for a single, modular purpose, ie. controlling the wheel motors or publishing the sensor data from a laser range-finder. Each node can send and receive data from other nodes via topics, services, actions, or parameters. A full robotic system is comprised of many nodes working in concert. Figure 2.1 ROS Nodes Graph","title":"Nodes in ROS"},{"location":"sea700/lab2/#topics-in-ros","text":"ROS breaks complex systems down into many modular nodes. Topics are a vital element of the ROS graph that act as a bus for nodes to exchange messages. Figure 2.2 ROS Topic Graph A node may publish data to any number of topics and simultaneously have subscriptions to any number of topics. Figure 2.3 ROS Topic Graph (One-to-Many) Topics are one of the main ways in which data is moved between nodes and therefore between different parts of the system.","title":"Topics in ROS"},{"location":"sea700/lab2/#service-in-ros","text":"Services are another method of communication for nodes in the ROS graph. Services are based on a call-and-response model versus the publisher-subscriber model of topics. While topics allow nodes to subscribe to data streams and get continual updates, services only provide data when they are specifically called by a client. Figure 2.4 ROS Service Single Node Figure 2.5 ROS Service Multiple Node","title":"Service in ROS"},{"location":"sea700/lab2/#parameter-in-ros","text":"A parameter is a configuration value of a node. You can think of parameters as node settings. A node can store parameters as integers, floats, booleans, strings, and lists. In ROS, each node maintains its own parameters.","title":"Parameter in ROS"},{"location":"sea700/lab2/#procedures","text":"","title":"Procedures"},{"location":"sea700/lab2/#understanding-ros-nodes","text":"Open a terminal to run ROS using roscore and another tmerinal to run turtlesim. The command rosrun [package_name] [node_name] launches an executable from a package. We need the package name to be turtlesim and the executable name to be turtlesim_node . roscore Then, in a new terminal: rosrun turtlesim turtlesim_node To find the node names, the rosnode list can be used. rosnode list will show you the names of all running nodes. This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them. Open a new terminal while /rosout and /turtlesim is still running and enter the following command: rosnode list The terminal will return the node name: /rosout /turtlesim Open another new terminal and start the teleop node with the command: rosrun turtlesim turtle_teleop_keyy Return to the terminal where you ran rosnode list and run it again. You will now see the names of three active nodes: /rosout /turtlesim /teleop_turtle Remapping allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values. Let\u2019s open another /turtlesim node and reassign the name to /my_turtle . In a new terminal, run the following command: rosrun turtlesim turtlesim_node __name:=my_turtle Return to the terminal where you ran rosnode list , and run it again, you will see four node names: /my_turtle /rosout /turtlesim /teleop_turtle To access more information about a node, use the following command: rosnode info [node_name] . To examine your latest node, my_turtle , run the following command: rosnode info /my_turtle rosnode info returns a list of subscribers, publishers, services, and actions. i.e. the ROS graph connections that interact with that node. The output should look like this: -------------------------------------------------------------------------------- Node [/my_turtle] Publications: * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose] Subscriptions: * /turtle1/cmd_vel [geometry_msgs/Twist] Services: * /clear * /kill * /my_turtle/get_loggers * /my_turtle/set_logger_level * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative Run the same comand on the /teleop_turtle node and see the difference.","title":"Understanding ROS Nodes"},{"location":"sea700/lab2/#understanding-ros-topics","text":"Close the /my_turtle terminal so only the /turtlesim and /teleop_turtle are open. We will use rqt_graph to visualize the changing nodes and topics, as well as the connections between them. Open a new terminal and enter the command: rqt_graph You can also open rqt_graph by opening rqt and selecting Plugins > Introspection > Node Graph . Figure 2.6 ROS rqt_graph You should see the above nodes and topics, as well as two actions around the periphery of the graph (let\u2019s ignore those for now). If you don't see the the nodes and topics, click the refresh button. If you hover your mouse over the topic in the center, you\u2019ll see the colour highlighting like in the image above. The graph shows how the /turtlesim node and the /teleop_turtle node are communicating with each other over a topic. The /teleop_turtle node is publishing data (the keystrokes you enter to move the turtle around) to the /turtle1/cmd_vel topic, and the /turtlesim node is subscribed to that topic to receive the data. The highlighting feature of rqt_graph is very helpful when examining more complex systems with many nodes and topics connected in many different ways. rqt_graph is a graphical introspection tool. Now we\u2019ll look at some command line tools for introspecting topics. Open another terminal and run the rostopic list command to return a list of all the topics currently active in the system: /rosout /rosout_agg /statistics /turtle1/cmd_vel /turtle1/color_sensor /turtle1/pose Running the code with an additional argument rostopic list -v will return more details on the topics with the topic type appended in brackets: Published topics: * /turtle1/color_sensor [turtlesim/Color] 2 publishers * /turtle1/cmd_vel [geometry_msgs/Twist] 1 publisher * /rosout [rosgraph_msgs/Log] 4 publishers * /rosout_agg [rosgraph_msgs/Log] 1 publisher * /turtle1/pose [turtlesim/Pose] 2 publishers Subscribed topics: * /turtle1/cmd_vel [geometry_msgs/Twist] 2 subscribers * /rosout [rosgraph_msgs/Log] 1 subscriber * /statistics [rosgraph_msgs/TopicStatistics] 1 subscriber These attributes, particularly the type, are how nodes know they\u2019re talking about the same information as it moves over topics. If you\u2019re wondering where all these topics are in rqt_graph , you can uncheck all the boxes under Hide : Figure 2.7 ROS rqt_graph with everything unhidden To see the data being published on a topic, use: rostopic echo [topic] . Since we know that /teleop_turtle publishes data to /turtlesim over the /turtle1/cmd_vel topic, let\u2019s use echo to introspect that topic: rostopic echo /turtle1/cmd_vel Return to the terminal where turtle_teleop_key is running and use the arrows to move the turtle around. Watch the terminal where your echo is running at the same time, and you\u2019ll see position data being published for every movement you make: linear: x: 2.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.0 --- Return to rqt_graph and unhide the Debug box, hide everything else, then refresh. Figure 2.8 ROS rqt_graph with debug node A new node /rostopic_XXXXX is created by the echo command we just ran (the number might be different). Now you can see that the publisher is publishing data over the cmd_vel topic, and two subscribers are subscribed to it (the two arrows with /turtle/cmd_vel ). Nodes send data over topics using messages. Publishers and subscribers must send and receive the same type of message to communicate. The topic types we saw earlier after running rostopic list -v let us know what message type is used on each topic. Recall that the cmd_vel topic has the type geometry_msgs/Twist . This means that in the package geometry_msgs there is a type called Twist . Alternatively, We can run rostopic type [topic] to see the topic type. We can also run rosmsg show [msg type] on the type to learn its details. Specifically, what structure of data the message expects. rostopic type /turtle1/cmd_vel You should get: geometry_msgs/Twist Look at the details of the message using rosmsg : rosmsg show geometry_msgs/Twist For the message type from above, you should see: geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z This tells you that the /turtlesim node is expecting a message with two vectors, linear and angular , of three elements each. If you recall the data we saw /teleop_turtle passing to /turtlesim with the echo command earlier. Now that you have the message structure, you can publish data to a topic directly from the command line using: rostopic pub [topic] [msg_type] [args] . The [args] argument is the actual data you\u2019ll pass to the topic, in the structure you just discovered in the previous section. It\u2019s important to note that this argument needs to be input in YAML syntax. Input the full command like so: rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' --once is an optional argument meaning \u201cpublish one message then exit\u201d. You will see your turtle move like so: Figure 2.9 The turtle starts moving in a circle This is a pretty complicated example, so lets look at each argument in detail. This command will publish messages to a given topic: rostopic pub This option (dash-one) causes rostopic to only publish one message then exit: -1 This is the name of the topic to publish to: /turtle1/cmd_vel This is the message type to use when publishing to the topic: geometry_msgs/Twist This option (double-dash) tells the option parser that none of the following arguments is an option. This is required in cases where your arguments have a leading dash -, like negative numbers. -- As noted before, a geometry_msgs/Twist msg has two vectors of three floating point elements each: linear and angular . In this case, '[2.0, 0.0, 0.0]' becomes the linear value with x=2.0 , y=0.0 , and z=0.0 , and '[0.0, 0.0, 1.8]' is the angular value with x=0.0 , y=0.0 , and z=1.8 . These arguments are actually in YAML syntax, which is described more in the YAML command line documentation . '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]' In order to continuously operate the turtle (and commonly a real robot which it is meant to emulate) require a steady stream of commands. So, to get the turtle to keep moving, you can run: rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]' The difference here is the removal of the -1 (for --once ) option and the addition of the -r 1 (for --rate 1 ) option, which tells rostopic pub to publish the command in a steady stream at 1 Hz. Figure 2.10 The turtle moving in a circle Refresh rqt_graph to see what\u2019s happening graphically. You will see a new rostopic pub ... node ( /rostopic_3330 in the figure) is publishing over the /turtle1/cmd_vel topic, which is being received by both the rostopic echo ... node ( /rostopic_3663 in the figure) and the /turtlesim node now. Figure 2.11 ROS rqt_graph of turtle moving in a circle Next, in a new terminal, run echo on the pose topic and recheck rqt_graph : rosopic echo /turtle1/pose Figure 2.12 ROS rqt_graph of turtle moving in a circle with pose You can see that the /turtlesim node is also publishing to the pose topic, which the new echo node has subscribed to.","title":"Understanding ROS Topics"},{"location":"sea700/lab2/#understanding-ros-services","text":"Leave roscore , rosrun turtlesim turtlesim_node and rosrun turtlesim turtle_teleop_key open and close all the other terminal. Open a new terminal and run the rosservice list command to return a list of all the services currently active in the system: /clear /kill /reset /rosout/get_loggers /rosout/set_logger_level /spawn /teleop_turtle/get_loggers /teleop_turtle/set_logger_level /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/get_loggers /turtlesim/set_logger_level Let's look more closely at the turtlesim-specific services, /clear , /kill , /reset , /spawn , /turtle1/set_pen , /turtle1/teleport_absolute , and /turtle1/teleport_relative . You may recall interacting with some of these services using rqt. Services have types that describe how the request and response data of a service is structured. Service types are defined similarly to topic types, except service types have two parts: one message for the request and another for the response. To find out the type of a service, use the command: rosservice type [service] Let\u2019s take a look at turtlesim\u2019s /clear service. In a new terminal, enter the command: rosservice type /clear Which should return: std_srvs/Empty The std_srvs/Empty type means the service call sends no data when making a request and receives no data when receiving a response. If you want to find all the services of a specific type, you can use the command: rosservice find [type_name] . For example, you can find all the Empty typed services like this: rosservice find std_srvs/Empty Which will return: /clear /reset You can call services from the command line, but first you need to know the structure of the input arguments by using rossrv show [type_name] . Try this on the /clear service\u2019s type, std_srvs/Empty : rossrv show std_srvs/Empty Which will return: --- The --- separates the request structure (above) from the response structure (below). But, as you learned earlier, the std_srvs/Empty type doesn\u2019t send or receive any data. So, naturally, its structure is blank. Let\u2019s introspect a service with a type that sends and receives data, like /spawn . From the results of rosservice type /spawn , we know /spawn \u2019s type is turtlesim/Spawn . To see the request and response arguments of the /spawn service, we can pass the return value of the rosservice command to the rossrv command by running the command: rosservice type /spawn | rossrv show Which will return: float32 x float32 y float32 theta string name --- string name The information above the --- line tells us the arguments needed to call /spawn . x , y and theta determine the 2D pose of the spawned turtle, and name is optional. The information below the --- line isn\u2019t something you need to know in this case, but it can help you understand the data type of the response you get from the call. Now that you know what a service type is, how to find a service\u2019s type, and how to find the structure of that type\u2019s arguments, you can call a service using: rosservice call [service_name] [service_type] [arguments] . The [arguments] part is optional. For example, you know that Empty typed services don\u2019t have any arguments: rosservice call /clear This command will clear the turtlesim window of any lines your turtle has drawn. Figure 2.13 Turtlesim with line Figure 2.14 Turtlesim cleared Now let\u2019s spawn a new turtle by calling /spawn and setting arguments. Input [arguments] in a service call from the command-line need to be in YAML syntax. Enter the command: rosservice call /spawn 2 2 0.2 \"\" You will get this service response: name: turtle2 Your turtlesim window will update with the newly spawned turtle right away: Figure 2.15 Turtlesim Spawn","title":"Understanding ROS Services"},{"location":"sea700/lab2/#understanding-ros-parameters","text":"rosparam allows you to store and manipulate data on the ROS Parameter Server . The Parameter Server can store integers, floats, boolean, dictionaries, and lists. rosparam uses the YAML markup language for syntax. In simple cases, YAML looks very natural: 1 is an integer, 1.0 is a float, one is a string, true is a boolean, [1, 2, 3] is a list of integers, and {a: b, c: d} is a dictionary. rosparam has many commands that can be used on parameters, as shown below: Usage: rosparam set set parameter rosparam get get parameter rosparam load load parameters from file rosparam dump dump parameters to file rosparam delete delete parameter rosparam list list parameter names To see the parameters belonging to your nodes, enter the command: rosparam list You will see the node namespaces, /teleop_turtle and /turtlesim , followed by each node\u2019s parameters: /rosdistro /roslaunch/uris/host_ubuntu_18__37467 /rosversion /run_id /turtlesim/background_b /turtlesim/background_g /turtlesim/background_r Based on their names, it looks like /turtlesim \u2019s parameters determine the background color of the turtlesim window using RGB color values. To display the type and current value of a parameter, use the command: rosparam get [param_name] . Let\u2019s find out the current value of /turtlesim \u2019s parameter background_g : rosparam get /turtlesim/background_g Which will return the value: 86 Now you know background_g holds an integer value. If you run the same command on background_r and background_b , you will get the values 69 and 255 , respectively. To change a parameter\u2019s value at runtime, use the command: rosparam set [param_name] . Let\u2019s change /turtlesim \u2019s background color: rosparam set /turtlesim/background_r 150 This changes the parameter value, now we have to call the clear service for the parameter change to take effect: rosservice call /clear And the background of your turtlesim window should change colors: Figure 2.16 Turtlesim Purple","title":"Understanding ROS Parameters"},{"location":"sea700/lab2/#understanding-recording-and-playback","text":"rosbag is a command line tool for recording data published on topics in your system. It accumulates the data passed on any number of topics and saves it in a database. You can then replay the data to reproduce the results of your tests and experiments. Recording topics is also a great way to share your work and allow others to recreate it. rosbag can only record data from published messages in topics. Earlier in the lab, you learned that the /turtle_teleop node publishes commands on the /turtle1/cmd_vel topic to make the turtle move in turtlesim . Restart roscore , rosrun turtlesim turtlesim_node and ro run turtlesim turtle_teleop_key open and close all the other terminal. Let\u2019s also make a new directory to store our saved recordings, just as good practice. Open a new terminal and run: mkdir ~/bag_files cd ~/bag_files To record the data published to a topic use the command syntax: rosbag record [topic_name] . Run the command: rosbag record /turtle1/cmd_vel You will see the following messages in the terminal (the date and time will be different): [ INFO] [1727727815.120194012]: Subscribing to /turtle1/cmd_vel [ INFO] [1727727815.122105256]: Recording to '2024-09-30-16-23-35.bag'. Now rosbag is recording the data published on the /turtle1/cmd_vel topic. Return to the teleop terminal and move the turtle around again. The movements don\u2019t matter, but try to make a recognizable pattern to see when you replay the data later. Figure 2.17 Turtlesim Recording Press Ctrl+C to stop recording. The data will be accumulated in a new bag directory with a name in the pattern of year_month_day-hour-minute-second . You can also record multiple topics, as well as change the name of the file rosbag saves to. Run the following command: rosbag record -O subset /turtle1/cmd_vel /turtle1/pose The -O option allows you to choose a unique name for your bag file. The following string, in this case subset , is the file name. To record more than one topic at a time, simply list each topic separated by a space or you can use the -a to record all topics. You will see the following message, confirming that both topics are being recorded. [ INFO] [1727728178.421665012]: Subscribing to /turtle1/cmd_vel [ INFO] [1727728178.425904027]: Subscribing to /turtle1/pose [ INFO] [1727728178.430928233]: Recording to 'subset.bag'. You can move the turtle around and press Ctrl+C when you\u2019re finished. You can see details about your recording by running: rosbag info <bag_file_name> . Running this command on the subset bag file will return a list of information on the file: rosbag info subset.bag You should see something like: path: subset.bag version: 2.0 duration: 35.5s start: Sep 30 2024 16:29:38.64 (1727728178.64) end: Sep 30 2024 16:30:14.15 (1727728214.15) size: 184.7 KB messages: 2307 compression: none [1/1 chunks] types: geometry_msgs/Twist [9f195f881246fdfa2798d1d3eebca84a] turtlesim/Pose [863b248d5016ca62ea2e895ae5265cf9] topics: /turtle1/cmd_vel 92 msgs : geometry_msgs/Twist /turtle1/pose 2215 msgs : turtlesim/Pose Before replaying the bag file, enter Ctrl+C in the terminal where the teleop is running. Then make sure your turtlesim window is visible so you can see the bag file in action. Enter the command: rosbag play subset The terminal will return the message: [ INFO] [1727728462.171253911]: Opening subset.bag Waiting 0.2 seconds after advertising topics... done. Hit space to toggle paused, or 's' to step. [DELAYED] Bag Time: ... After some time, your turtle will follow the same path you entered while recording (though not 100% exactly; turtlesim is sensitive to small changes in the system\u2019s timing). Figure 2.18 Turtlesim Recording Because the subset file recorded the /turtle1/pose topic , the rosbag play command will be recording for as long as you had turtlesim running, even if you weren\u2019t moving. This is because as long as the /turtlesim node is active, it publishes data on the /turtle1/pose topic at regular intervals. You may have noticed in the rosbag info example result above that the /turtle1/cmd_vel topic\u2019s Count information was only 92; that\u2019s how many times we pressed the arrow keys while recording. Notice that /turtle1/pose has a Count value of over 2000; while we were recording, data was published on that topic over 2000 times.","title":"Understanding Recording and Playback"},{"location":"sea700/lab2/#lab-question","text":"Change the background of turtlesim to orange or cyan then create a recording of a turtle performing a \"Figure 8\" path (clockwise circle followed by counter-clockwise circle). Play it back. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab Question"},{"location":"sea700/lab2/#reference","text":"ROS Tutorials EECS 106A Labs","title":"Reference"},{"location":"sea700/lab3/","text":"Lab 3 : ROS Workspace, Package, Publisher and Subscriber Seneca Polytechnic SEA700 Robotics for Software Engineers Introduction ROS Workspace A workspace is a directory containing ROS packages. Before using ROS, it\u2019s necessary to source your ROS installation workspace in the terminal you plan to work in. This makes ROS\u2019s packages available for you to use in that terminal. ROS Package A package is an organizational unit for your ROS code. If you want to be able to install your code or share it with others, then you\u2019ll need it organized in a package. With packages, you can release your ROS work and allow others to build and use it easily. For a package to be considered a catkin package it must meet a few requirements: The package must contain a catkin compliant package.xml file. That package.xml file provides meta information about the package. The package must contain a CMakeLists.txt which uses catkin. If it is a catkin metapackage it must have the relevant boilerplate CMakeLists.txt file. Each package must have its own directory This means no nested packages nor multiple packages sharing the same directory. The simplest possible package may have a file structure that looks like: my_package/ CMakeLists.txt package.xml A single workspace can contain as many packages as you want, each in their own directory. You can also have packages of different build types in one workspace (CMake, Python, etc.). You cannot have nested packages. Best practice is to have a src directory within your workspace, and to create your packages in there. This keeps the top level of the workspace \u201cclean\u201d. A trivial workspace might look like: workspace_directory/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n Procedures Create a Workspace directory Best practice is to create a new directory for every new workspace. The name doesn\u2019t matter, but it is helpful to have it indicate the purpose of the workspace. Let\u2019s choose the directory name ros_ws , for \u201cdevelopment workspace\u201d. Open a new terminal and run: mkdir -p ~/ros_ws/src cd ~/ros_ws/ catkin_make The catkin_make command is a convenience tool for working with catkin workspaces. Running it the first time in your workspace, it will create a CMakeLists.txt link in your src directory. Another best practice is to put any packages in your workspace into the src directory. The above code creates a src directory inside ros_ws . If you are building ROS from source to achieve Python 3 compatibility, and have setup your system appropriately (ie: have the Python 3 versions of all the required ROS Python packages installed, such as catkin) the first catkin_make command in a clean catkin workspace must be: catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 This will configure catkin_make with Python 3. You may then proceed to use just catkin_make for subsequent builds. Additionally, if you look in your current directory you should now have a 'build' and 'devel' directory. Inside the 'devel' directory you can see that there are now several setup files. Sourcing any of these files will overlay this workspace on top of your environment. Before continuing source your new setup.sh file: source devel/setup.bash To make sure your workspace is properly overlayed by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the directory you're in. echo $ROS_PACKAGE_PATH You should see: /home/<youruser>/ros_ws/src:/opt/ros/melodic/share And other path(s) if you have them added to your source. Create a C++ Package Navigate into ros_ws/src , and run the package creation command to create a simple C++ publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg cpp_pubsub std_msgs roscpp Your terminal will return a message verifying the creation of your package cpp_pubsub and all its necessary files and directories. catkin_create_pkg requires that you give it a package_name and optionally a list of dependencies on which that package depends: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] More details on package creation can be found here . Write the publisher node Navigate into ros_ws/src/cpp_pubsub/src . This is the directory in any CMake package where the source files containing executables belong. Download the example talker code by entering the following command: wget -O talker.cpp https://raw.githubusercontent.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp Now there will be a new file named talker.cpp . Open the file using your preferred text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include <sstream> /** * This tutorial demonstrates simple sending of messages over the ROS system. */ int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"talker\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The advertise() function is how you tell ROS that you want to * publish on a given topic name. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. After this advertise() call is made, the master * node will notify anyone who is trying to subscribe to this topic name, * and they will in turn negotiate a peer-to-peer connection with this * node. advertise() returns a Publisher object which allows you to * publish messages on that topic through a call to publish(). Once * all copies of the returned Publisher object are destroyed, the topic * will be automatically unadvertised. * * The second parameter to advertise() is the size of the message queue * used for publishing messages. If messages are published more quickly * than we can send them, the number here specifies how many messages to * buffer up before throwing some away. */ ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); ros::Rate loop_rate(10); /** * A count of how many messages we have sent. This is used to create * a unique string for each message. */ int count = 0; while (ros::ok()) { /** * This is a message object. You stuff it with data, and then publish it. */ std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); ROS_INFO(\"%s\", msg.data.c_str()); /** * The publish() function is how you send messages. The parameter * is the message object. The type of this object must agree with the type * given as a template parameter to the advertise<>() call, as was done * in the constructor above. */ chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } return 0; } The Code Explained Now, let's break the code down. #include \"ros/ros.h\" ros/ros.h is a convenience include that includes all the headers necessary to use the most common public pieces of the ROS system. #include \"std_msgs/String.h\" This includes the std_msgs/String message, which resides in the std_msgs package. This is a header generated automatically from the String.msg file in that package. For more information on message definitions, see the msg page. ros::init(argc, argv, \"talker\"); Initialize ROS. This allows ROS to do name remapping through the command line -- not important for now. This is also where we specify the name of our node. Node names must be unique in a running system. The name used here must be a base name, ie. it cannot have a / in it. ros::NodeHandle n; Create a handle to this process' node. The first NodeHandle created will actually do the initialization of the node, and the last one destructed will cleanup any resources the node was using. ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); Tell the master that we are going to be publishing a message of type std_msgs/String on the topic chatter . This lets the master tell any nodes listening on chatter that we are going to publish data on that topic. The second argument is the size of our publishing queue. In this case if we are publishing too quickly it will buffer up a maximum of 1000 messages before beginning to throw away old ones. NodeHandle::advertise() returns a ros::Publisher object, which serves two purposes: 1) it contains a publish() method that lets you publish messages onto the topic it was created with, and 2) when it goes out of scope, it will automatically unadvertise. ros::Rate loop_rate(10); A ros::Rate object allows you to specify a frequency that you would like to loop at. It will keep track of how long it has been since the last call to Rate::sleep() , and sleep for the correct amount of time. In this case we tell it we want to run at 10Hz. int count = 0; while (ros::ok()) { By default roscpp will install a SIGINT handler which provides Ctrl-C handling which will cause ros::ok() to return false if that happens. ros::ok() will return false if: a SIGINT is received (Ctrl-C) we have been kicked off the network by another node with the same name ros::shutdown() has been called by another part of the application. all ros::NodeHandles have been destroyed Once ros::ok() returns false, all ROS calls will fail. std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); We broadcast a message on ROS using a message-adapted class, generally generated from a msg file. More complicated datatypes are possible, but for now we're going to use the standard String message, which has one member: \"data\". chatter_pub.publish(msg); Now we actually broadcast the message to anyone who is connected. ROS_INFO(\"%s\", msg.data.c_str()); ROS_INFO and friends are our replacement for printf/cout . See the rosconsole documentation for more information. ros::spinOnce(); Calling ros::spinOnce() here is not necessary for this simple program, because we are not receiving any callbacks. However, if you were to add a subscription into this application, and did not have ros::spinOnce() here, your callbacks would never get called. So, add it for good measure. loop_rate.sleep(); Now we use the ros::Rate object to sleep for the time remaining to let us hit our 10Hz publish rate. Here's the condensed version of what's going on: Initialize the ROS system Advertise that we are going to be publishing std_msgs/String messages on the chatter topic to the master Loop while publishing messages to chatter 10 times a second Write the subscriber node Now we need to write a node to receive the messsages. Return to ros_ws/src/cpp_pubsub/src to create the next node. Enter the following code in your terminal to download the subscriber: wget -O listener.cpp https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp Check to ensure that these files exist: talker.cpp listener.cpp Open the listener.cpp with your text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" /** * This tutorial demonstrates simple receipt of messages over the ROS system. */ void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"listener\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The subscribe() call is how you tell ROS that you want to receive messages * on a given topic. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. Messages are passed to a callback function, here * called chatterCallback. subscribe() returns a Subscriber object that you * must hold on to until you want to unsubscribe. When all copies of the Subscriber * object go out of scope, this callback will automatically be unsubscribed from * this topic. * * The second parameter to the subscribe() function is the size of the message * queue. If messages are arriving faster than they are being processed, this * is the number of messages that will be buffered up before beginning to throw * away the oldest ones. */ ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); /** * ros::spin() will enter a loop, pumping callbacks. With this version, all * callbacks will be called from within this thread (the main one). ros::spin() * will exit when Ctrl-C is pressed, or the node is shutdown by the master. */ ros::spin(); return 0; } The Code Explained Now, let's break it down piece by piece, ignoring some pieces that have already been explained above. void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } This is the callback function that will get called when a new message has arrived on the chatter topic. The message is passed in a boost shared_ptr , which means you can store it off if you want, without worrying about it getting deleted underneath you, and without copying the underlying data. ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); Subscribe to the chatter topic with the master. ROS will call the chatterCallback() function whenever a new message arrives. The 2nd argument is the queue size, in case we are not able to process messages fast enough. In this case, if the queue reaches 1000 messages, we will start throwing away old messages as new ones arrive. NodeHandle::subscribe() returns a ros::Subscriber object, that you must hold on to until you want to unsubscribe. When the Subscriber object is destructed, it will automatically unsubscribe from the chatter topic. There are versions of the NodeHandle::subscribe() function which allow you to specify a class member function, or even anything callable by a Boost.Function object. The roscpp overview contains more information. ros::spin(); ros::spin() enters a loop, calling message callbacks as fast as possible. Don't worry though, if there's nothing for it to do it won't use much CPU. ros::spin() will exit once ros::ok() returns false, which means ros::shutdown() has been called, either by the default Ctrl-C handler, the master telling us to shutdown, or it being called manually. Again, here's a condensed version of what's going on: Initialize the ROS system Subscribe to the chatter topic Spin, waiting for messages to arrive When a message arrives, the chatterCallback() function is called Build and Run C++ Package Now, go back to the package and open up CMakeLists.txt and ensure the following are in there. Note: Some of the functions are currently commented out and some are missing. ## Generate added messages and services generate_messages(DEPENDENCIES std_msgs) ## Declare a catkin package catkin_package() ## Build talker and listener include_directories(include ${catkin_INCLUDE_DIRS}) add_dependencies(talker cpp_pubsub_generate_messages_cpp) add_executable(talker src/talker.cpp) target_link_libraries(talker ${catkin_LIBRARIES}) add_dependencies(listener cpp_pubsub_generate_messages_cpp) add_executable(listener src/listener.cpp) target_link_libraries(listener ${catkin_LIBRARIES}) This will create two executables, talker and listener , which by default will go into the package directory of your devel space, located by default at ~/ros_ws/devel/lib/<package name> . Note that you have to add dependencies for the executable targets to message the generation targets: add_dependencies(talker cpp_pubsub_generate_messages_cpp) This makes sure message headers of this package are generated before being used. If you use messages from other packages inside your catkin workspace, you need to add dependencies to their respective generation targets as well, because catkin builds all projects in parallel. The following variable to allow you to depend on all necessary targets: target_link_libraries(talker ${catkin_LIBRARIES}) You can invoke executables directly or you can use rosrun to invoke them. They are not placed in <prefix>/bin because that would pollute the PATH when installing your package to the system. If you wish for your executable to be on the PATH at installation time, you can setup an install target, see: catkin/CMakeLists.txt Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Now run catkin_make in your catkin workspace: cd ~/ros_ws catkin_make Note: Or if you're adding as new pkg, you may need to tell catkin to force making by --force-cmake option. Now you have written a simple publisher and subscriber. Run ROS master. roscore In a new terminal, source the setup files: source ./devel/setup.bash Now run the talker node from ros_ws : rosrun cpp_pubsub talker The terminal should start publishing info messages every 0.5 seconds, like so: [ INFO] [1727906572.247429209]: hello world 0 [ INFO] [1727906572.347872260]: hello world 1 [ INFO] [1727906572.448580826]: hello world 2 [ INFO] [1727906572.548227290]: hello world 3 [ INFO] [1727906572.650658485]: hello world 4 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: . devel/setup.bash rosrun cpp_pubsub listener The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [ INFO] [1727906765.424901599]: I heard: [hello world 10] [ INFO] [1727906765.525323426]: I heard: [hello world 11] [ INFO] [1727906765.625240241]: I heard: [hello world 12] [ INFO] [1727906765.728040103]: I heard: [hello world 13] [ INFO] [1727906765.824066051]: I heard: [hello world 14] Enter Ctrl+C in each terminal to stop the nodes from spinning. Create a Python Package Navigate into ros_ws/src , and run the package creation command to create a simple Python publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg py_pubsub std_msgs rospy Your terminal will return a message verifying the creation of your package py_pubsub and all its necessary files and directories. Write the publisher node Navigate to your package ros_ws/src/py_pubsub and let's first create a scripts directories to store our Python scripts in and navigate into it: cd py_pubsub Create a directory. mkdir scripts cd scripts Download the example talker code and make it executable by entering the following command: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/talker.py chmod +x talker.py Now there will be a new file named talker.py . Open the file using your preferred text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python # license removed for brevity import rospy from std_msgs.msg import String def talker(): pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) rate = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() if __name__ == '__main__': try: talker() except rospy.ROSInterruptException: pass Add the following to your CMakeLists.txt . This makes sure the python script gets installed properly, and uses the right python interpreter. catkin_install_python(PROGRAMS scripts/talker.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) The Code Explained Now, let's break the code down. #!/usr/bin/env python Every Python ROS Node will have this declaration at the top. The first line makes sure your script is executed as a Python script. import rospy from std_msgs.msg import String You need to import rospy if you are writing a ROS Node. The std_msgs.msg import is so that we can reuse the std_msgs/String message type (a simple string container) for publishing. pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) This section of code defines the talker's interface to the rest of ROS. pub = rospy.Publisher(\"chatter\", String, queue_size=10) declares that your node is publishing to the chatter topic using the message type String . String here is actually the class std_msgs.msg.String . The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. The next line, rospy.init_node(NAME, ...) , is very important as it tells rospy the name of your node -- until rospy has this information, it cannot start communicating with the ROS Master. In this case, your node will take on the name talker . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". anonymous = True ensures that your node has a unique name by adding random numbers to the end of NAME. Refer to Initialization and Shutdown - Initializing your ROS Node in the rospy documentation for more information about node initialization options. rate = rospy.Rate(10) # 10hz This line creates a Rate object rate . With the help of its method sleep() , it offers a convenient way for looping at the desired rate . With its argument of 10 , we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10th of a second!) while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() This loop is a fairly standard rospy construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(hello_str) that publishes a string to our chatter topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. (You may also run across rospy.sleep() which is similar to time.sleep() except that it works with simulated time as well (see Clock ).) This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. std_msgs.msg.String is a very simple message type, so you may be wondering what it looks like to publish more complicated types. The general rule of thumb is that constructor args are in the same order as in the .msg file . You can also pass in no arguments and initialize the fields directly, e.g. msg = String() msg.data = str or you can initialize some of the fields and leave the rest with default values: String(data=str) You may be wondering about the last little bit: try: talker() except rospy.ROSInterruptException: pass In addition to the standard Python __main__ check, this catches a rospy.ROSInterruptException exception, which can be thrown by rospy.sleep() and rospy.Rate.sleep() methods when Ctrl-C is pressed or your Node is otherwise shutdown. The reason this exception is raised is so that you don't accidentally continue executing code after the sleep() . Write the subscriber node Now we need to write a node to receive the messages. Return to ros_ws/src/py_pubsub/scripts to create the next node. Enter the following code in your terminal: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/listener.py chmod +x listener.py Now the directory should have these files: listener.py talker.py Open the listener.py with your text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python import rospy from std_msgs.msg import String def callback(data): rospy.loginfo(rospy.get_caller_id() + \"I heard %s\", data.data) def listener(): # In ROS, nodes are uniquely named. If two nodes with the same # name are launched, the previous one is kicked off. The # anonymous=True flag means that rospy will choose a unique # name for our 'listener' node so that multiple listeners can # run simultaneously. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() if __name__ == '__main__': listener() Then, edit the catkin_install_python() call in your CMakeLists.txt so it looks like the following: catkin_install_python(PROGRAMS scripts/talker.py scripts/listener.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) The Code Explained The code for listener.py is similar to talker.py , except we've introduced a new callback-based mechanism for subscribing to messages. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() This declares that your node subscribes to the chatter topic which is of type std_msgs.msgs.String . When new messages are received, callback is invoked with the message as the first argument. We also changed up the call to rospy.init_node() somewhat. We've added the anonymous=True keyword argument. ROS requires that each node have a unique name. If a node with the same name comes up, it bumps the previous one. This is so that malfunctioning nodes can easily be kicked off the network. The anonymous=True flag tells rospy to generate a unique name for the node so that you can have multiple listener.py nodes run easily. The final addition, rospy.spin() simply keeps your node from exiting until the node has been shutdown. Unlike roscpp , rospy.spin() does not affect the subscriber callback functions, as those have their own threads. Build and run Python Package We use CMake as our build system and, yes, you have to use it even for Python nodes. This is to make sure that the autogenerated Python code for messages and services is created. Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Go to your catkin workspace and run catkin_make : cd ~/ros_ws catkin_make Run ROS master. roscore Open a new terminal, navigate to ros_ws , and source the setup files: source ./devel/setup.bash Now run the talker node: rosrun py_pubsub talker.py The terminal should start publishing info messages every 0.5 seconds, like so: [INFO] [1727910097.196673]: hello world 1727910097.2 [INFO] [1727910097.293260]: hello world 1727910097.29 [INFO] [1727910097.394363]: hello world 1727910097.39 [INFO] [1727910097.493223]: hello world 1727910097.49 [INFO] [1727910097.592866]: hello world 1727910097.59 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: rosrun py_pubsub listener.py The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [INFO] [1727910166.665430]: /listener_5173_1727910161732I heard hello world 1727910166.66 [INFO] [1727910166.761804]: /listener_5173_1727910161732I heard hello world 1727910166.76 [INFO] [1727910166.870095]: /listener_5173_1727910161732I heard hello world 1727910166.87 [INFO] [1727910166.963474]: /listener_5173_1727910161732I heard hello world 1727910166.96 [INFO] [1727910167.071514]: /listener_5173_1727910161732I heard hello world 1727910167.07 Stop the listener and try to run the C++ listener from earlier: rosrun cpp_pubsub listener You should see a similar same output. Enter Ctrl+C in each terminal to stop the nodes from spinning. Lab Question Write a new controller (C++ or Python) for turtlesim that replace turtle_teleop_key . Since the turtlesim node is the subscriber in this example, you\u2019ll only need to write a single publisher node. Create a new package called lab3_turtlesim . You can create a new workspace called lab3_ws or use your existing workspace. catkin_create_pkg lab3_turtlesim roscpp geometry_msgs or catkin_create_pkg lab3_turtlesim rospy geometry_msgs Your node should do the following: Accept a command line argument specifying the name of the turtle it should control. Running rosrun lab3_turtlesim turtle_controller turtle1 will start a controller node that controls turtle1. Use w , a , s , d to control the turtle by publish velocity control messages on the appropriate topic whenever the user presses those keys on the keyboard, as in the original turtle_teleop_key . Capturing individual keystrokes from the terminal is slightly complicated, so feel free to use keyboard input such as scanf() or input() instead. Hint: You'll need to use the Twist message type in the geometry_msgs package. To test, spawn multiple turtles and open multiple instances of your new turtle controller node, each linked to a different turtle. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab. Reference ROS Tutorials EECS 106A Labs","title":"Lab 3 : ROS Workspace, Package, Publisher and Subscriber"},{"location":"sea700/lab3/#lab-3-ros-workspace-package-publisher-and-subscriber","text":"Seneca Polytechnic SEA700 Robotics for Software Engineers","title":"Lab 3 : ROS Workspace, Package, Publisher and Subscriber"},{"location":"sea700/lab3/#introduction","text":"","title":"Introduction"},{"location":"sea700/lab3/#ros-workspace","text":"A workspace is a directory containing ROS packages. Before using ROS, it\u2019s necessary to source your ROS installation workspace in the terminal you plan to work in. This makes ROS\u2019s packages available for you to use in that terminal.","title":"ROS Workspace"},{"location":"sea700/lab3/#ros-package","text":"A package is an organizational unit for your ROS code. If you want to be able to install your code or share it with others, then you\u2019ll need it organized in a package. With packages, you can release your ROS work and allow others to build and use it easily. For a package to be considered a catkin package it must meet a few requirements: The package must contain a catkin compliant package.xml file. That package.xml file provides meta information about the package. The package must contain a CMakeLists.txt which uses catkin. If it is a catkin metapackage it must have the relevant boilerplate CMakeLists.txt file. Each package must have its own directory This means no nested packages nor multiple packages sharing the same directory. The simplest possible package may have a file structure that looks like: my_package/ CMakeLists.txt package.xml A single workspace can contain as many packages as you want, each in their own directory. You can also have packages of different build types in one workspace (CMake, Python, etc.). You cannot have nested packages. Best practice is to have a src directory within your workspace, and to create your packages in there. This keeps the top level of the workspace \u201cclean\u201d. A trivial workspace might look like: workspace_directory/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- 'Toplevel' CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n","title":"ROS Package"},{"location":"sea700/lab3/#procedures","text":"","title":"Procedures"},{"location":"sea700/lab3/#create-a-workspace-directory","text":"Best practice is to create a new directory for every new workspace. The name doesn\u2019t matter, but it is helpful to have it indicate the purpose of the workspace. Let\u2019s choose the directory name ros_ws , for \u201cdevelopment workspace\u201d. Open a new terminal and run: mkdir -p ~/ros_ws/src cd ~/ros_ws/ catkin_make The catkin_make command is a convenience tool for working with catkin workspaces. Running it the first time in your workspace, it will create a CMakeLists.txt link in your src directory. Another best practice is to put any packages in your workspace into the src directory. The above code creates a src directory inside ros_ws . If you are building ROS from source to achieve Python 3 compatibility, and have setup your system appropriately (ie: have the Python 3 versions of all the required ROS Python packages installed, such as catkin) the first catkin_make command in a clean catkin workspace must be: catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 This will configure catkin_make with Python 3. You may then proceed to use just catkin_make for subsequent builds. Additionally, if you look in your current directory you should now have a 'build' and 'devel' directory. Inside the 'devel' directory you can see that there are now several setup files. Sourcing any of these files will overlay this workspace on top of your environment. Before continuing source your new setup.sh file: source devel/setup.bash To make sure your workspace is properly overlayed by the setup script, make sure ROS_PACKAGE_PATH environment variable includes the directory you're in. echo $ROS_PACKAGE_PATH You should see: /home/<youruser>/ros_ws/src:/opt/ros/melodic/share And other path(s) if you have them added to your source.","title":"Create a Workspace directory"},{"location":"sea700/lab3/#create-a-c-package","text":"Navigate into ros_ws/src , and run the package creation command to create a simple C++ publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg cpp_pubsub std_msgs roscpp Your terminal will return a message verifying the creation of your package cpp_pubsub and all its necessary files and directories. catkin_create_pkg requires that you give it a package_name and optionally a list of dependencies on which that package depends: catkin_create_pkg <package_name> [depend1] [depend2] [depend3] More details on package creation can be found here .","title":"Create a C++ Package"},{"location":"sea700/lab3/#write-the-publisher-node","text":"Navigate into ros_ws/src/cpp_pubsub/src . This is the directory in any CMake package where the source files containing executables belong. Download the example talker code by entering the following command: wget -O talker.cpp https://raw.githubusercontent.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp Now there will be a new file named talker.cpp . Open the file using your preferred text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" #include <sstream> /** * This tutorial demonstrates simple sending of messages over the ROS system. */ int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"talker\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The advertise() function is how you tell ROS that you want to * publish on a given topic name. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. After this advertise() call is made, the master * node will notify anyone who is trying to subscribe to this topic name, * and they will in turn negotiate a peer-to-peer connection with this * node. advertise() returns a Publisher object which allows you to * publish messages on that topic through a call to publish(). Once * all copies of the returned Publisher object are destroyed, the topic * will be automatically unadvertised. * * The second parameter to advertise() is the size of the message queue * used for publishing messages. If messages are published more quickly * than we can send them, the number here specifies how many messages to * buffer up before throwing some away. */ ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); ros::Rate loop_rate(10); /** * A count of how many messages we have sent. This is used to create * a unique string for each message. */ int count = 0; while (ros::ok()) { /** * This is a message object. You stuff it with data, and then publish it. */ std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); ROS_INFO(\"%s\", msg.data.c_str()); /** * The publish() function is how you send messages. The parameter * is the message object. The type of this object must agree with the type * given as a template parameter to the advertise<>() call, as was done * in the constructor above. */ chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } return 0; }","title":"Write the publisher node"},{"location":"sea700/lab3/#the-code-explained","text":"Now, let's break the code down. #include \"ros/ros.h\" ros/ros.h is a convenience include that includes all the headers necessary to use the most common public pieces of the ROS system. #include \"std_msgs/String.h\" This includes the std_msgs/String message, which resides in the std_msgs package. This is a header generated automatically from the String.msg file in that package. For more information on message definitions, see the msg page. ros::init(argc, argv, \"talker\"); Initialize ROS. This allows ROS to do name remapping through the command line -- not important for now. This is also where we specify the name of our node. Node names must be unique in a running system. The name used here must be a base name, ie. it cannot have a / in it. ros::NodeHandle n; Create a handle to this process' node. The first NodeHandle created will actually do the initialization of the node, and the last one destructed will cleanup any resources the node was using. ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000); Tell the master that we are going to be publishing a message of type std_msgs/String on the topic chatter . This lets the master tell any nodes listening on chatter that we are going to publish data on that topic. The second argument is the size of our publishing queue. In this case if we are publishing too quickly it will buffer up a maximum of 1000 messages before beginning to throw away old ones. NodeHandle::advertise() returns a ros::Publisher object, which serves two purposes: 1) it contains a publish() method that lets you publish messages onto the topic it was created with, and 2) when it goes out of scope, it will automatically unadvertise. ros::Rate loop_rate(10); A ros::Rate object allows you to specify a frequency that you would like to loop at. It will keep track of how long it has been since the last call to Rate::sleep() , and sleep for the correct amount of time. In this case we tell it we want to run at 10Hz. int count = 0; while (ros::ok()) { By default roscpp will install a SIGINT handler which provides Ctrl-C handling which will cause ros::ok() to return false if that happens. ros::ok() will return false if: a SIGINT is received (Ctrl-C) we have been kicked off the network by another node with the same name ros::shutdown() has been called by another part of the application. all ros::NodeHandles have been destroyed Once ros::ok() returns false, all ROS calls will fail. std_msgs::String msg; std::stringstream ss; ss << \"hello world \" << count; msg.data = ss.str(); We broadcast a message on ROS using a message-adapted class, generally generated from a msg file. More complicated datatypes are possible, but for now we're going to use the standard String message, which has one member: \"data\". chatter_pub.publish(msg); Now we actually broadcast the message to anyone who is connected. ROS_INFO(\"%s\", msg.data.c_str()); ROS_INFO and friends are our replacement for printf/cout . See the rosconsole documentation for more information. ros::spinOnce(); Calling ros::spinOnce() here is not necessary for this simple program, because we are not receiving any callbacks. However, if you were to add a subscription into this application, and did not have ros::spinOnce() here, your callbacks would never get called. So, add it for good measure. loop_rate.sleep(); Now we use the ros::Rate object to sleep for the time remaining to let us hit our 10Hz publish rate. Here's the condensed version of what's going on: Initialize the ROS system Advertise that we are going to be publishing std_msgs/String messages on the chatter topic to the master Loop while publishing messages to chatter 10 times a second","title":"The Code Explained"},{"location":"sea700/lab3/#write-the-subscriber-node","text":"Now we need to write a node to receive the messsages. Return to ros_ws/src/cpp_pubsub/src to create the next node. Enter the following code in your terminal to download the subscriber: wget -O listener.cpp https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp Check to ensure that these files exist: talker.cpp listener.cpp Open the listener.cpp with your text editor. Alternatively, create a .cpp file with the following: #include \"ros/ros.h\" #include \"std_msgs/String.h\" /** * This tutorial demonstrates simple receipt of messages over the ROS system. */ void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } int main(int argc, char **argv) { /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, \"listener\"); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The subscribe() call is how you tell ROS that you want to receive messages * on a given topic. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. Messages are passed to a callback function, here * called chatterCallback. subscribe() returns a Subscriber object that you * must hold on to until you want to unsubscribe. When all copies of the Subscriber * object go out of scope, this callback will automatically be unsubscribed from * this topic. * * The second parameter to the subscribe() function is the size of the message * queue. If messages are arriving faster than they are being processed, this * is the number of messages that will be buffered up before beginning to throw * away the oldest ones. */ ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); /** * ros::spin() will enter a loop, pumping callbacks. With this version, all * callbacks will be called from within this thread (the main one). ros::spin() * will exit when Ctrl-C is pressed, or the node is shutdown by the master. */ ros::spin(); return 0; }","title":"Write the subscriber node"},{"location":"sea700/lab3/#the-code-explained_1","text":"Now, let's break it down piece by piece, ignoring some pieces that have already been explained above. void chatterCallback(const std_msgs::String::ConstPtr& msg) { ROS_INFO(\"I heard: [%s]\", msg->data.c_str()); } This is the callback function that will get called when a new message has arrived on the chatter topic. The message is passed in a boost shared_ptr , which means you can store it off if you want, without worrying about it getting deleted underneath you, and without copying the underlying data. ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback); Subscribe to the chatter topic with the master. ROS will call the chatterCallback() function whenever a new message arrives. The 2nd argument is the queue size, in case we are not able to process messages fast enough. In this case, if the queue reaches 1000 messages, we will start throwing away old messages as new ones arrive. NodeHandle::subscribe() returns a ros::Subscriber object, that you must hold on to until you want to unsubscribe. When the Subscriber object is destructed, it will automatically unsubscribe from the chatter topic. There are versions of the NodeHandle::subscribe() function which allow you to specify a class member function, or even anything callable by a Boost.Function object. The roscpp overview contains more information. ros::spin(); ros::spin() enters a loop, calling message callbacks as fast as possible. Don't worry though, if there's nothing for it to do it won't use much CPU. ros::spin() will exit once ros::ok() returns false, which means ros::shutdown() has been called, either by the default Ctrl-C handler, the master telling us to shutdown, or it being called manually. Again, here's a condensed version of what's going on: Initialize the ROS system Subscribe to the chatter topic Spin, waiting for messages to arrive When a message arrives, the chatterCallback() function is called","title":"The Code Explained"},{"location":"sea700/lab3/#build-and-run-c-package","text":"Now, go back to the package and open up CMakeLists.txt and ensure the following are in there. Note: Some of the functions are currently commented out and some are missing. ## Generate added messages and services generate_messages(DEPENDENCIES std_msgs) ## Declare a catkin package catkin_package() ## Build talker and listener include_directories(include ${catkin_INCLUDE_DIRS}) add_dependencies(talker cpp_pubsub_generate_messages_cpp) add_executable(talker src/talker.cpp) target_link_libraries(talker ${catkin_LIBRARIES}) add_dependencies(listener cpp_pubsub_generate_messages_cpp) add_executable(listener src/listener.cpp) target_link_libraries(listener ${catkin_LIBRARIES}) This will create two executables, talker and listener , which by default will go into the package directory of your devel space, located by default at ~/ros_ws/devel/lib/<package name> . Note that you have to add dependencies for the executable targets to message the generation targets: add_dependencies(talker cpp_pubsub_generate_messages_cpp) This makes sure message headers of this package are generated before being used. If you use messages from other packages inside your catkin workspace, you need to add dependencies to their respective generation targets as well, because catkin builds all projects in parallel. The following variable to allow you to depend on all necessary targets: target_link_libraries(talker ${catkin_LIBRARIES}) You can invoke executables directly or you can use rosrun to invoke them. They are not placed in <prefix>/bin because that would pollute the PATH when installing your package to the system. If you wish for your executable to be on the PATH at installation time, you can setup an install target, see: catkin/CMakeLists.txt Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Now run catkin_make in your catkin workspace: cd ~/ros_ws catkin_make Note: Or if you're adding as new pkg, you may need to tell catkin to force making by --force-cmake option. Now you have written a simple publisher and subscriber. Run ROS master. roscore In a new terminal, source the setup files: source ./devel/setup.bash Now run the talker node from ros_ws : rosrun cpp_pubsub talker The terminal should start publishing info messages every 0.5 seconds, like so: [ INFO] [1727906572.247429209]: hello world 0 [ INFO] [1727906572.347872260]: hello world 1 [ INFO] [1727906572.448580826]: hello world 2 [ INFO] [1727906572.548227290]: hello world 3 [ INFO] [1727906572.650658485]: hello world 4 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: . devel/setup.bash rosrun cpp_pubsub listener The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [ INFO] [1727906765.424901599]: I heard: [hello world 10] [ INFO] [1727906765.525323426]: I heard: [hello world 11] [ INFO] [1727906765.625240241]: I heard: [hello world 12] [ INFO] [1727906765.728040103]: I heard: [hello world 13] [ INFO] [1727906765.824066051]: I heard: [hello world 14] Enter Ctrl+C in each terminal to stop the nodes from spinning.","title":"Build and Run C++ Package"},{"location":"sea700/lab3/#create-a-python-package","text":"Navigate into ros_ws/src , and run the package creation command to create a simple Python publisher and subscriber: cd ~/ros_ws/src catkin_create_pkg py_pubsub std_msgs rospy Your terminal will return a message verifying the creation of your package py_pubsub and all its necessary files and directories.","title":"Create a Python Package"},{"location":"sea700/lab3/#write-the-publisher-node_1","text":"Navigate to your package ros_ws/src/py_pubsub and let's first create a scripts directories to store our Python scripts in and navigate into it: cd py_pubsub Create a directory. mkdir scripts cd scripts Download the example talker code and make it executable by entering the following command: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/talker.py chmod +x talker.py Now there will be a new file named talker.py . Open the file using your preferred text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python # license removed for brevity import rospy from std_msgs.msg import String def talker(): pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) rate = rospy.Rate(10) # 10hz while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() if __name__ == '__main__': try: talker() except rospy.ROSInterruptException: pass Add the following to your CMakeLists.txt . This makes sure the python script gets installed properly, and uses the right python interpreter. catkin_install_python(PROGRAMS scripts/talker.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} )","title":"Write the publisher node"},{"location":"sea700/lab3/#the-code-explained_2","text":"Now, let's break the code down. #!/usr/bin/env python Every Python ROS Node will have this declaration at the top. The first line makes sure your script is executed as a Python script. import rospy from std_msgs.msg import String You need to import rospy if you are writing a ROS Node. The std_msgs.msg import is so that we can reuse the std_msgs/String message type (a simple string container) for publishing. pub = rospy.Publisher('chatter', String, queue_size=10) rospy.init_node('talker', anonymous=True) This section of code defines the talker's interface to the rest of ROS. pub = rospy.Publisher(\"chatter\", String, queue_size=10) declares that your node is publishing to the chatter topic using the message type String . String here is actually the class std_msgs.msg.String . The queue_size argument limits the amount of queued messages if any subscriber is not receiving them fast enough. The next line, rospy.init_node(NAME, ...) , is very important as it tells rospy the name of your node -- until rospy has this information, it cannot start communicating with the ROS Master. In this case, your node will take on the name talker . NOTE: the name must be a base name, i.e. it cannot contain any slashes \"/\". anonymous = True ensures that your node has a unique name by adding random numbers to the end of NAME. Refer to Initialization and Shutdown - Initializing your ROS Node in the rospy documentation for more information about node initialization options. rate = rospy.Rate(10) # 10hz This line creates a Rate object rate . With the help of its method sleep() , it offers a convenient way for looping at the desired rate . With its argument of 10 , we should expect to go through the loop 10 times per second (as long as our processing time does not exceed 1/10th of a second!) while not rospy.is_shutdown(): hello_str = \"hello world %s\" % rospy.get_time() rospy.loginfo(hello_str) pub.publish(hello_str) rate.sleep() This loop is a fairly standard rospy construct: checking the rospy.is_shutdown() flag and then doing work. You have to check is_shutdown() to check if your program should exit (e.g. if there is a Ctrl-C or otherwise). In this case, the \"work\" is a call to pub.publish(hello_str) that publishes a string to our chatter topic. The loop calls rate.sleep() , which sleeps just long enough to maintain the desired rate through the loop. (You may also run across rospy.sleep() which is similar to time.sleep() except that it works with simulated time as well (see Clock ).) This loop also calls rospy.loginfo(str) , which performs triple-duty: the messages get printed to screen, it gets written to the Node's log file, and it gets written to rosout . rosout is a handy tool for debugging: you can pull up messages using rqt_console instead of having to find the console window with your Node's output. std_msgs.msg.String is a very simple message type, so you may be wondering what it looks like to publish more complicated types. The general rule of thumb is that constructor args are in the same order as in the .msg file . You can also pass in no arguments and initialize the fields directly, e.g. msg = String() msg.data = str or you can initialize some of the fields and leave the rest with default values: String(data=str) You may be wondering about the last little bit: try: talker() except rospy.ROSInterruptException: pass In addition to the standard Python __main__ check, this catches a rospy.ROSInterruptException exception, which can be thrown by rospy.sleep() and rospy.Rate.sleep() methods when Ctrl-C is pressed or your Node is otherwise shutdown. The reason this exception is raised is so that you don't accidentally continue executing code after the sleep() .","title":"The Code Explained"},{"location":"sea700/lab3/#write-the-subscriber-node_1","text":"Now we need to write a node to receive the messages. Return to ros_ws/src/py_pubsub/scripts to create the next node. Enter the following code in your terminal: wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/listener.py chmod +x listener.py Now the directory should have these files: listener.py talker.py Open the listener.py with your text editor. Alternatively, create a .py file with the following: #!/usr/bin/env python import rospy from std_msgs.msg import String def callback(data): rospy.loginfo(rospy.get_caller_id() + \"I heard %s\", data.data) def listener(): # In ROS, nodes are uniquely named. If two nodes with the same # name are launched, the previous one is kicked off. The # anonymous=True flag means that rospy will choose a unique # name for our 'listener' node so that multiple listeners can # run simultaneously. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() if __name__ == '__main__': listener() Then, edit the catkin_install_python() call in your CMakeLists.txt so it looks like the following: catkin_install_python(PROGRAMS scripts/talker.py scripts/listener.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} )","title":"Write the subscriber node"},{"location":"sea700/lab3/#the-code-explained_3","text":"The code for listener.py is similar to talker.py , except we've introduced a new callback-based mechanism for subscribing to messages. rospy.init_node('listener', anonymous=True) rospy.Subscriber(\"chatter\", String, callback) # spin() simply keeps python from exiting until this node is stopped rospy.spin() This declares that your node subscribes to the chatter topic which is of type std_msgs.msgs.String . When new messages are received, callback is invoked with the message as the first argument. We also changed up the call to rospy.init_node() somewhat. We've added the anonymous=True keyword argument. ROS requires that each node have a unique name. If a node with the same name comes up, it bumps the previous one. This is so that malfunctioning nodes can easily be kicked off the network. The anonymous=True flag tells rospy to generate a unique name for the node so that you can have multiple listener.py nodes run easily. The final addition, rospy.spin() simply keeps your node from exiting until the node has been shutdown. Unlike roscpp , rospy.spin() does not affect the subscriber callback functions, as those have their own threads.","title":"The Code Explained"},{"location":"sea700/lab3/#build-and-run-python-package","text":"We use CMake as our build system and, yes, you have to use it even for Python nodes. This is to make sure that the autogenerated Python code for messages and services is created. Before building the package, it's always a good idea to check and see if all dependencies are met. cd ~/ros_ws rosdep install -i --from-path src --rosdistro melodic -y You should get a success return: #All required rosdeps installed successfully Go to your catkin workspace and run catkin_make : cd ~/ros_ws catkin_make Run ROS master. roscore Open a new terminal, navigate to ros_ws , and source the setup files: source ./devel/setup.bash Now run the talker node: rosrun py_pubsub talker.py The terminal should start publishing info messages every 0.5 seconds, like so: [INFO] [1727910097.196673]: hello world 1727910097.2 [INFO] [1727910097.293260]: hello world 1727910097.29 [INFO] [1727910097.394363]: hello world 1727910097.39 [INFO] [1727910097.493223]: hello world 1727910097.49 [INFO] [1727910097.592866]: hello world 1727910097.59 Open another terminal, source the setup files from inside ros_ws again, and then start the listener node: rosrun py_pubsub listener.py The listener will start printing messages to the console, starting at whatever message count the publisher is on at that time, like so: [INFO] [1727910166.665430]: /listener_5173_1727910161732I heard hello world 1727910166.66 [INFO] [1727910166.761804]: /listener_5173_1727910161732I heard hello world 1727910166.76 [INFO] [1727910166.870095]: /listener_5173_1727910161732I heard hello world 1727910166.87 [INFO] [1727910166.963474]: /listener_5173_1727910161732I heard hello world 1727910166.96 [INFO] [1727910167.071514]: /listener_5173_1727910161732I heard hello world 1727910167.07 Stop the listener and try to run the C++ listener from earlier: rosrun cpp_pubsub listener You should see a similar same output. Enter Ctrl+C in each terminal to stop the nodes from spinning.","title":"Build and run Python Package"},{"location":"sea700/lab3/#lab-question","text":"Write a new controller (C++ or Python) for turtlesim that replace turtle_teleop_key . Since the turtlesim node is the subscriber in this example, you\u2019ll only need to write a single publisher node. Create a new package called lab3_turtlesim . You can create a new workspace called lab3_ws or use your existing workspace. catkin_create_pkg lab3_turtlesim roscpp geometry_msgs or catkin_create_pkg lab3_turtlesim rospy geometry_msgs Your node should do the following: Accept a command line argument specifying the name of the turtle it should control. Running rosrun lab3_turtlesim turtle_controller turtle1 will start a controller node that controls turtle1. Use w , a , s , d to control the turtle by publish velocity control messages on the appropriate topic whenever the user presses those keys on the keyboard, as in the original turtle_teleop_key . Capturing individual keystrokes from the terminal is slightly complicated, so feel free to use keyboard input such as scanf() or input() instead. Hint: You'll need to use the Twist message type in the geometry_msgs package. To test, spawn multiple turtles and open multiple instances of your new turtle controller node, each linked to a different turtle. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab Question"},{"location":"sea700/lab3/#reference","text":"ROS Tutorials EECS 106A Labs","title":"Reference"},{"location":"sea700/lab4/","text":"Lab 4 : Robot Model, Gazebo and JetAuto Seneca Polytechnic SEA700 Robotics for Software Engineers Introduction URDF URDF (Unified Robot Description Format) is an XML format for representing a robot model. URDF is commonly used in Robot Operating System (ROS) tools such as rviz (Ros Visualization tool) and Gazebo simulator. It is essentially a 3-D model with information around joints, motors, mass, etc. The files are then run through the Robot Operating System (ROS). The data from the file informs the human operator what the robot looks like and is capable of before they begin operating the robot. More details on the URDF specification can be found here . Many robotic manufacturers have URDF models of their devices available for download. These include the Segway RMP , Turtlebot , and AR10 . More Models: Agility Robotics Digit ANYbotics Anymal Boston Dynamics Spot (via Clearpath ROS Driver) Clearpath Jackal Clearpath Dingo Clearpath Husky Clearpath Turtlebot Unitree Go1 Universal Robotics URDF vs XACRO URDF (Unified Robot Description Format) and XACRO (XML Macros) are both used in ROS (Robot Operating System) for robot modeling, but they have distinct roles. URDF is a straightforward XML format that describes the physical structure of a robot, detailing its links and joints, as well as their properties like geometry and dynamics. It's ideal for simpler robot designs where the model's complexity is limited. In contrast, XACRO is an extension of URDF that incorporates macros, allowing for parameterization and reducing redundancy in model descriptions. This makes XACRO particularly useful for complex robots or those with interchangeable components, as it facilitates easier maintenance and enhances readability. Typically, XACRO files are processed into URDF files before they are utilized in simulations or applications, combining the flexibility of XACRO with the straightforwardness of URDF. RViz RViz, or Robot Visualization, is a powerful 3D visualization tool used primarily in robotics and the Robot Operating System (ROS). It enables developers to visualize and interpret a wide array of sensor data, such as point clouds, maps, and robot models, in real-time. With its interactive features, users can manipulate objects and adjust visual settings to enhance understanding of robot behavior and performance. RViz's plugin architecture allows for extensibility, accommodating various data types and visualization needs. This makes it an invaluable resource for debugging algorithms, simulating scenarios, and gaining insights into robotic systems, ultimately aiding in the development and refinement of robotics applications. Gazebo Gazebo is an open-source robotics simulation tool that provides a highly realistic environment for testing and developing robotic systems. It allows users to simulate robots in complex 3D environments, complete with detailed physics interactions, which include gravity, collisions, and friction. Gazebo supports a variety of sensors, such as cameras and LIDAR, enabling the generation of realistic sensor data for developing perception algorithms. Its seamless integration with the Robot Operating System (ROS) enhances its functionality, allowing developers to leverage ROS tools and libraries for robot control and communication. With a flexible plugin architecture, Gazebo can be customized to meet specific simulation needs, making it an essential platform for researchers and engineers in the field of robotics. Preparation JetAuto Robot In preperation of using the JetAuto robot, please be familiar with the user manual and the basic lesson provided by the manufacturer found here: JetAuto User Manual JetAuto & JetAuto Pro Resources Install Gazebo and other ROS packages After being familiar with ROS, we'll now install the Gazebo simulation environment. Following the instruction here to install Gazebo version 9.X to be used with ROS Melodic. Each Gazebo version works with a specific version of ROS. sudo apt install gazebo9 libgazebo9-dev Once installed, start Gazebo with the following command to ensure it's functional: gazebo Figure 4.1 Gazebo Running Lastly, ensure the following ros gazebo packages are installed: sudo apt install ros-melodic-gazebo-dev ros-melodic-gazebo-msgs ros-melodic-gazebo-plugins ros-melodic-gazebo-ros ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller ros-melodic-moveit ros-melodic-trac-ik-kinematics-plugin ros-melodic-slam-gmapping Procedures JetAuto Robot Inspection The robot we have for this course is the JetAuto Pro assembled in the configuration: Figure 4.2 JetAuto Pro Before using the JetAuto robot, read the following: JetAuto User Manual Page 01: Guide to Battery Safety Page 03: JetAuto Pro Standard Kit Packing List Page 04-09: Installation Instruction (except for 1.4 LCD) Check all nuts and bolts to ensure confirm installation and security Page 10-11: Charging and Starting the Robot We will NOT be using the smartphone app for controlling the robot. SSH Into the JetAuto Robot Copy this lab instruction somewhere on your computer as you'll lose connection to the internet! By default, the JetAuto is configured to be in Wifi AP mode. Power on the robot and connect to the robot's WiFi starting in \"HW-\". If you are unsure of which Wifi SSID is your robot broadcasting, open the \"Tool\" application on the robot and look for the AP name in the setting. Do NOT change any of the default settings. The password for the WiFi connection is: hiwonder . Once connected, use terminal (or PuTTY) to SSH into the robot at \"192.168.149.1\". ssh jetauto@192.168.149.1 The user is: jetauto , and the password is: hiwonder . USB connection with the robot It is also possible to connect with the robot via USB using the Jetson Nano's micro-B USB port. Use screen terminal application to connection with the robot. sudo apt-get install -y screen sudo screen /dev/ttyACM0 115200 NoMachine (Use with caution) Only recommended to be used on within a virtual machine. For security, stop the NoMachine server after you installation. NoMachine is another application that can be used to for remote connection with the JetNano board. Once you are connected with the robot, the credential is the same as above. JetAuto Robot Movement Ensure the battery charging cable is UNPLUGGED and all cables on the robot are secure. Ensure all structures, nuts and bolts on the robot are tightly fastened. Ensure the robot is on the ground and awy from any obstacles. In a terminal that's connected to the JetAuto robot using SSH or in JetAuto's terminal using remote desktop, stop the app service then start the jetauto_controller service: sudo systemctl stop start_app_node.service roslaunch jetauto_controller jetauto_controller.launch Now that the controller service has started, we can publish move command as Twist message to the motion controller. Before publish a command to the robot, remember you must issue a stop command for the robot to stop. Let's issue that first so you can recall it faster. rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should not do anything. Issue a move in the x-direction (forward) at 0.3 m/s, x: 0.3 : rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should now start moving. Be ready to stop the robot by issuing (or up arrow twice): rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' DO NOT set the movement value above 0.7 m/s to keep the robot within it control limit. The linear values refer to the translation of the robot. Positive X is forward and positive Y is left. There is no Z-direction for this robot. Do not exceed 0.7 m/s. The angular values refer to the rotation of the robot. Only Z-rotation is considered with positive value as counter-clockwise. Do not exceed 3.5 rad/s. Copying JetAuto Workspace to Local Machine for Simulation After figuring out how to control the JetAuto robot, let's copy the JetAuto workspace jetauto_ws over from the robot to our local machine so we can inspect and use it locally. Open a new terminla (you may close your SSH terminal) and run the following command locally to use rsync to copy the directory over: Run these commands on your local machine! Not in the SSH terminal. rsync -av jetauto@192.168.149.1:~/jetauto_ws/ ~/jetauto_ws Once jetauto_ws is on your virtual machine's home directory, let's add it as a source in ~/.bashrc . echo \"source /home/jetauto/jetauto_ws/devel/setup.bash\" >> ~/.bashrc Let's inspect the source code of the motion controller. Open the file at the following path: ~/jetauto_ws/src/jetauto_driver/jetauto_controller/scripts/jetauto_controller_main.py As we can see in the controller code: linear_x = self.go_factor*msg.linear.x linear_y = self.go_factor*msg.linear.y angular_z = self.turn_factor*msg.angular.z speed_up = False if abs(self.last_linear_x - linear_x) > 0.2 or abs(self.last_linear_y - linear_y) > 0.2 or abs(self.last_angular_z - angular_z) > 1: speed_up = True self.last_linear_x = linear_x self.last_linear_y = linear_y self.last_angular_z = angular_z linear_x_, linear_y_ = linear_x * 1000.0, linear_y * 1000.0#mm to m speed = math.sqrt(linear_x_ ** 2 + linear_y_ ** 2) direction = math.atan2(linear_y_, linear_x_) direction = math.pi * 2 + direction if direction < 0 else direction self.mecanum.set_velocity(speed, direction, angular_z, speed_up=speed_up) The Twist message from cmd_vel provides the necessary information to calculate speed , direction , and angular_z for controlling the mecanum wheel using the MecanumChassis object. Refer to JetAuto & JetAuto Pro Resources chapter 7.3 for the working principle of the mecanum wheel. Try other various combination of motion command to gain a better understanding of the robot's movement. Next, we'll try controlling the JetAuto robot using keyboard input. Keep the jetauto_controller terminal open. In a new/other terminal, run: roslaunch jetauto_peripherals teleop_key_control.launch robot_name:=\"/\" Use w, a, s, d to control the robot. Inspect the source code of the teleop controller to understand it's operation by opening the file at: ~/jetauto_ws/src/jetauto_peripherals/scripts/teleop_key_control.py JetAuto Robot Model Now that we can control the basic movement of the JetAuto robot, let's try to simulate it in Gazebo. Robot model in URDF consist of links that are joined together to form a robot assembly. Each link have its given geometry, mass, and collision parameter. The geometry can be provide as simple shape or complex shape using solid model. Before we start, let's ensure we have the required package installed (if you haven't installed it from the beginning of this lab) to view and test our robot model: sudo apt install ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller Before we can simulate the JetAuto in ROS and gazebo, we first need to set some environment variables that our launch script look for. Edit the system's environment variables: sudo gedit /etc/environment We'll add the following in the environment: LIDAR_TYPE=\"A1\" DEPTH_CAMERA_TYPE=\"AstraProPlus\" MACHINE_TYPE=\"JetAutoPro\" HOST=\"/\" MASTER=\"/\" Restart your system in order for the change to take effect. To have a quick view at the URDF model, we can us RViz: roslaunch jetauto_description display.launch model:=urdf/jetauto.urdf You can use the joint_state_publisher_gui to adjust the arm angle. Figure 4.3 JetAuto in Gazebo Let's open up the JetAuto URDF model file to take a look at it more closely. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto_car.urdf.xacro Here, we see a file in XML format: <robot name=\"jetauto\" xmlns:xacro=\"http://ros.org/wiki/xacro\" > <xacro:property name=\"M_PI\" value=\"3.1415926535897931\"/> <xacro:property name=\"base_link_mass\" value=\"1.6\" /> <xacro:property name=\"base_link_w\" value=\"0.297\"/> <xacro:property name=\"base_link_h\" value=\"0.145\"/> <xacro:property name=\"base_link_d\" value=\"0.11255\"/> <xacro:property name=\"wheel_link_mass\" value=\"0.1\" /> <xacro:property name=\"wheel_link_radius\" value=\"0.049\"/> <xacro:property name=\"wheel_link_length\" value=\"0.04167\"/> The first few lines define the robot's name and the basic parameters of the JetAuto's body. M_PI defines the value of \u03c0. base_link_mass defines the mass of the JetAuto\u2019s body model. base_link_w defines the width of the JetAuto\u2019s body model. base_link_h defines the height of of the JetAuto\u2019s body model. base_link_d defines the length of of the JetAuto\u2019s body model. wheel_link_mass defines the mass of each mecanum wheel. wheel_link_radius defines the radius of each mecanum wheel. The name of the robot is also defined as jetauto . <link name=\"base_footprint\"/> <joint name=\"base_joint\" type=\"fixed\"> <parent link=\"base_footprint\"/> <child link=\"base_link\"/> <origin xyz=\"0.0 0.0 0.0\" rpy=\"0 0 0\"/> </joint> base_footprint is defined as the top parent link (part) of the JetAuto model to create a overall envolope that sits as the origin. base_link is the base part of the robot that house the battery and motor. In the URDF mode, it is connected to base_footprint as a child linke. This envolope configuration ensure the wheel of the robot will always above the origin (ground). <link name=\"base_link\"> <xacro:box_inertial m=\"${base_link_mass}\" w=\"${base_link_w}\" h=\"${base_link_h}\" d=\"${base_link_d}\"/> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/base_link.stl\" /> </geometry> <material name=\"green\"/> </visual> <collision> <origin xyz=\"${base_link_w/2.0 - 0.14810} 0 ${0.126437/2 + 0.02362364}\" rpy=\"0 0 0\" /> <geometry> <box size=\"${base_link_w} ${base_link_h} ${base_link_d}\" /> </geometry> </collision> </link> Next is the link/part base_link along with it's elements. The mass and inertial information of the part is defined as an xacro element. The geometry sub-element in the visual element is provide by a stl mesh file from the jetauto_description package. The collision element is also defined as a box relative to the specified xyz cordinate. Figure 4.4 JetAuto base_link STL <link name=\"back_shell_link\"> <inertial> <origin xyz=\"-1.22838595456587E-05 0.00218574826309681 -0.0500522861933898\" rpy=\"0 0 0\" /> <mass value=\"0.0663478534899862\" /> <inertia ixx=\"5.65277934912267E-05\" ixy=\"-5.13394387877366E-11\" ixz=\"-4.07561372273553E-11\" iyy=\"4.33740893441632E-05\" iyz=\"-5.43059341238134E-06\" izz=\"6.86642544694324E-05\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> <material name=\"black\"> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> </collision> </link> <joint name=\"back_shell_joint\" type=\"fixed\"> <origin xyz=\"-0.076481 0 0.082796\" rpy=\"-3.1416 0 1.5708\" /> <parent link=\"base_link\" /> <child link=\"back_shell_link\" /> <axis xyz=\"0 0 0\" /> </joint> The back_shell_link is the part that house the Jetson Nano, the expansion board, and mount the antenna. All the elements are defined in a similar manner as back_link and it's defined as a child link of back_link within it's relative position defined in joint . The wheel_XXX_link are all defined in a similar manner. The JetAuto URDF model file above only defined the mechancial structure of the robot. If we take a look at the URDF file for simulating the robot in Gazebo, we'll find more links that are used and defined in other URDF files within the same package. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto.xacro If you are interested in building a URDF from scratch, visit the ROS tutorial here . Running JetAuto in Gazebo In a terminal, launch: roslaunch jetauto_gazebo worlds.launch Gazebo should run and you should see the JetAuto robot in the simulation enviornment. Figure 4.5 JetAuto in Gazebo With gazebo and ros running, we can now control the virtual robot the same way as the physical robot. Let's try publishing to the cmd_vel topic: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Stop the robot: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' We can also use the keyboard to control the robot: roslaunch jetauto_peripherals teleop_key_control.launch robot_name:=\"/\" Lab Question Write a code that will move the JetAuto robot in a roughly 1m square shape pattern as follow: (0, 0, 0\u00b0) to (1, 0, 0\u00b0) - face the direction of travel (1, 0, 0\u00b0) to (1, 1, 0\u00b0) - face the outside of the square (1, 1, -90\u00b0) to (0, 1, -90\u00b0) - rotate first to face the inside of the square (0, 1, -90\u00b0) to (0, 0, 0\u00b0) - rotate the robot while traveling Repeat this for 2 times after a start command (such as a keyboard input) is given. For example: when you run rosrun lab4_jetauto_control jetauto_control , it'll ask for an input before performing the above action. Hint: You can follow the same approach as Lab 3 by creating a new package called lab4_jetauto_control in your ros_ws catkin_create_pkg lab4_jetauto_control rospy geometry_msgs Refer to the teleop_key_control.py controller you used in this lab on how to publish to the jetauto nodes. Reference ROS Tutorials What is the Unified Robotics Description Format (URDF)? EECS 106A Labs","title":"Lab 4 : Robot Model, Gazebo and JetAuto"},{"location":"sea700/lab4/#lab-4-robot-model-gazebo-and-jetauto","text":"Seneca Polytechnic SEA700 Robotics for Software Engineers","title":"Lab 4 : Robot Model, Gazebo and JetAuto"},{"location":"sea700/lab4/#introduction","text":"","title":"Introduction"},{"location":"sea700/lab4/#urdf","text":"URDF (Unified Robot Description Format) is an XML format for representing a robot model. URDF is commonly used in Robot Operating System (ROS) tools such as rviz (Ros Visualization tool) and Gazebo simulator. It is essentially a 3-D model with information around joints, motors, mass, etc. The files are then run through the Robot Operating System (ROS). The data from the file informs the human operator what the robot looks like and is capable of before they begin operating the robot. More details on the URDF specification can be found here . Many robotic manufacturers have URDF models of their devices available for download. These include the Segway RMP , Turtlebot , and AR10 . More Models: Agility Robotics Digit ANYbotics Anymal Boston Dynamics Spot (via Clearpath ROS Driver) Clearpath Jackal Clearpath Dingo Clearpath Husky Clearpath Turtlebot Unitree Go1 Universal Robotics","title":"URDF"},{"location":"sea700/lab4/#urdf-vs-xacro","text":"URDF (Unified Robot Description Format) and XACRO (XML Macros) are both used in ROS (Robot Operating System) for robot modeling, but they have distinct roles. URDF is a straightforward XML format that describes the physical structure of a robot, detailing its links and joints, as well as their properties like geometry and dynamics. It's ideal for simpler robot designs where the model's complexity is limited. In contrast, XACRO is an extension of URDF that incorporates macros, allowing for parameterization and reducing redundancy in model descriptions. This makes XACRO particularly useful for complex robots or those with interchangeable components, as it facilitates easier maintenance and enhances readability. Typically, XACRO files are processed into URDF files before they are utilized in simulations or applications, combining the flexibility of XACRO with the straightforwardness of URDF.","title":"URDF vs XACRO"},{"location":"sea700/lab4/#rviz","text":"RViz, or Robot Visualization, is a powerful 3D visualization tool used primarily in robotics and the Robot Operating System (ROS). It enables developers to visualize and interpret a wide array of sensor data, such as point clouds, maps, and robot models, in real-time. With its interactive features, users can manipulate objects and adjust visual settings to enhance understanding of robot behavior and performance. RViz's plugin architecture allows for extensibility, accommodating various data types and visualization needs. This makes it an invaluable resource for debugging algorithms, simulating scenarios, and gaining insights into robotic systems, ultimately aiding in the development and refinement of robotics applications.","title":"RViz"},{"location":"sea700/lab4/#gazebo","text":"Gazebo is an open-source robotics simulation tool that provides a highly realistic environment for testing and developing robotic systems. It allows users to simulate robots in complex 3D environments, complete with detailed physics interactions, which include gravity, collisions, and friction. Gazebo supports a variety of sensors, such as cameras and LIDAR, enabling the generation of realistic sensor data for developing perception algorithms. Its seamless integration with the Robot Operating System (ROS) enhances its functionality, allowing developers to leverage ROS tools and libraries for robot control and communication. With a flexible plugin architecture, Gazebo can be customized to meet specific simulation needs, making it an essential platform for researchers and engineers in the field of robotics.","title":"Gazebo"},{"location":"sea700/lab4/#preparation","text":"","title":"Preparation"},{"location":"sea700/lab4/#jetauto-robot","text":"In preperation of using the JetAuto robot, please be familiar with the user manual and the basic lesson provided by the manufacturer found here: JetAuto User Manual JetAuto & JetAuto Pro Resources","title":"JetAuto Robot"},{"location":"sea700/lab4/#install-gazebo-and-other-ros-packages","text":"After being familiar with ROS, we'll now install the Gazebo simulation environment. Following the instruction here to install Gazebo version 9.X to be used with ROS Melodic. Each Gazebo version works with a specific version of ROS. sudo apt install gazebo9 libgazebo9-dev Once installed, start Gazebo with the following command to ensure it's functional: gazebo Figure 4.1 Gazebo Running Lastly, ensure the following ros gazebo packages are installed: sudo apt install ros-melodic-gazebo-dev ros-melodic-gazebo-msgs ros-melodic-gazebo-plugins ros-melodic-gazebo-ros ros-melodic-gazebo-ros-control ros-melodic-gazebo-ros-pkgs ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller ros-melodic-moveit ros-melodic-trac-ik-kinematics-plugin ros-melodic-slam-gmapping","title":"Install Gazebo and other ROS packages"},{"location":"sea700/lab4/#procedures","text":"","title":"Procedures"},{"location":"sea700/lab4/#jetauto-robot-inspection","text":"The robot we have for this course is the JetAuto Pro assembled in the configuration: Figure 4.2 JetAuto Pro Before using the JetAuto robot, read the following: JetAuto User Manual Page 01: Guide to Battery Safety Page 03: JetAuto Pro Standard Kit Packing List Page 04-09: Installation Instruction (except for 1.4 LCD) Check all nuts and bolts to ensure confirm installation and security Page 10-11: Charging and Starting the Robot We will NOT be using the smartphone app for controlling the robot.","title":"JetAuto Robot Inspection"},{"location":"sea700/lab4/#ssh-into-the-jetauto-robot","text":"Copy this lab instruction somewhere on your computer as you'll lose connection to the internet! By default, the JetAuto is configured to be in Wifi AP mode. Power on the robot and connect to the robot's WiFi starting in \"HW-\". If you are unsure of which Wifi SSID is your robot broadcasting, open the \"Tool\" application on the robot and look for the AP name in the setting. Do NOT change any of the default settings. The password for the WiFi connection is: hiwonder . Once connected, use terminal (or PuTTY) to SSH into the robot at \"192.168.149.1\". ssh jetauto@192.168.149.1 The user is: jetauto , and the password is: hiwonder .","title":"SSH Into the JetAuto Robot"},{"location":"sea700/lab4/#usb-connection-with-the-robot","text":"It is also possible to connect with the robot via USB using the Jetson Nano's micro-B USB port. Use screen terminal application to connection with the robot. sudo apt-get install -y screen sudo screen /dev/ttyACM0 115200","title":"USB connection with the robot"},{"location":"sea700/lab4/#nomachine-use-with-caution","text":"Only recommended to be used on within a virtual machine. For security, stop the NoMachine server after you installation. NoMachine is another application that can be used to for remote connection with the JetNano board. Once you are connected with the robot, the credential is the same as above.","title":"NoMachine (Use with caution)"},{"location":"sea700/lab4/#jetauto-robot-movement","text":"Ensure the battery charging cable is UNPLUGGED and all cables on the robot are secure. Ensure all structures, nuts and bolts on the robot are tightly fastened. Ensure the robot is on the ground and awy from any obstacles. In a terminal that's connected to the JetAuto robot using SSH or in JetAuto's terminal using remote desktop, stop the app service then start the jetauto_controller service: sudo systemctl stop start_app_node.service roslaunch jetauto_controller jetauto_controller.launch Now that the controller service has started, we can publish move command as Twist message to the motion controller. Before publish a command to the robot, remember you must issue a stop command for the robot to stop. Let's issue that first so you can recall it faster. rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should not do anything. Issue a move in the x-direction (forward) at 0.3 m/s, x: 0.3 : rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Your robot should now start moving. Be ready to stop the robot by issuing (or up arrow twice): rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' DO NOT set the movement value above 0.7 m/s to keep the robot within it control limit. The linear values refer to the translation of the robot. Positive X is forward and positive Y is left. There is no Z-direction for this robot. Do not exceed 0.7 m/s. The angular values refer to the rotation of the robot. Only Z-rotation is considered with positive value as counter-clockwise. Do not exceed 3.5 rad/s.","title":"JetAuto Robot Movement"},{"location":"sea700/lab4/#copying-jetauto-workspace-to-local-machine-for-simulation","text":"After figuring out how to control the JetAuto robot, let's copy the JetAuto workspace jetauto_ws over from the robot to our local machine so we can inspect and use it locally. Open a new terminla (you may close your SSH terminal) and run the following command locally to use rsync to copy the directory over: Run these commands on your local machine! Not in the SSH terminal. rsync -av jetauto@192.168.149.1:~/jetauto_ws/ ~/jetauto_ws Once jetauto_ws is on your virtual machine's home directory, let's add it as a source in ~/.bashrc . echo \"source /home/jetauto/jetauto_ws/devel/setup.bash\" >> ~/.bashrc Let's inspect the source code of the motion controller. Open the file at the following path: ~/jetauto_ws/src/jetauto_driver/jetauto_controller/scripts/jetauto_controller_main.py As we can see in the controller code: linear_x = self.go_factor*msg.linear.x linear_y = self.go_factor*msg.linear.y angular_z = self.turn_factor*msg.angular.z speed_up = False if abs(self.last_linear_x - linear_x) > 0.2 or abs(self.last_linear_y - linear_y) > 0.2 or abs(self.last_angular_z - angular_z) > 1: speed_up = True self.last_linear_x = linear_x self.last_linear_y = linear_y self.last_angular_z = angular_z linear_x_, linear_y_ = linear_x * 1000.0, linear_y * 1000.0#mm to m speed = math.sqrt(linear_x_ ** 2 + linear_y_ ** 2) direction = math.atan2(linear_y_, linear_x_) direction = math.pi * 2 + direction if direction < 0 else direction self.mecanum.set_velocity(speed, direction, angular_z, speed_up=speed_up) The Twist message from cmd_vel provides the necessary information to calculate speed , direction , and angular_z for controlling the mecanum wheel using the MecanumChassis object. Refer to JetAuto & JetAuto Pro Resources chapter 7.3 for the working principle of the mecanum wheel. Try other various combination of motion command to gain a better understanding of the robot's movement. Next, we'll try controlling the JetAuto robot using keyboard input. Keep the jetauto_controller terminal open. In a new/other terminal, run: roslaunch jetauto_peripherals teleop_key_control.launch robot_name:=\"/\" Use w, a, s, d to control the robot. Inspect the source code of the teleop controller to understand it's operation by opening the file at: ~/jetauto_ws/src/jetauto_peripherals/scripts/teleop_key_control.py","title":"Copying JetAuto Workspace to Local Machine for Simulation"},{"location":"sea700/lab4/#jetauto-robot-model","text":"Now that we can control the basic movement of the JetAuto robot, let's try to simulate it in Gazebo. Robot model in URDF consist of links that are joined together to form a robot assembly. Each link have its given geometry, mass, and collision parameter. The geometry can be provide as simple shape or complex shape using solid model. Before we start, let's ensure we have the required package installed (if you haven't installed it from the beginning of this lab) to view and test our robot model: sudo apt install ros-melodic-joint-state-publisher ros-melodic-joint-state-publisher-gui ros-melodic-joint-trajectory-controller Before we can simulate the JetAuto in ROS and gazebo, we first need to set some environment variables that our launch script look for. Edit the system's environment variables: sudo gedit /etc/environment We'll add the following in the environment: LIDAR_TYPE=\"A1\" DEPTH_CAMERA_TYPE=\"AstraProPlus\" MACHINE_TYPE=\"JetAutoPro\" HOST=\"/\" MASTER=\"/\" Restart your system in order for the change to take effect. To have a quick view at the URDF model, we can us RViz: roslaunch jetauto_description display.launch model:=urdf/jetauto.urdf You can use the joint_state_publisher_gui to adjust the arm angle. Figure 4.3 JetAuto in Gazebo Let's open up the JetAuto URDF model file to take a look at it more closely. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto_car.urdf.xacro Here, we see a file in XML format: <robot name=\"jetauto\" xmlns:xacro=\"http://ros.org/wiki/xacro\" > <xacro:property name=\"M_PI\" value=\"3.1415926535897931\"/> <xacro:property name=\"base_link_mass\" value=\"1.6\" /> <xacro:property name=\"base_link_w\" value=\"0.297\"/> <xacro:property name=\"base_link_h\" value=\"0.145\"/> <xacro:property name=\"base_link_d\" value=\"0.11255\"/> <xacro:property name=\"wheel_link_mass\" value=\"0.1\" /> <xacro:property name=\"wheel_link_radius\" value=\"0.049\"/> <xacro:property name=\"wheel_link_length\" value=\"0.04167\"/> The first few lines define the robot's name and the basic parameters of the JetAuto's body. M_PI defines the value of \u03c0. base_link_mass defines the mass of the JetAuto\u2019s body model. base_link_w defines the width of the JetAuto\u2019s body model. base_link_h defines the height of of the JetAuto\u2019s body model. base_link_d defines the length of of the JetAuto\u2019s body model. wheel_link_mass defines the mass of each mecanum wheel. wheel_link_radius defines the radius of each mecanum wheel. The name of the robot is also defined as jetauto . <link name=\"base_footprint\"/> <joint name=\"base_joint\" type=\"fixed\"> <parent link=\"base_footprint\"/> <child link=\"base_link\"/> <origin xyz=\"0.0 0.0 0.0\" rpy=\"0 0 0\"/> </joint> base_footprint is defined as the top parent link (part) of the JetAuto model to create a overall envolope that sits as the origin. base_link is the base part of the robot that house the battery and motor. In the URDF mode, it is connected to base_footprint as a child linke. This envolope configuration ensure the wheel of the robot will always above the origin (ground). <link name=\"base_link\"> <xacro:box_inertial m=\"${base_link_mass}\" w=\"${base_link_w}\" h=\"${base_link_h}\" d=\"${base_link_d}\"/> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/base_link.stl\" /> </geometry> <material name=\"green\"/> </visual> <collision> <origin xyz=\"${base_link_w/2.0 - 0.14810} 0 ${0.126437/2 + 0.02362364}\" rpy=\"0 0 0\" /> <geometry> <box size=\"${base_link_w} ${base_link_h} ${base_link_d}\" /> </geometry> </collision> </link> Next is the link/part base_link along with it's elements. The mass and inertial information of the part is defined as an xacro element. The geometry sub-element in the visual element is provide by a stl mesh file from the jetauto_description package. The collision element is also defined as a box relative to the specified xyz cordinate. Figure 4.4 JetAuto base_link STL <link name=\"back_shell_link\"> <inertial> <origin xyz=\"-1.22838595456587E-05 0.00218574826309681 -0.0500522861933898\" rpy=\"0 0 0\" /> <mass value=\"0.0663478534899862\" /> <inertia ixx=\"5.65277934912267E-05\" ixy=\"-5.13394387877366E-11\" ixz=\"-4.07561372273553E-11\" iyy=\"4.33740893441632E-05\" iyz=\"-5.43059341238134E-06\" izz=\"6.86642544694324E-05\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> <material name=\"black\"> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://jetauto_description/meshes/back_shell_link.stl\" /> </geometry> </collision> </link> <joint name=\"back_shell_joint\" type=\"fixed\"> <origin xyz=\"-0.076481 0 0.082796\" rpy=\"-3.1416 0 1.5708\" /> <parent link=\"base_link\" /> <child link=\"back_shell_link\" /> <axis xyz=\"0 0 0\" /> </joint> The back_shell_link is the part that house the Jetson Nano, the expansion board, and mount the antenna. All the elements are defined in a similar manner as back_link and it's defined as a child link of back_link within it's relative position defined in joint . The wheel_XXX_link are all defined in a similar manner. The JetAuto URDF model file above only defined the mechancial structure of the robot. If we take a look at the URDF file for simulating the robot in Gazebo, we'll find more links that are used and defined in other URDF files within the same package. ~/jetauto_ws/src/jetauto_simulations/jetauto_description/urdf/jetauto.xacro If you are interested in building a URDF from scratch, visit the ROS tutorial here .","title":"JetAuto Robot Model"},{"location":"sea700/lab4/#running-jetauto-in-gazebo","text":"In a terminal, launch: roslaunch jetauto_gazebo worlds.launch Gazebo should run and you should see the JetAuto robot in the simulation enviornment. Figure 4.5 JetAuto in Gazebo With gazebo and ros running, we can now control the virtual robot the same way as the physical robot. Let's try publishing to the cmd_vel topic: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' Stop the robot: rostopic pub -1 /jetauto_controller/cmd_vel geometry_msgs/Twist '{linear: {x: 0.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}' We can also use the keyboard to control the robot: roslaunch jetauto_peripherals teleop_key_control.launch robot_name:=\"/\"","title":"Running JetAuto in Gazebo"},{"location":"sea700/lab4/#lab-question","text":"Write a code that will move the JetAuto robot in a roughly 1m square shape pattern as follow: (0, 0, 0\u00b0) to (1, 0, 0\u00b0) - face the direction of travel (1, 0, 0\u00b0) to (1, 1, 0\u00b0) - face the outside of the square (1, 1, -90\u00b0) to (0, 1, -90\u00b0) - rotate first to face the inside of the square (0, 1, -90\u00b0) to (0, 0, 0\u00b0) - rotate the robot while traveling Repeat this for 2 times after a start command (such as a keyboard input) is given. For example: when you run rosrun lab4_jetauto_control jetauto_control , it'll ask for an input before performing the above action. Hint: You can follow the same approach as Lab 3 by creating a new package called lab4_jetauto_control in your ros_ws catkin_create_pkg lab4_jetauto_control rospy geometry_msgs Refer to the teleop_key_control.py controller you used in this lab on how to publish to the jetauto nodes.","title":"Lab Question"},{"location":"sea700/lab4/#reference","text":"ROS Tutorials What is the Unified Robotics Description Format (URDF)? EECS 106A Labs","title":"Reference"},{"location":"sea700/lab5/","text":"Lab 5 : Robotic Arm and SLAM Seneca Polytechnic SEA700 Robotics for Software Engineers Forward Kinematics As discussed in lecture, the forward kinematics problem involves fnding the confguration of a specifed link in a robotic manipulator relative to some other reference frame, given the angles of each of the joints in the manipulator. Denavit\u2013Hartenberg (DH) Parameters In mechanical engineering, the Denavit\u2013Hartenberg parameters (also called DH parameters) are the four parameters associated with a particular convention for attaching reference frames to the links of a spatial kinematic chain, or robot manipulator. In this convention, coordinate frames are attached to the joints between two links such that one transformation is associated with the joint [Z] , and the second is associated with the link [X] . The coordinate transformations along a serial robot consisting of n links form the kinematics equations of the robot: [T] = [Z_1][X_1][Z_2][X_2]...[Z_{n-1}][X_{n-1}][Z_n][X_n] where [T] is the transformation that characterizes the location and orientation of the end-link. Figure 5.1 DH Kinematics Links As shown in the figure above, each joints (i-1, i, and i+1) has a unique line S (shown as dotted line in the figure above) in space that forms the joint axis and define the relative movement of its two links. For each sequence of lines S_i and S_{i+1} , there is a common normal line A_{i, i+1} . By convention: z -direction is the joint axes S . z_i describe the joint attached to the end of \\textrm{Link}_i . x -direction is the common normal A . x_i = z_{i} \\times z_{i-1} is the common normal A_{i, i+1} . If there are no unqiue common normal, d_i below become a free parameter and can be defined by joint configuration. y -direction is third direction using right-hand rule. Four Parameters The following four transformation parameters (labelled in red text in the figure above) are known as the DH parameters: Descriptions of the Joint d_i : sliding / offset along the joint axis S_i ( z_{i-1} ) from the old common normal A_{i-1, i} ( x_{x-1} ) to the common normal A_{i, i+1} ( x_i ) \\theta_i : rotation about joint axis S_i ( z_{i-1} ) from the old common normal A_{i-1, i} ( x_{x-1} ) to the common normal A_{i, i+1} ( x_i ) Physical Dimensions of the Link a_i (or r_i ): arm length / length along the common normal A_{i, i+1} ( x_i ) from the joint axis S_i ( z_{i-1} ) to the next joint axis S_{i+1} ( z_i ) at the end of \\textrm{Link}_i \\alpha_i : rotation about the common normal A_{i, i+1} ( x_i ) from the joint axis S_i ( z_{i-1} ) to the next joint axis S_{i+1} ( z_i ) at the end of \\textrm{Link}_i This convention allows the definition of the movement of links around a common joint axis S_i by the screw displacement: [Z_i] = \\begin{bmatrix} cos \\theta_i & -sin \\theta_i & 0 & 0 \\\\ sin \\theta_i & cos \\theta_i & 0 & 0 \\\\ 0 & 0 & 1 & d_i \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} Each of these parameters could be a constant depending on the structure of the robot. Under this convention the dimensions of each link in the serial chain are defined by the screw displacement around the common normal A_{i, i+1} from the joint S_i to S_{i+1} , which is given by: [X_i] = \\begin{bmatrix} 1 & 0 & 0 & a_{i, i+1} \\\\ 0 & cos \\alpha_{i, i+1} & -sin \\alpha_{i, i+1} & 0 \\\\ 0 & sin \\alpha_{i, i+1} & cos \\alpha_{i, i+1} & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} where \\alpha_{i, i+1} and a_{i, i+1} define the physical dimensions of the link in terms of the angle measured around and distance measured along the x-axis. JetAuto Arm Forward Kinematics Figure 5.2 JetAuto Arm Links The figure above shows the kinematic link diagram of the JetAuto arm. Let's create the DH parameters table for the first two joints: Joint-0 is the base platform and will be used as the global reference. Joint-1 is the rotation platform of the robotics arm. It's a rotary joint about the joint axis ( \\z_0 ). Therefore, only \\theta_1 (angle between \\x_0 and \\x_1 ) is non-zero. We can assume that Joint-1 is at the same position as Joint-0. Joint-2 is the rotation of the first segment of the robotics arm. It is a rotary joint with a distance, d , offset from Joint-1 (Joint-0). There is a 90\u00b0 change between the Joint-1 (z_1) and Joint-2 axis (z_2). Therefore, \\alpha_2 = 90\u00b0 (angle between z_1 and z_2 about x_2). It will also have a rotation about the Joint-2 axis (z_2), \\theta_2 (angle between x_1 and x_2). Putting this all together yield the following DH parameters table: Table 5.1 JetAuto DH Parameters Table DH# d \u03b8 a \u03b1 1 0 \\theta_1 0 0 2 d 0 0 - \\pi / 2 3 4 ROS MoveIt ROS MoveIt is a powerful software framework designed for robot motion planning and manipulation within the Robot Operating System (ROS) ecosystem. It provides a robust set of tools and libraries that enable developers to implement complex motion planning algorithms, manage robot kinematics, and execute real-time motion tasks. With features such as collision detection, trajectory optimization, and support for various robotic platforms, MoveIt simplifies the process of programming robots to perform intricate movements. Its flexibility and extensibility make it a popular choice for both research and industrial applications, allowing users to create sophisticated robotic solutions tailored to specific needs. Figure 5.3 ROS MoveIt More details on MoveIt can be found here . Simultaneous Localization and Mapping (SLAM) Simultaneous localization and mapping (SLAM) is the computational problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent's location within it.Popular approximate solution methods include the particle filter, extended Kalman filter, covariance intersection, and GraphSLAM. SLAM algorithms are based on concepts in computational geometry and computer vision, and are used in robot navigation, robotic mapping and odometry for virtual reality or augmented reality. SLAM algorithms are tailored to the available resources and are not aimed at perfection but at operational compliance. Published approaches are employed in self-driving cars, unmanned aerial vehicles, autonomous underwater vehicles, planetary rovers, newer domestic robots and even inside the human body. JetAuto Robot Arm Control Before controlling JetAuto's robot arm, let make sure we have all the package necessary installed. We'll also install the GMapping package for the second part of this Lab. Open a terminal and run the following command: sudo apt install ros-melodic-moveit ros-melodic-trac-ik-kinematics-plugin ros-melodic-slam-gmapping ros-melodic-map-server ros-melodic-amcl ros-melodic-move-base ros-melodic-global-planner First, we'll try simulating JetAuto's robot arm in ROS using MoveIt along with a gazebo model. Open terminal and run: roslaunch jetauto_moveit_config demo_gazebo.launch fake_execution:=false This should load a RViz and a Gazebo windows. By provide the false to the fake_execution argument, we'll be able to move the robot arm in the Gazebo model as well. Figure 5.4 JetAuto MoveIt The top left Panel labelled \"Displays\" is the RViz Tool Bar, the bottom left Panel labelled \"MotionPlanning\" is the MoveIt Tool Area, the right Panel is the Simulation view. In the Simulation view, you can use your mouse (rigth click, left click, middle click, and wheel) to adjust the view. Select the \"Planning\" tab in MoveIt and ensure the \"Planning Group\" is \"arm\". Move the model in the Simulation view around to set the joint goal of the arm: The Blue ball control the position of the end effector in 3d space The Red Arrow control the y-axis of the end effector The Green Arrow control the x-axis of the end effector The Blue Arrow control the z-axis of the end effector Remember, once the arm is moved, the axis refer to the end effector's frame of reference. Figure 5.5 JetAuto MoveIt Planning When you set the goal for the robot arm, MoveIt performs inverse kinematics (IK) to determine the configuration for each joint to reach the goal. When calculating the IK, collisions with other parts of the robot are already taken into consideration. If there are any anticipated collisions, they are indicated in red. You can also also perform forward kinematics by scrolling over to the \"Joints\" tab in MoveIt to view and adjust the goal rotation angle of each joint. Figure 5.6 JetAuto MoveIt Planning Joints Once you are ready with the position for the arm to move to, go back to the \"Planning\" tab and click \"Plan & Execute\" . You should see the model move from the current state to the goal state. The gazebo model should move as well. Figure 5.7 JetAuto MoveIt Planning Gazebo View (Optional) If you want, you can go through the demo videos and lessions provided by the manufacturer to gain a better understanding on the robot arm. JetAuto & JetAuto Pro Resources Chapter 15.1 All Lesson Chapter 15.2 Lesson 2 - Demo Video Lesson 3 - Demo Video Lesson 4 Lesson 5 - Demo Video Lesson 6 - Demo Video Lesson 7 - Demo Video Lesson 8 - Demo Video MoveIt Python Interface Next, let's use a Python interface to work with MoveIt. Build a new ROS package in your ros_ws workspace and put the following script into your package and call it move_group_python_interface_tutorial.py . This script is from the MoveIt Tutorial using the Panda robot but changed to work with the JetAuto robot. #!/usr/bin/env python import sys import copy import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg from math import pi from std_msgs.msg import String from moveit_commander.conversions import pose_to_list ## END_SUB_TUTORIAL def all_close(goal, actual, tolerance): \"\"\" Convenience method for testing if a list of values are within a tolerance of their counterparts in another list @param: goal A list of floats, a Pose or a PoseStamped @param: actual A list of floats, a Pose or a PoseStamped @param: tolerance A float @returns: bool \"\"\" all_equal = True if type(goal) is list: for index in range(len(goal)): if abs(actual[index] - goal[index]) > tolerance: return False elif type(goal) is geometry_msgs.msg.PoseStamped: return all_close(goal.pose, actual.pose, tolerance) elif type(goal) is geometry_msgs.msg.Pose: return all_close(pose_to_list(goal), pose_to_list(actual), tolerance) return True class MoveGroupPythonIntefaceTutorial(object): \"\"\"MoveGroupPythonIntefaceTutorial\"\"\" def __init__(self): super(MoveGroupPythonIntefaceTutorial, self).__init__() ## BEGIN_SUB_TUTORIAL setup ## ## First initialize `moveit_commander`_ and a `rospy`_ node: moveit_commander.roscpp_initialize(sys.argv) rospy.init_node('move_group_python_interface_tutorial', anonymous=True) ## Instantiate a `RobotCommander`_ object. Provides information such as the robot's ## kinematic model and the robot's current joint states robot = moveit_commander.RobotCommander() ## Instantiate a `PlanningSceneInterface`_ object. This provides a remote interface ## for getting, setting, and updating the robot's internal understanding of the ## surrounding world: scene = moveit_commander.PlanningSceneInterface() ## Instantiate a `MoveGroupCommander`_ object. This object is an interface ## to a planning group (group of joints). In this tutorial the group is the primary ## arm joints in the Panda robot, so we set the group's name to \"panda_arm\". ## If you are using a different robot, change this value to the name of your robot ## arm planning group. ## This interface can be used to plan and execute motions: ##group_name = \"panda_arm\" group_name = \"arm\" move_group = moveit_commander.MoveGroupCommander(group_name) ## Create a `DisplayTrajectory`_ ROS publisher which is used to display ## trajectories in Rviz: display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=20) ## END_SUB_TUTORIAL ## BEGIN_SUB_TUTORIAL basic_info ## ## Getting Basic Information ## ^^^^^^^^^^^^^^^^^^^^^^^^^ # We can get the name of the reference frame for this robot: planning_frame = move_group.get_planning_frame() print \"============ Planning frame: %s\" % planning_frame # We can also print the name of the end-effector link for this group: eef_link = move_group.get_end_effector_link() print \"============ End effector link: %s\" % eef_link # We can get a list of all the groups in the robot: group_names = robot.get_group_names() print \"============ Available Planning Groups:\", robot.get_group_names() # Sometimes for debugging it is useful to print the entire state of the # robot: print \"============ Printing robot state\" print robot.get_current_state() print \"\" ## END_SUB_TUTORIAL # Misc variables self.box_name = '' self.robot = robot self.scene = scene self.move_group = move_group self.display_trajectory_publisher = display_trajectory_publisher self.planning_frame = planning_frame self.eef_link = eef_link self.group_names = group_names def go_to_joint_state(self): # Copy class variables to local variables to make the web tutorials more clear. # In practice, you should use the class variables directly unless you have a good # reason not to. move_group = self.move_group ## BEGIN_SUB_TUTORIAL plan_to_joint_state ## ## Planning to a Joint Goal ## ^^^^^^^^^^^^^^^^^^^^^^^^ ## The Panda's zero configuration is at a `singularity <https://www.quora.com/Robotics-What-is-meant-by-kinematic-singularity>`_ so the first ## thing we want to do is move it to a slightly better configuration. # We can get the joint values from the group and adjust some of the values: joint_goal = move_group.get_current_joint_values() joint_goal[0] = pi/4 joint_goal[1] = pi/4 joint_goal[2] = pi/4 joint_goal[3] = pi/4 # The go command can be called with joint values, poses, or without any # parameters if you have already set the pose or joint target for the group move_group.go(joint_goal, wait=True) # Calling ``stop()`` ensures that there is no residual movement move_group.stop() ## END_SUB_TUTORIAL # For testing: current_joints = move_group.get_current_joint_values() return all_close(joint_goal, current_joints, 0.01) def main(): try: print \"\" print \"----------------------------------------------------------\" print \"Welcome to the MoveIt MoveGroup Python Interface Tutorial\" print \"----------------------------------------------------------\" print \"Press Ctrl-D to exit at any time\" print \"\" print \"============ Press `Enter` to begin the tutorial by setting up the moveit_commander ...\" raw_input() tutorial = MoveGroupPythonIntefaceTutorial() print \"============ Press `Enter` to execute a movement using a joint state goal ...\" raw_input() tutorial.go_to_joint_state() print \"============ Python tutorial demo complete!\" except rospy.ROSInterruptException: return except KeyboardInterrupt: return if __name__ == '__main__': main() To use the Python MoveIt interfaces, we will import the moveit_commander namespace. This namespace provides us with a MoveGroupCommander class, a PlanningSceneInterface class, and a RobotCommander class. More on these below. We also import rospy and some messages that we will use: import sys import copy import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg from math import pi from std_msgs.msg import String from moveit_commander.conversions import pose_to_list First initialize moveit_commander and a rospy node: moveit_commander.roscpp_initialize(sys.argv) rospy.init_node('move_group_python_interface_tutorial', anonymous=True) Instantiate a RobotCommander object. Provides information such as the robot\u2019s kinematic model and the robot\u2019s current joint states robot = moveit_commander.RobotCommander() Instantiate a PlanningSceneInterface object. This provides a remote interface for getting, setting, and updating the robot\u2019s internal understanding of the surrounding world: scene = moveit_commander.PlanningSceneInterface() Instantiate a MoveGroupCommander object. This object is an interface to a planning group (group of joints). In this tutorial the group is the primary arm joints in the JetAuto robot, so we set the group\u2019s name to arm . If you are using a different robot, change this value to the name of your robot arm planning group. This interface can be used to plan and execute motions: group_name = \"arm\" move_group = moveit_commander.MoveGroupCommander(group_name) Create a DisplayTrajectory ROS publisher which is used to display trajectories in Rviz: display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=20) Getting Basic Information: # We can get the name of the reference frame for this robot: planning_frame = move_group.get_planning_frame() print \"============ Planning frame: %s\" % planning_frame # We can also print the name of the end-effector link for this group: eef_link = move_group.get_end_effector_link() print \"============ End effector link: %s\" % eef_link # We can get a list of all the groups in the robot: group_names = robot.get_group_names() print \"============ Available Planning Groups:\", robot.get_group_names() # Sometimes for debugging it is useful to print the entire state of the # robot: print \"============ Printing robot state\" print robot.get_current_state() print \"\" Planning to a Joint Goal: # We can get the joint values from the group and adjust some of the values: joint_goal = move_group.get_current_joint_values() joint_goal[0] = pi/4 joint_goal[1] = pi/4 joint_goal[2] = pi/4 joint_goal[3] = pi/4 # The go command can be called with joint values, poses, or without any # parameters if you have already set the pose or joint target for the group move_group.go(joint_goal, wait=True) # Calling ``stop()`` ensures that there is no residual movement move_group.stop() Make sure you made the file executeable using chmod +x . Build the package and run the script. You should see the robot arm in RViz and Gazebo move to the new configuration you defined. Lastly, let's try everything out on the physical robot. Copy your workspace to the JetAuto then SSH into the JetAuto. Stop the APP service on the robot: sudo systemctl stop start_app_node.service For the robot arm on the JetAuto to work, we need to start the servo controller service: roslaunch hiwonder_servo_controllers start.launch Next, start MoveIt on the JetAuto. This time, we won't be using Gazebo simulation: roslaunch jetauto_moveit_config demo.launch fake_execution:=false You can now move the robot arm using MoveIt interface as well as the script in your package. JetAuto Robot Arm Control (Without MoveIt) Although MoveIt is a good tool for simulating and moving the robot arm, but you can control the robot arm without using MoveIt. Create another python script in your package with the following: #!/usr/bin/env python3 import rospy import signal from hiwonder_servo_msgs.msg import MultiRawIdPosDur from hiwonder_servo_controllers.bus_servo_control import set_servos from kinematics.search_kinematics_solutions import SearchKinematicsSolutions class MoveServoNode: def __init__(self, name): rospy.init_node(name, anonymous=True) self.z_dis = 0.4 self.y_init = 0.15 signal.signal(signal.SIGINT, self.shutdown) self.joints_pub = rospy.Publisher('servo_controllers/port_id_1/multi_id_pos_dur', MultiRawIdPosDur, queue_size=1) rospy.sleep(0.2) self.search_kinemactis_solutions = SearchKinematicsSolutions() while not rospy.is_shutdown(): try: if rospy.get_param('/hiwonder_servo_manager/running') and rospy.get_param('/joint_states_publisher/running'): break except: rospy.sleep(0.1) self.move_servo() def shutdown(self, signum, frame): rospy.loginfo('shutdown') def move_servo(self): if self.z_dis > 0.43: self.z_dis = 0.43 if self.z_dis < 0.33: self.z_dis = 0.33 res = self.search_kinemactis_solutions.solveIK((0, self.y_init, self.z_dis), 0, -90, 90) if res: joint_data = res[1] rospy.sleep(0.5) set_servos(self.joints_pub, 1500, ((1, 500), (2, joint_data['joint4']), (3, joint_data['joint3']), (4, joint_data['joint2']), (5, joint_data['joint1']))) rospy.sleep(1.8) rospy.signal_shutdown('shutdown') if __name__ == '__main__': MoveServoNode('move_servo') The above code is extracted from example code found in: ~/jetauto_ws/src/jetauto_example/scripts/ It allows you to control the position of the robot arm end effector through inverse kinematics. Controlling the arm's servo directly is NOT recommended as you'll need to manually define collision limits. Run the script and the robot arm should move to the given position. JetAuto SLAM (Simulation) Open a terminal your computer (not the robot) and run the following: roslaunch jetauto_gazebo room_worlds.launch This will open up a JetAuto model in a room populated with furnitures. Figure 5.8 Gazebo Room Press the \"Play\" buttons at the button of the Gazebo simulator. Start the SLAM node. Open a new terminal and start: roslaunch jetauto_slam slam.launch sim:=true You can ignore the \"No module named 'smbus2'\" error because we don't have a joystick connected. Start RViz to visualize the map. Open a new terminal and start: roslaunch jetauto_slam rviz_slam.launch sim:=true If RViz does not load with the proper config, go to File > Open Config and open the follow config file: ~/jetauto_ws/src/jetauto_slam/rviz/without_namespace/gmapping_sim.rviz You can close the default.rviz without saving. Figure 5.8 Gazebo Room Mapping Start the keyboard controller and move the robot around to map the entire room. Once you are satisfied, open a new terminal and navigate to the slam map directory: roscd jetauto_slam/maps We'll save the map as map_01 : rosrun map_server map_saver -f map_01 map:=/map You should see something similar to this output from the terminal: [ INFO] [1729620059.595167203]: Waiting for the map [ INFO] [1729620060.388306846]: Received a 1248 X 384 map @ 0.025 m/pix [ INFO] [1729620060.388618676]: Writing map occupancy data to map_01.pgm [ INFO] [1729620060.400554480, 1407.036000000]: Writing map occupancy data to map_01.yaml [ INFO] [1729620060.400909179, 1407.036000000]: Done Your map has now been saved. Close the SLAM and RViz terminals. You can keep the Gazebo room open. With the map saved, we'll now use it for navigation. Open a new terminal and run: roslaunch jetauto_navigation navigation.launch sim:=true map:=map_01 Open a new terminal and run: roslaunch jetauto_navigation rviz_navigation.launch sim:=true There's an error with the above code that still needs to be solved. We will need to perform the SLAM step using a phsyical robot for now. JetAuto SLAM (Physical Robot) Let's try everything out on the physical robot. Connect into the JetAuto using NoMachine or any remote Desktop software and stop the APP service on the robot: sudo systemctl stop start_app_node.service Start the SLAM node and use gmapping as the mapping method: roslaunch jetauto_slam slam.launch slam_methods:=gmapping Open a new terminal and start RViz to visualize the map. Open a new terminal and start: roslaunch jetauto_slam rviz_slam.launch slam_methods:=gmapping Open a new terminal and start the keyboard controller and move the robot around to map the entire room. Once you are satisfied, open a new terminal and navigate to the slam map directory: roscd jetauto_slam/maps We'll save the map as map_01 : rosrun map_server map_saver -f map_01 map:=/jetauto_1/map You should see something similar to this output from the terminal: [ INFO] [1729620059.595167203]: Waiting for the map [ INFO] [1729620060.388306846]: Received a 1248 X 384 map @ 0.025 m/pix [ INFO] [1729620060.388618676]: Writing map occupancy data to map_01.pgm [ INFO] [1729620060.400554480, 1407.036000000]: Writing map occupancy data to map_01.yaml [ INFO] [1729620060.400909179, 1407.036000000]: Done Your map has now been saved. Close the SLAM and RViz terminals. With the map saved, we'll now use it for navigation. Open a new terminal and run: roslaunch jetauto_navigation navigation.launch map:=map_01 Open a new terminal and run: roslaunch jetauto_navigation rviz_navigation.launch Now you can use the 2D Pose Estimate , 2D Nav Goal and Publish Point to help you navigate. 2D Pose Estimate is used to set the initial position of JetAuto, 2D Nav Goal is used to set a target point Publish Point is used to set multiple target points Lab Question Find the approximate artesian coordinate of the end effector (tip of the gripper) of the JetAuto if: \\theta_1 = 45 \\theta_2 = -30 \\theta_3 = 85 \\theta_4 = 25 You'll need to measure the dimension of each link and construct the foward kinematics using DH parameters. You can perform the calculation by hand or using software (such as Python). You are not allowed to just read the position from ROS. Write a program that will move the robot arm to the position in question 1. Use SLAM to create and save a map of the class room. Afterward, demostrate navigating from one corner of the class to another. Reference Denavit\u2013Hartenberg parameters ROS Tutorials EECS 106A Labs","title":"Lab 5 : Robotic Arm and SLAM"},{"location":"sea700/lab5/#lab-5-robotic-arm-and-slam","text":"Seneca Polytechnic SEA700 Robotics for Software Engineers","title":"Lab 5 : Robotic Arm and SLAM"},{"location":"sea700/lab5/#forward-kinematics","text":"As discussed in lecture, the forward kinematics problem involves fnding the confguration of a specifed link in a robotic manipulator relative to some other reference frame, given the angles of each of the joints in the manipulator.","title":"Forward Kinematics"},{"location":"sea700/lab5/#denavithartenberg-dh-parameters","text":"In mechanical engineering, the Denavit\u2013Hartenberg parameters (also called DH parameters) are the four parameters associated with a particular convention for attaching reference frames to the links of a spatial kinematic chain, or robot manipulator. In this convention, coordinate frames are attached to the joints between two links such that one transformation is associated with the joint [Z] , and the second is associated with the link [X] . The coordinate transformations along a serial robot consisting of n links form the kinematics equations of the robot: [T] = [Z_1][X_1][Z_2][X_2]...[Z_{n-1}][X_{n-1}][Z_n][X_n] where [T] is the transformation that characterizes the location and orientation of the end-link. Figure 5.1 DH Kinematics Links As shown in the figure above, each joints (i-1, i, and i+1) has a unique line S (shown as dotted line in the figure above) in space that forms the joint axis and define the relative movement of its two links. For each sequence of lines S_i and S_{i+1} , there is a common normal line A_{i, i+1} . By convention: z -direction is the joint axes S . z_i describe the joint attached to the end of \\textrm{Link}_i . x -direction is the common normal A . x_i = z_{i} \\times z_{i-1} is the common normal A_{i, i+1} . If there are no unqiue common normal, d_i below become a free parameter and can be defined by joint configuration. y -direction is third direction using right-hand rule.","title":"Denavit\u2013Hartenberg (DH) Parameters"},{"location":"sea700/lab5/#four-parameters","text":"The following four transformation parameters (labelled in red text in the figure above) are known as the DH parameters: Descriptions of the Joint d_i : sliding / offset along the joint axis S_i ( z_{i-1} ) from the old common normal A_{i-1, i} ( x_{x-1} ) to the common normal A_{i, i+1} ( x_i ) \\theta_i : rotation about joint axis S_i ( z_{i-1} ) from the old common normal A_{i-1, i} ( x_{x-1} ) to the common normal A_{i, i+1} ( x_i ) Physical Dimensions of the Link a_i (or r_i ): arm length / length along the common normal A_{i, i+1} ( x_i ) from the joint axis S_i ( z_{i-1} ) to the next joint axis S_{i+1} ( z_i ) at the end of \\textrm{Link}_i \\alpha_i : rotation about the common normal A_{i, i+1} ( x_i ) from the joint axis S_i ( z_{i-1} ) to the next joint axis S_{i+1} ( z_i ) at the end of \\textrm{Link}_i This convention allows the definition of the movement of links around a common joint axis S_i by the screw displacement: [Z_i] = \\begin{bmatrix} cos \\theta_i & -sin \\theta_i & 0 & 0 \\\\ sin \\theta_i & cos \\theta_i & 0 & 0 \\\\ 0 & 0 & 1 & d_i \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} Each of these parameters could be a constant depending on the structure of the robot. Under this convention the dimensions of each link in the serial chain are defined by the screw displacement around the common normal A_{i, i+1} from the joint S_i to S_{i+1} , which is given by: [X_i] = \\begin{bmatrix} 1 & 0 & 0 & a_{i, i+1} \\\\ 0 & cos \\alpha_{i, i+1} & -sin \\alpha_{i, i+1} & 0 \\\\ 0 & sin \\alpha_{i, i+1} & cos \\alpha_{i, i+1} & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} where \\alpha_{i, i+1} and a_{i, i+1} define the physical dimensions of the link in terms of the angle measured around and distance measured along the x-axis.","title":"Four Parameters"},{"location":"sea700/lab5/#jetauto-arm-forward-kinematics","text":"Figure 5.2 JetAuto Arm Links The figure above shows the kinematic link diagram of the JetAuto arm. Let's create the DH parameters table for the first two joints: Joint-0 is the base platform and will be used as the global reference. Joint-1 is the rotation platform of the robotics arm. It's a rotary joint about the joint axis ( \\z_0 ). Therefore, only \\theta_1 (angle between \\x_0 and \\x_1 ) is non-zero. We can assume that Joint-1 is at the same position as Joint-0. Joint-2 is the rotation of the first segment of the robotics arm. It is a rotary joint with a distance, d , offset from Joint-1 (Joint-0). There is a 90\u00b0 change between the Joint-1 (z_1) and Joint-2 axis (z_2). Therefore, \\alpha_2 = 90\u00b0 (angle between z_1 and z_2 about x_2). It will also have a rotation about the Joint-2 axis (z_2), \\theta_2 (angle between x_1 and x_2). Putting this all together yield the following DH parameters table: Table 5.1 JetAuto DH Parameters Table DH# d \u03b8 a \u03b1 1 0 \\theta_1 0 0 2 d 0 0 - \\pi / 2 3 4","title":"JetAuto Arm Forward Kinematics"},{"location":"sea700/lab5/#ros-moveit","text":"ROS MoveIt is a powerful software framework designed for robot motion planning and manipulation within the Robot Operating System (ROS) ecosystem. It provides a robust set of tools and libraries that enable developers to implement complex motion planning algorithms, manage robot kinematics, and execute real-time motion tasks. With features such as collision detection, trajectory optimization, and support for various robotic platforms, MoveIt simplifies the process of programming robots to perform intricate movements. Its flexibility and extensibility make it a popular choice for both research and industrial applications, allowing users to create sophisticated robotic solutions tailored to specific needs. Figure 5.3 ROS MoveIt More details on MoveIt can be found here .","title":"ROS MoveIt"},{"location":"sea700/lab5/#simultaneous-localization-and-mapping-slam","text":"Simultaneous localization and mapping (SLAM) is the computational problem of constructing or updating a map of an unknown environment while simultaneously keeping track of an agent's location within it.Popular approximate solution methods include the particle filter, extended Kalman filter, covariance intersection, and GraphSLAM. SLAM algorithms are based on concepts in computational geometry and computer vision, and are used in robot navigation, robotic mapping and odometry for virtual reality or augmented reality. SLAM algorithms are tailored to the available resources and are not aimed at perfection but at operational compliance. Published approaches are employed in self-driving cars, unmanned aerial vehicles, autonomous underwater vehicles, planetary rovers, newer domestic robots and even inside the human body.","title":"Simultaneous Localization and Mapping (SLAM)"},{"location":"sea700/lab5/#jetauto-robot-arm-control","text":"Before controlling JetAuto's robot arm, let make sure we have all the package necessary installed. We'll also install the GMapping package for the second part of this Lab. Open a terminal and run the following command: sudo apt install ros-melodic-moveit ros-melodic-trac-ik-kinematics-plugin ros-melodic-slam-gmapping ros-melodic-map-server ros-melodic-amcl ros-melodic-move-base ros-melodic-global-planner First, we'll try simulating JetAuto's robot arm in ROS using MoveIt along with a gazebo model. Open terminal and run: roslaunch jetauto_moveit_config demo_gazebo.launch fake_execution:=false This should load a RViz and a Gazebo windows. By provide the false to the fake_execution argument, we'll be able to move the robot arm in the Gazebo model as well. Figure 5.4 JetAuto MoveIt The top left Panel labelled \"Displays\" is the RViz Tool Bar, the bottom left Panel labelled \"MotionPlanning\" is the MoveIt Tool Area, the right Panel is the Simulation view. In the Simulation view, you can use your mouse (rigth click, left click, middle click, and wheel) to adjust the view. Select the \"Planning\" tab in MoveIt and ensure the \"Planning Group\" is \"arm\". Move the model in the Simulation view around to set the joint goal of the arm: The Blue ball control the position of the end effector in 3d space The Red Arrow control the y-axis of the end effector The Green Arrow control the x-axis of the end effector The Blue Arrow control the z-axis of the end effector Remember, once the arm is moved, the axis refer to the end effector's frame of reference. Figure 5.5 JetAuto MoveIt Planning When you set the goal for the robot arm, MoveIt performs inverse kinematics (IK) to determine the configuration for each joint to reach the goal. When calculating the IK, collisions with other parts of the robot are already taken into consideration. If there are any anticipated collisions, they are indicated in red. You can also also perform forward kinematics by scrolling over to the \"Joints\" tab in MoveIt to view and adjust the goal rotation angle of each joint. Figure 5.6 JetAuto MoveIt Planning Joints Once you are ready with the position for the arm to move to, go back to the \"Planning\" tab and click \"Plan & Execute\" . You should see the model move from the current state to the goal state. The gazebo model should move as well. Figure 5.7 JetAuto MoveIt Planning Gazebo View (Optional) If you want, you can go through the demo videos and lessions provided by the manufacturer to gain a better understanding on the robot arm. JetAuto & JetAuto Pro Resources Chapter 15.1 All Lesson Chapter 15.2 Lesson 2 - Demo Video Lesson 3 - Demo Video Lesson 4 Lesson 5 - Demo Video Lesson 6 - Demo Video Lesson 7 - Demo Video Lesson 8 - Demo Video","title":"JetAuto Robot Arm Control"},{"location":"sea700/lab5/#moveit-python-interface","text":"Next, let's use a Python interface to work with MoveIt. Build a new ROS package in your ros_ws workspace and put the following script into your package and call it move_group_python_interface_tutorial.py . This script is from the MoveIt Tutorial using the Panda robot but changed to work with the JetAuto robot. #!/usr/bin/env python import sys import copy import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg from math import pi from std_msgs.msg import String from moveit_commander.conversions import pose_to_list ## END_SUB_TUTORIAL def all_close(goal, actual, tolerance): \"\"\" Convenience method for testing if a list of values are within a tolerance of their counterparts in another list @param: goal A list of floats, a Pose or a PoseStamped @param: actual A list of floats, a Pose or a PoseStamped @param: tolerance A float @returns: bool \"\"\" all_equal = True if type(goal) is list: for index in range(len(goal)): if abs(actual[index] - goal[index]) > tolerance: return False elif type(goal) is geometry_msgs.msg.PoseStamped: return all_close(goal.pose, actual.pose, tolerance) elif type(goal) is geometry_msgs.msg.Pose: return all_close(pose_to_list(goal), pose_to_list(actual), tolerance) return True class MoveGroupPythonIntefaceTutorial(object): \"\"\"MoveGroupPythonIntefaceTutorial\"\"\" def __init__(self): super(MoveGroupPythonIntefaceTutorial, self).__init__() ## BEGIN_SUB_TUTORIAL setup ## ## First initialize `moveit_commander`_ and a `rospy`_ node: moveit_commander.roscpp_initialize(sys.argv) rospy.init_node('move_group_python_interface_tutorial', anonymous=True) ## Instantiate a `RobotCommander`_ object. Provides information such as the robot's ## kinematic model and the robot's current joint states robot = moveit_commander.RobotCommander() ## Instantiate a `PlanningSceneInterface`_ object. This provides a remote interface ## for getting, setting, and updating the robot's internal understanding of the ## surrounding world: scene = moveit_commander.PlanningSceneInterface() ## Instantiate a `MoveGroupCommander`_ object. This object is an interface ## to a planning group (group of joints). In this tutorial the group is the primary ## arm joints in the Panda robot, so we set the group's name to \"panda_arm\". ## If you are using a different robot, change this value to the name of your robot ## arm planning group. ## This interface can be used to plan and execute motions: ##group_name = \"panda_arm\" group_name = \"arm\" move_group = moveit_commander.MoveGroupCommander(group_name) ## Create a `DisplayTrajectory`_ ROS publisher which is used to display ## trajectories in Rviz: display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=20) ## END_SUB_TUTORIAL ## BEGIN_SUB_TUTORIAL basic_info ## ## Getting Basic Information ## ^^^^^^^^^^^^^^^^^^^^^^^^^ # We can get the name of the reference frame for this robot: planning_frame = move_group.get_planning_frame() print \"============ Planning frame: %s\" % planning_frame # We can also print the name of the end-effector link for this group: eef_link = move_group.get_end_effector_link() print \"============ End effector link: %s\" % eef_link # We can get a list of all the groups in the robot: group_names = robot.get_group_names() print \"============ Available Planning Groups:\", robot.get_group_names() # Sometimes for debugging it is useful to print the entire state of the # robot: print \"============ Printing robot state\" print robot.get_current_state() print \"\" ## END_SUB_TUTORIAL # Misc variables self.box_name = '' self.robot = robot self.scene = scene self.move_group = move_group self.display_trajectory_publisher = display_trajectory_publisher self.planning_frame = planning_frame self.eef_link = eef_link self.group_names = group_names def go_to_joint_state(self): # Copy class variables to local variables to make the web tutorials more clear. # In practice, you should use the class variables directly unless you have a good # reason not to. move_group = self.move_group ## BEGIN_SUB_TUTORIAL plan_to_joint_state ## ## Planning to a Joint Goal ## ^^^^^^^^^^^^^^^^^^^^^^^^ ## The Panda's zero configuration is at a `singularity <https://www.quora.com/Robotics-What-is-meant-by-kinematic-singularity>`_ so the first ## thing we want to do is move it to a slightly better configuration. # We can get the joint values from the group and adjust some of the values: joint_goal = move_group.get_current_joint_values() joint_goal[0] = pi/4 joint_goal[1] = pi/4 joint_goal[2] = pi/4 joint_goal[3] = pi/4 # The go command can be called with joint values, poses, or without any # parameters if you have already set the pose or joint target for the group move_group.go(joint_goal, wait=True) # Calling ``stop()`` ensures that there is no residual movement move_group.stop() ## END_SUB_TUTORIAL # For testing: current_joints = move_group.get_current_joint_values() return all_close(joint_goal, current_joints, 0.01) def main(): try: print \"\" print \"----------------------------------------------------------\" print \"Welcome to the MoveIt MoveGroup Python Interface Tutorial\" print \"----------------------------------------------------------\" print \"Press Ctrl-D to exit at any time\" print \"\" print \"============ Press `Enter` to begin the tutorial by setting up the moveit_commander ...\" raw_input() tutorial = MoveGroupPythonIntefaceTutorial() print \"============ Press `Enter` to execute a movement using a joint state goal ...\" raw_input() tutorial.go_to_joint_state() print \"============ Python tutorial demo complete!\" except rospy.ROSInterruptException: return except KeyboardInterrupt: return if __name__ == '__main__': main() To use the Python MoveIt interfaces, we will import the moveit_commander namespace. This namespace provides us with a MoveGroupCommander class, a PlanningSceneInterface class, and a RobotCommander class. More on these below. We also import rospy and some messages that we will use: import sys import copy import rospy import moveit_commander import moveit_msgs.msg import geometry_msgs.msg from math import pi from std_msgs.msg import String from moveit_commander.conversions import pose_to_list First initialize moveit_commander and a rospy node: moveit_commander.roscpp_initialize(sys.argv) rospy.init_node('move_group_python_interface_tutorial', anonymous=True) Instantiate a RobotCommander object. Provides information such as the robot\u2019s kinematic model and the robot\u2019s current joint states robot = moveit_commander.RobotCommander() Instantiate a PlanningSceneInterface object. This provides a remote interface for getting, setting, and updating the robot\u2019s internal understanding of the surrounding world: scene = moveit_commander.PlanningSceneInterface() Instantiate a MoveGroupCommander object. This object is an interface to a planning group (group of joints). In this tutorial the group is the primary arm joints in the JetAuto robot, so we set the group\u2019s name to arm . If you are using a different robot, change this value to the name of your robot arm planning group. This interface can be used to plan and execute motions: group_name = \"arm\" move_group = moveit_commander.MoveGroupCommander(group_name) Create a DisplayTrajectory ROS publisher which is used to display trajectories in Rviz: display_trajectory_publisher = rospy.Publisher('/move_group/display_planned_path', moveit_msgs.msg.DisplayTrajectory, queue_size=20) Getting Basic Information: # We can get the name of the reference frame for this robot: planning_frame = move_group.get_planning_frame() print \"============ Planning frame: %s\" % planning_frame # We can also print the name of the end-effector link for this group: eef_link = move_group.get_end_effector_link() print \"============ End effector link: %s\" % eef_link # We can get a list of all the groups in the robot: group_names = robot.get_group_names() print \"============ Available Planning Groups:\", robot.get_group_names() # Sometimes for debugging it is useful to print the entire state of the # robot: print \"============ Printing robot state\" print robot.get_current_state() print \"\" Planning to a Joint Goal: # We can get the joint values from the group and adjust some of the values: joint_goal = move_group.get_current_joint_values() joint_goal[0] = pi/4 joint_goal[1] = pi/4 joint_goal[2] = pi/4 joint_goal[3] = pi/4 # The go command can be called with joint values, poses, or without any # parameters if you have already set the pose or joint target for the group move_group.go(joint_goal, wait=True) # Calling ``stop()`` ensures that there is no residual movement move_group.stop() Make sure you made the file executeable using chmod +x . Build the package and run the script. You should see the robot arm in RViz and Gazebo move to the new configuration you defined. Lastly, let's try everything out on the physical robot. Copy your workspace to the JetAuto then SSH into the JetAuto. Stop the APP service on the robot: sudo systemctl stop start_app_node.service For the robot arm on the JetAuto to work, we need to start the servo controller service: roslaunch hiwonder_servo_controllers start.launch Next, start MoveIt on the JetAuto. This time, we won't be using Gazebo simulation: roslaunch jetauto_moveit_config demo.launch fake_execution:=false You can now move the robot arm using MoveIt interface as well as the script in your package.","title":"MoveIt Python Interface"},{"location":"sea700/lab5/#jetauto-robot-arm-control-without-moveit","text":"Although MoveIt is a good tool for simulating and moving the robot arm, but you can control the robot arm without using MoveIt. Create another python script in your package with the following: #!/usr/bin/env python3 import rospy import signal from hiwonder_servo_msgs.msg import MultiRawIdPosDur from hiwonder_servo_controllers.bus_servo_control import set_servos from kinematics.search_kinematics_solutions import SearchKinematicsSolutions class MoveServoNode: def __init__(self, name): rospy.init_node(name, anonymous=True) self.z_dis = 0.4 self.y_init = 0.15 signal.signal(signal.SIGINT, self.shutdown) self.joints_pub = rospy.Publisher('servo_controllers/port_id_1/multi_id_pos_dur', MultiRawIdPosDur, queue_size=1) rospy.sleep(0.2) self.search_kinemactis_solutions = SearchKinematicsSolutions() while not rospy.is_shutdown(): try: if rospy.get_param('/hiwonder_servo_manager/running') and rospy.get_param('/joint_states_publisher/running'): break except: rospy.sleep(0.1) self.move_servo() def shutdown(self, signum, frame): rospy.loginfo('shutdown') def move_servo(self): if self.z_dis > 0.43: self.z_dis = 0.43 if self.z_dis < 0.33: self.z_dis = 0.33 res = self.search_kinemactis_solutions.solveIK((0, self.y_init, self.z_dis), 0, -90, 90) if res: joint_data = res[1] rospy.sleep(0.5) set_servos(self.joints_pub, 1500, ((1, 500), (2, joint_data['joint4']), (3, joint_data['joint3']), (4, joint_data['joint2']), (5, joint_data['joint1']))) rospy.sleep(1.8) rospy.signal_shutdown('shutdown') if __name__ == '__main__': MoveServoNode('move_servo') The above code is extracted from example code found in: ~/jetauto_ws/src/jetauto_example/scripts/ It allows you to control the position of the robot arm end effector through inverse kinematics. Controlling the arm's servo directly is NOT recommended as you'll need to manually define collision limits. Run the script and the robot arm should move to the given position.","title":"JetAuto Robot Arm Control (Without MoveIt)"},{"location":"sea700/lab5/#jetauto-slam-simulation","text":"Open a terminal your computer (not the robot) and run the following: roslaunch jetauto_gazebo room_worlds.launch This will open up a JetAuto model in a room populated with furnitures. Figure 5.8 Gazebo Room Press the \"Play\" buttons at the button of the Gazebo simulator. Start the SLAM node. Open a new terminal and start: roslaunch jetauto_slam slam.launch sim:=true You can ignore the \"No module named 'smbus2'\" error because we don't have a joystick connected. Start RViz to visualize the map. Open a new terminal and start: roslaunch jetauto_slam rviz_slam.launch sim:=true If RViz does not load with the proper config, go to File > Open Config and open the follow config file: ~/jetauto_ws/src/jetauto_slam/rviz/without_namespace/gmapping_sim.rviz You can close the default.rviz without saving. Figure 5.8 Gazebo Room Mapping Start the keyboard controller and move the robot around to map the entire room. Once you are satisfied, open a new terminal and navigate to the slam map directory: roscd jetauto_slam/maps We'll save the map as map_01 : rosrun map_server map_saver -f map_01 map:=/map You should see something similar to this output from the terminal: [ INFO] [1729620059.595167203]: Waiting for the map [ INFO] [1729620060.388306846]: Received a 1248 X 384 map @ 0.025 m/pix [ INFO] [1729620060.388618676]: Writing map occupancy data to map_01.pgm [ INFO] [1729620060.400554480, 1407.036000000]: Writing map occupancy data to map_01.yaml [ INFO] [1729620060.400909179, 1407.036000000]: Done Your map has now been saved. Close the SLAM and RViz terminals. You can keep the Gazebo room open. With the map saved, we'll now use it for navigation. Open a new terminal and run: roslaunch jetauto_navigation navigation.launch sim:=true map:=map_01 Open a new terminal and run: roslaunch jetauto_navigation rviz_navigation.launch sim:=true There's an error with the above code that still needs to be solved. We will need to perform the SLAM step using a phsyical robot for now.","title":"JetAuto SLAM (Simulation)"},{"location":"sea700/lab5/#jetauto-slam-physical-robot","text":"Let's try everything out on the physical robot. Connect into the JetAuto using NoMachine or any remote Desktop software and stop the APP service on the robot: sudo systemctl stop start_app_node.service Start the SLAM node and use gmapping as the mapping method: roslaunch jetauto_slam slam.launch slam_methods:=gmapping Open a new terminal and start RViz to visualize the map. Open a new terminal and start: roslaunch jetauto_slam rviz_slam.launch slam_methods:=gmapping Open a new terminal and start the keyboard controller and move the robot around to map the entire room. Once you are satisfied, open a new terminal and navigate to the slam map directory: roscd jetauto_slam/maps We'll save the map as map_01 : rosrun map_server map_saver -f map_01 map:=/jetauto_1/map You should see something similar to this output from the terminal: [ INFO] [1729620059.595167203]: Waiting for the map [ INFO] [1729620060.388306846]: Received a 1248 X 384 map @ 0.025 m/pix [ INFO] [1729620060.388618676]: Writing map occupancy data to map_01.pgm [ INFO] [1729620060.400554480, 1407.036000000]: Writing map occupancy data to map_01.yaml [ INFO] [1729620060.400909179, 1407.036000000]: Done Your map has now been saved. Close the SLAM and RViz terminals. With the map saved, we'll now use it for navigation. Open a new terminal and run: roslaunch jetauto_navigation navigation.launch map:=map_01 Open a new terminal and run: roslaunch jetauto_navigation rviz_navigation.launch Now you can use the 2D Pose Estimate , 2D Nav Goal and Publish Point to help you navigate. 2D Pose Estimate is used to set the initial position of JetAuto, 2D Nav Goal is used to set a target point Publish Point is used to set multiple target points","title":"JetAuto SLAM (Physical Robot)"},{"location":"sea700/lab5/#lab-question","text":"Find the approximate artesian coordinate of the end effector (tip of the gripper) of the JetAuto if: \\theta_1 = 45 \\theta_2 = -30 \\theta_3 = 85 \\theta_4 = 25 You'll need to measure the dimension of each link and construct the foward kinematics using DH parameters. You can perform the calculation by hand or using software (such as Python). You are not allowed to just read the position from ROS. Write a program that will move the robot arm to the position in question 1. Use SLAM to create and save a map of the class room. Afterward, demostrate navigating from one corner of the class to another.","title":"Lab Question"},{"location":"sea700/lab5/#reference","text":"Denavit\u2013Hartenberg parameters ROS Tutorials EECS 106A Labs","title":"Reference"},{"location":"seh500/","text":"SEH500 Lab Manual Documentation of the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) ARMv7-M Architecture Reference Manual ( PDF ) FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors by Joseph Yiu Simulator: Computer System Simulator ARMv7 -> ARMv7 generic Labs: Lab 1 : Setup Lab 2 : Writing in Assembly Lab 3 : Branching in Assembly Lab 4 : Branching, Array and String in Assembly Lab 5 : More Branching, Subroutine, and Stack Lab 6 : Timer Interrupt and C Code Lab 7 : GPIO and Interrupt Lab 8 : GPIO Input and Code Optimization","title":"SEH500 Microprocessors"},{"location":"seh500/#seh500-lab-manual","text":"Documentation of the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) ARMv7-M Architecture Reference Manual ( PDF ) FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors by Joseph Yiu Simulator: Computer System Simulator ARMv7 -> ARMv7 generic Labs: Lab 1 : Setup Lab 2 : Writing in Assembly Lab 3 : Branching in Assembly Lab 4 : Branching, Array and String in Assembly Lab 5 : More Branching, Subroutine, and Stack Lab 6 : Timer Interrupt and C Code Lab 7 : GPIO and Interrupt Lab 8 : GPIO Input and Code Optimization","title":"SEH500 Lab Manual"},{"location":"seh500/lab1/","text":"Lab 1 : Setup Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction The Freedom-K64F and Freedom-K66F are both low-cost development platforms using the NXP Kinetis series of microcontrollers based on the ARM Cortex-M4 processor. Features K64F K66F Microcontroller MK64FN1M0VLL12 MK66FN2M0VMD18 Speed 120 MHz 180 MHz RAM 256 kB 256 kB External Memory N/A microSD socket Connectivity USB, Ethernet, Add-on Bluetooth USB, Ethernet, Add-on Bluetooth Audio N/A Audio codec and Jacks Sensors Accelerometer and Magnetometer (FXOS8700CQ) No longer populated! Accelerometer and Magnetometer (FXOS8700CQ) Gyroscope (FXAS21002) Debug OpenSDAv2 Virtual Serial Port OpenSDAv2 Virtual Serial Port User Components RGB LED RGB LED Two user push buttons Preparation Read over the lab manual for this lab. Acquire the Freedom microcontroller board and install the necessary IDE as described in the lab manual. Documentation of the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) ARMv7-M Architecture Reference Manual ( PDF ) FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors by Joseph Yiu Procedures Firmware Update If you are using the Freedom-K64F, you might need to update its firmware before using it with Windows 10. Even if you are not using Windows 10, updating the firmware might be a good idea. If you are using Windows OS, follow step 1-4 to disable the storage service on the Getting Started with the FRDM-K64F BUT DO NOT FOLLOW ANY OTHER STEPS. Unplug the Freedom board then hold down the \"RESET SW1\" button as you plug the board into your computer to enter bootloader mode. Figure 1.1 Start in Bootloader Mode Once plugged in, if you see \"BOOTLOADER\", then we need to update the firmware. If you see \"MAINTENANCE\", then you most likely have the latest firmware and don't need to perform an update. Once in bootloader mode, copy the bootloader files below into the \"BOOTLOADER\" drive. The board should load the .bin file then restart into \"MAINTENANCE\". If the board does not restart, manually restart it by unplugging power. If \"BOOTLOADER\" directory is still showing, repeat the process. K64F Bootloader: 0244_k20dx_bootloader_update_0x5000.bin for updating the OpenSDA bootloader K66F Bootloader: 0244_k20dx_bootloader_update_0x8000.bin for updating the OpenSDA bootloader (Reference: DAPLink bootloader update ) If the bootloader drive is not showing, try updating the bootloader using a non-Windows 10 computer. If it is still not showing up, the board might be in a bricked state. In this case, an external device must be used to flash a new bootloader. Follow the instructions here . Once you see the \"MAINTENANCE\" drive. Load the firmware application back onto the board using the same methods as above. K64F Firmware Application: k20dx_frdmk64f_if_crc_legacy_0x5000 for loading the CMSIS-DAP application back onto the board K66F Firmware Application: k20dx_frdmk66f_if_crc for loading the CMSIS-DAP application back onto the board (Reference: OpenSDA Serial and Debug Adapter ) *** Later in the Lab, if you get an \"0 SWD device available\" error, this is usually due to a conflict with the firmware. To resoluve this, load the Segger Jlink OpenSDA Firmware on your board then run debug using Segger JLink as the debugger. Once a program can be uploaded onto your board, you may switch back to the DAPLink firmware. Install IDE Install the MCUXpresso IDE from NXP (account creation required) or using Seneca MyApps . NOTE: If the board is not recognized by Windows, download the latest driver for Windows. Links to other drivers such as P&E Micro and Segger Jlink can be found here: OpenSDA Serial and Debug Adapter . Figure 1.2 Seneca MyApps Select an appropriate location to save your workspace. It must be a directory to which you have \"write\" permission. Figure 1.3 Select Workspace Directory Install SDK Once MCUXpresso opens, click \"Download and Install SDK\" from the quick-start menu. Figure 1.4 Download and Install SDK Filter for \"K64\" or \"K66\" depending on the version of the board you are using then install the SDK. Figure 1.5 Filter SDK Figure 1.6 Select SDK Figure 1.7 Install SDK Import SDK Example After downloading and installing the SDK, close the welcome screen. At the bottom left Quickstart Panel, click \"Import SDK example(s)...\". Figure 1.8 Install SDK Select the appropriate example library. Figure 1.9 Select Example Library Find the \"hello_world\" example from \"demo_apps\". Figure 1.10 Select Hello World Demo Ensure \"SDK Debug Console\" under Project Options is selected as UART then click \"Next\". Figure 1.11 SDK Debug Console UART In the project Advanced Settings page, ensure to CLEAR the \"Redirect SDK PRINTF to C library printf\" option then click \"Finish\". Figure 1.12 Clear Redirect SDK PRINTF to C library printf Code, Build and Debug Project By now, you should be able to see a familiar interface with a project tree on the left and a code in the middle. Take a look at the code and get an idea of what it is performing. Afterward, click \"Build\" at the lower left Quickstart Panel to compile the code. Figure 1.13 Demo Project Code Figure 1.14 Build Project Once the project is built, click \"Debug\" to run the project in debug mode. Figure 1.15 Run in Debug Mode The IDE should automatically probe for and connect to the target microcontroller board. Click \"OK\". Figure 1.16 Connect to target Serial Terminal Open a Serial terminal in the IDE by clicking on the \"Terminal\" tab beside the \"Console\" tab at the bottom of the screen. Select the appropriate COM port that the microcontroller board is connected to (check the device manager of your computer). Ensure the settings are 115200 baud rate with 8-bit data size, no parity bit, and 1 stop bit. Figure 1.17 Start a Serial Terminal Once the terminal is connected, press \"Resume\" from the debug menu and you should see \"Hello World\" in the serial terminal. Figure 1.18 Press Resume Figure 1.19 Hello World in Serial Terminal View Assembly Code Lastly, let's take a look at the assembly language code. From the project tree on the left, find the \"Debug\" directory. Within the directory, right-click on the .axf file then click Binary Utilities > Disassemble. Figure 1.20 View Disassembled Code A new .dis file should be created. Open the file to see the disassembled code. Figure 1.21 Disassembled Code Another way to see the assembly code is to view it live during execution. To do that, at the top menu, go to \"Windows > Show View > Other\" and then type in Disassembly. View the Registers Value and Memory Data during Debug This step can only be done with a microcontroller board running during debugging. To view the register values during debugging, select the \"Registers\" tab beside the Project Explorer tab on the left-hand side. You should now see the register from r0-r12, sp, lr, pc, ... To view memory data, at the bottom right, select the \"Memory\" tab. Click the plus (+) symbol then type in the memory address you want to view. Usually, the memory area you want to view will be somewhere between 0x20000000 to 0x3FFFFFFF. Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Refer to the Memory map shown in class or from Figure 4.18 of Yiu, what is the starting address and ending address of the instruction code region? In the hello_world.c example, what is the instruction address of the first line of code that it halts on once you start debugging? Note: The instruction is at a hex address within the instruction region. You can find it in the disabled code or the Disassembly view during debug. Hint: The main function starts at address 0x00000924. Look at the register tab, what is the value of the Program Counter (PC) when you first start debugging? Refer back to the memory map in question 1 and see if it corresponds to the proper memory region. What is the value of the Stack Pointer (SP)? Refer back to the memory map in question 1 and see if it corresponds to the proper memory region. Change the C-code to also display your name and student number within the print statement. Copy your main function onto blackboard. Run your modified code and view the result using the serial terminal. Your name and student number should now be displayed in the serial terminal. Take a screenshot of the printout and place it onto Blackboard.","title":"Lab 1 : Setup"},{"location":"seh500/lab1/#lab-1-setup","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 1 : Setup"},{"location":"seh500/lab1/#introduction","text":"The Freedom-K64F and Freedom-K66F are both low-cost development platforms using the NXP Kinetis series of microcontrollers based on the ARM Cortex-M4 processor. Features K64F K66F Microcontroller MK64FN1M0VLL12 MK66FN2M0VMD18 Speed 120 MHz 180 MHz RAM 256 kB 256 kB External Memory N/A microSD socket Connectivity USB, Ethernet, Add-on Bluetooth USB, Ethernet, Add-on Bluetooth Audio N/A Audio codec and Jacks Sensors Accelerometer and Magnetometer (FXOS8700CQ) No longer populated! Accelerometer and Magnetometer (FXOS8700CQ) Gyroscope (FXAS21002) Debug OpenSDAv2 Virtual Serial Port OpenSDAv2 Virtual Serial Port User Components RGB LED RGB LED Two user push buttons","title":"Introduction"},{"location":"seh500/lab1/#preparation","text":"Read over the lab manual for this lab. Acquire the Freedom microcontroller board and install the necessary IDE as described in the lab manual. Documentation of the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) ARMv7-M Architecture Reference Manual ( PDF ) FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors by Joseph Yiu","title":"Preparation"},{"location":"seh500/lab1/#procedures","text":"","title":"Procedures"},{"location":"seh500/lab1/#firmware-update","text":"If you are using the Freedom-K64F, you might need to update its firmware before using it with Windows 10. Even if you are not using Windows 10, updating the firmware might be a good idea. If you are using Windows OS, follow step 1-4 to disable the storage service on the Getting Started with the FRDM-K64F BUT DO NOT FOLLOW ANY OTHER STEPS. Unplug the Freedom board then hold down the \"RESET SW1\" button as you plug the board into your computer to enter bootloader mode. Figure 1.1 Start in Bootloader Mode Once plugged in, if you see \"BOOTLOADER\", then we need to update the firmware. If you see \"MAINTENANCE\", then you most likely have the latest firmware and don't need to perform an update. Once in bootloader mode, copy the bootloader files below into the \"BOOTLOADER\" drive. The board should load the .bin file then restart into \"MAINTENANCE\". If the board does not restart, manually restart it by unplugging power. If \"BOOTLOADER\" directory is still showing, repeat the process. K64F Bootloader: 0244_k20dx_bootloader_update_0x5000.bin for updating the OpenSDA bootloader K66F Bootloader: 0244_k20dx_bootloader_update_0x8000.bin for updating the OpenSDA bootloader (Reference: DAPLink bootloader update ) If the bootloader drive is not showing, try updating the bootloader using a non-Windows 10 computer. If it is still not showing up, the board might be in a bricked state. In this case, an external device must be used to flash a new bootloader. Follow the instructions here . Once you see the \"MAINTENANCE\" drive. Load the firmware application back onto the board using the same methods as above. K64F Firmware Application: k20dx_frdmk64f_if_crc_legacy_0x5000 for loading the CMSIS-DAP application back onto the board K66F Firmware Application: k20dx_frdmk66f_if_crc for loading the CMSIS-DAP application back onto the board (Reference: OpenSDA Serial and Debug Adapter ) *** Later in the Lab, if you get an \"0 SWD device available\" error, this is usually due to a conflict with the firmware. To resoluve this, load the Segger Jlink OpenSDA Firmware on your board then run debug using Segger JLink as the debugger. Once a program can be uploaded onto your board, you may switch back to the DAPLink firmware.","title":"Firmware Update"},{"location":"seh500/lab1/#install-ide","text":"Install the MCUXpresso IDE from NXP (account creation required) or using Seneca MyApps . NOTE: If the board is not recognized by Windows, download the latest driver for Windows. Links to other drivers such as P&E Micro and Segger Jlink can be found here: OpenSDA Serial and Debug Adapter . Figure 1.2 Seneca MyApps Select an appropriate location to save your workspace. It must be a directory to which you have \"write\" permission. Figure 1.3 Select Workspace Directory","title":"Install IDE"},{"location":"seh500/lab1/#install-sdk","text":"Once MCUXpresso opens, click \"Download and Install SDK\" from the quick-start menu. Figure 1.4 Download and Install SDK Filter for \"K64\" or \"K66\" depending on the version of the board you are using then install the SDK. Figure 1.5 Filter SDK Figure 1.6 Select SDK Figure 1.7 Install SDK","title":"Install SDK"},{"location":"seh500/lab1/#import-sdk-example","text":"After downloading and installing the SDK, close the welcome screen. At the bottom left Quickstart Panel, click \"Import SDK example(s)...\". Figure 1.8 Install SDK Select the appropriate example library. Figure 1.9 Select Example Library Find the \"hello_world\" example from \"demo_apps\". Figure 1.10 Select Hello World Demo Ensure \"SDK Debug Console\" under Project Options is selected as UART then click \"Next\". Figure 1.11 SDK Debug Console UART In the project Advanced Settings page, ensure to CLEAR the \"Redirect SDK PRINTF to C library printf\" option then click \"Finish\". Figure 1.12 Clear Redirect SDK PRINTF to C library printf","title":"Import SDK Example"},{"location":"seh500/lab1/#code-build-and-debug-project","text":"By now, you should be able to see a familiar interface with a project tree on the left and a code in the middle. Take a look at the code and get an idea of what it is performing. Afterward, click \"Build\" at the lower left Quickstart Panel to compile the code. Figure 1.13 Demo Project Code Figure 1.14 Build Project Once the project is built, click \"Debug\" to run the project in debug mode. Figure 1.15 Run in Debug Mode The IDE should automatically probe for and connect to the target microcontroller board. Click \"OK\". Figure 1.16 Connect to target","title":"Code, Build and Debug Project"},{"location":"seh500/lab1/#serial-terminal","text":"Open a Serial terminal in the IDE by clicking on the \"Terminal\" tab beside the \"Console\" tab at the bottom of the screen. Select the appropriate COM port that the microcontroller board is connected to (check the device manager of your computer). Ensure the settings are 115200 baud rate with 8-bit data size, no parity bit, and 1 stop bit. Figure 1.17 Start a Serial Terminal Once the terminal is connected, press \"Resume\" from the debug menu and you should see \"Hello World\" in the serial terminal. Figure 1.18 Press Resume Figure 1.19 Hello World in Serial Terminal","title":"Serial Terminal"},{"location":"seh500/lab1/#view-assembly-code","text":"Lastly, let's take a look at the assembly language code. From the project tree on the left, find the \"Debug\" directory. Within the directory, right-click on the .axf file then click Binary Utilities > Disassemble. Figure 1.20 View Disassembled Code A new .dis file should be created. Open the file to see the disassembled code. Figure 1.21 Disassembled Code Another way to see the assembly code is to view it live during execution. To do that, at the top menu, go to \"Windows > Show View > Other\" and then type in Disassembly.","title":"View Assembly Code"},{"location":"seh500/lab1/#view-the-registers-value-and-memory-data-during-debug","text":"This step can only be done with a microcontroller board running during debugging. To view the register values during debugging, select the \"Registers\" tab beside the Project Explorer tab on the left-hand side. You should now see the register from r0-r12, sp, lr, pc, ... To view memory data, at the bottom right, select the \"Memory\" tab. Click the plus (+) symbol then type in the memory address you want to view. Usually, the memory area you want to view will be somewhere between 0x20000000 to 0x3FFFFFFF.","title":"View the Registers Value and Memory Data during Debug"},{"location":"seh500/lab1/#lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Refer to the Memory map shown in class or from Figure 4.18 of Yiu, what is the starting address and ending address of the instruction code region? In the hello_world.c example, what is the instruction address of the first line of code that it halts on once you start debugging? Note: The instruction is at a hex address within the instruction region. You can find it in the disabled code or the Disassembly view during debug. Hint: The main function starts at address 0x00000924. Look at the register tab, what is the value of the Program Counter (PC) when you first start debugging? Refer back to the memory map in question 1 and see if it corresponds to the proper memory region. What is the value of the Stack Pointer (SP)? Refer back to the memory map in question 1 and see if it corresponds to the proper memory region. Change the C-code to also display your name and student number within the print statement. Copy your main function onto blackboard. Run your modified code and view the result using the serial terminal. Your name and student number should now be displayed in the serial terminal. Take a screenshot of the printout and place it onto Blackboard.","title":"Lab Questions"},{"location":"seh500/lab2/","text":"Lab 2 : Writing in Assembly Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction Cortex-M4 Memory Map The 4GB address space of the Cortex\u00ae-M processors is partitioned into a number of memory regions (Figure 2.1). The partitioning is based on typical usages so that different areas are designed to be used primarily for: Program code accesses (e.g., CODE region) Data accesses (e.g., SRAM region) Peripherals (e.g., Peripheral region) Processor\u2019s internal control and debug components (e.g., Private Peripheral Bus) The architecture also allows high flexibility to allow memory regions to be used for other purposes. For example, programs can be executed from the CODE as well as the SRAM region, and a microcontroller can also integrate SRAM blocks in CODE region. Figure 2.1 Memory map In practice, many microcontroller devices only use a small portion of each region for program flash, SRAM, and peripherals. Some of the regions can be unused. Different microcontrollers have different memory sizes and peripheral address locations. This information is usually outlined in user manuals or datasheets from microcontroller vendors. Cortex-M4 Registers The register bank in the Cortex-M3 and Cortex-M4 processors has 16 registers. Thirteen of them are general-purpose 32-bit registers, and the other three have special uses, as can be seen in Figure 2.2. Figure 2.2 Registers in the register bank R0 \u2013 R12 Registers R0 to R12 are general-purpose registers. The first eight (R0 \u2013 R7) are also called low registers. Due to the limited available space in the instruction set, many 16-bit instructions can only access the low registers. The high registers (R8 \u2013 R12) can be used with 32-bit instructions, and a few with 16-bit instructions, like MOV (move). The initial values of R0 to R12 are undefined. R13, stack pointer (SP) R13 is the Stack Pointer. It is used for accessing the stack memory via PUSH and POP operations. R14, link register (LR) R14 is also called the Link Register (LR). This is used for holding the return address when calling a function or subroutine. At the end of the function or subroutine, the program control can return to the calling program and resume by loading the value of LR into the Program Counter (PC). When a function or subroutine call is made, the value of LR is updated automatically. If a function needs to call another function or subroutine, it needs to save the value of LR in the stack first. Otherwise, the current value in LR will be lost when the function call is made. R15, program counter (PC) R15 is the Program Counter (PC). It is readable and writeable: a read returns the current instruction address plus 4 (this is due to the pipeline nature of the design, and compatibility requirement with the ARM7TDMI\u2122 processor). Writing to PC (e.g., using data transfer/processing instructions) causes a branch operation. Program status registers The Program Status Register is composed of three status registers: Application PSR (APSR) Execution PSR (EPSR) Interrupt PSR (IPSR) These three registers can be accessed as one combined register, referred to as xPSR in some documentation. In the ARM assembler, when accessing xPSR (Figure 2.3), the symbol PSR is used. Figure 2.3 Combined xPSR The main 4 status bits of interest are: N : Negative flag - set to 1 when the result of an operation is negative Z : Zero flag - set to 1 when the result of an operation is zero C : Carry (or NOT borrow) flag - set to 1 if the addition produces a carry - set to 0 if the subtraction produces a borrow V : Overflow flag - set to 1 if the result of an operation is outside the range of a signed 32-bit integer Reference: Yiu, Ch 4 Preparation Have a look at the following instruction set and ensure you understand how to lookup an instruction. Assembly Instruction Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) Procedures Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. Figure 2.3 New Project In the new project configuration, rename the project then leave all other settings as default. Even though we will be programming in assembly language, we'll still like the IDE to use the SDK template to set up the Freedom board so we don't have to bother with the startup configuration (ie. vector table, ISR, stack address, heap address, etc.) Figure 2.4 New Project Name and Settings Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". Figure 2.5 Rename File Replace the code within the file with the following: @ add directives .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .text @ put code into the text section of memory .global main @ declare main as a global variable .type main, %function @ set main to function type main: @ start of main code with an label ldr r0, =0x20000000 @ load 0x20000000 to R0 mov r1, #8 @ move #8 to R1 add r1, r1, #4 @ add #4 to R1 and write to R1 str r1, [r0] @ store value of R1 to address of R0 stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Your code should now look like this. Figure 2.6 Assembly Code Build and run the code using the debug option. Open both the register view and the memory view and set to address 0x20000000. Figure 2.7 Register and Memory View Step through (using Step Into or Step Over) the code and pay attention to the changes in the registers (register view) and memory (memory monitor). Step until you reach the stop label. Your code should not go any further as it will loop between the nop and b instructions. You can also see the program counter jumping back and forward. Next, re-run the code but this time, expand the program status register and notice the flags that change especially after an arithmetics instruction. Figure 2.8 Program Status Register Flags Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Referring to the Cortex-M4 technical manual, how many \"Add\" instructions can you find in the manual and what are they? Write the instruction that loads the address 0x20000010 into register R0. Write a functional assembly code that performs Exercise #2 from the module 3 lecture: Perform the calculation: A + B \u2013 C = D. Use 0x20000010 for variable A = first 2 digits of your student # Use 0x20000014 for variable B = next 2 digits of your student # Use 0x20000018 for variable C = next 2 digits of your student # Use 0x2000001C for variable D = 0 We will not be using variables at this point. Run the code and verify that your answer is correct. Paste your assembly code into Blackboard along with a screenshot of the memory view showing the content of the four memory addresses. Complete the code as necessary (ie. add all the necessary directives) and run it on your processor board. Comment out any line(s) that are invalid with \"@\" and explain why in the comment. Answer each question (indicated with ?) directly in the comment of your code and paste your code into Blackboard for submission. mov R2, # @ use the first 2 digits of your student ID mov R3, # @ use the last 2 digits of your student ID @Other examples to move immediate values mov R5, #0x1234 @ R5 = ? movt R5, #0x8765 @ R5 = ? movt R5, #0x5678 @ R5 = ? movw R6, #0x12345678 @ R6 = ? movw R5, #0x5678 @ R6 = ? ldr R7, =0x87654321 @ R7 = ? add R1, R2, R3 @ R1 = ? movt R3, #0xFFFF @ R3 = ? adds R1, R2, R3 @ R1 = ? @ What are the PSR (N, Z, C, V) flags now? subs R1, R2, R3 @ R1 = ? @ How are the PSR flags affected? mov R4, #0xFFFFFFFF @ R4 = ? add R1, R2, R4 @ R1 = ? @ How are the PSR flags affected? adds R1, R2, R4 @ R1 = ? @ What happened to the PSR flags now? mov R2, #0x00000002 @ R2 = ? adds R1, R2, R4 @ R1 = ? @ again, what happened to the PSR flags? mov R2, #0x00000001 @ R2 = ? mov R3, #0x00000002 @ R3 = ? adds R1, R2, R3 @ R1 = ? @ After adding some small numbers and checking the PSR flags again, what happened? @ Add numbers that will create an overflow mov R2, #0x7FFFFFFF @ R2 = ? mov R3, #0x7FFFFFFF @ R3 = ? adds R1, R2, R3 @ R1 = ? @ Check and see what happened to the PSR flags. Reference [1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Lab 2 : Writing in Assembly"},{"location":"seh500/lab2/#lab-2-writing-in-assembly","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 2 : Writing in Assembly"},{"location":"seh500/lab2/#introduction","text":"","title":"Introduction"},{"location":"seh500/lab2/#cortex-m4-memory-map","text":"The 4GB address space of the Cortex\u00ae-M processors is partitioned into a number of memory regions (Figure 2.1). The partitioning is based on typical usages so that different areas are designed to be used primarily for: Program code accesses (e.g., CODE region) Data accesses (e.g., SRAM region) Peripherals (e.g., Peripheral region) Processor\u2019s internal control and debug components (e.g., Private Peripheral Bus) The architecture also allows high flexibility to allow memory regions to be used for other purposes. For example, programs can be executed from the CODE as well as the SRAM region, and a microcontroller can also integrate SRAM blocks in CODE region. Figure 2.1 Memory map In practice, many microcontroller devices only use a small portion of each region for program flash, SRAM, and peripherals. Some of the regions can be unused. Different microcontrollers have different memory sizes and peripheral address locations. This information is usually outlined in user manuals or datasheets from microcontroller vendors.","title":"Cortex-M4 Memory Map"},{"location":"seh500/lab2/#cortex-m4-registers","text":"The register bank in the Cortex-M3 and Cortex-M4 processors has 16 registers. Thirteen of them are general-purpose 32-bit registers, and the other three have special uses, as can be seen in Figure 2.2. Figure 2.2 Registers in the register bank","title":"Cortex-M4 Registers"},{"location":"seh500/lab2/#r0-r12","text":"Registers R0 to R12 are general-purpose registers. The first eight (R0 \u2013 R7) are also called low registers. Due to the limited available space in the instruction set, many 16-bit instructions can only access the low registers. The high registers (R8 \u2013 R12) can be used with 32-bit instructions, and a few with 16-bit instructions, like MOV (move). The initial values of R0 to R12 are undefined.","title":"R0 \u2013 R12"},{"location":"seh500/lab2/#r13-stack-pointer-sp","text":"R13 is the Stack Pointer. It is used for accessing the stack memory via PUSH and POP operations.","title":"R13, stack pointer (SP)"},{"location":"seh500/lab2/#r14-link-register-lr","text":"R14 is also called the Link Register (LR). This is used for holding the return address when calling a function or subroutine. At the end of the function or subroutine, the program control can return to the calling program and resume by loading the value of LR into the Program Counter (PC). When a function or subroutine call is made, the value of LR is updated automatically. If a function needs to call another function or subroutine, it needs to save the value of LR in the stack first. Otherwise, the current value in LR will be lost when the function call is made.","title":"R14, link register (LR)"},{"location":"seh500/lab2/#r15-program-counter-pc","text":"R15 is the Program Counter (PC). It is readable and writeable: a read returns the current instruction address plus 4 (this is due to the pipeline nature of the design, and compatibility requirement with the ARM7TDMI\u2122 processor). Writing to PC (e.g., using data transfer/processing instructions) causes a branch operation.","title":"R15, program counter (PC)"},{"location":"seh500/lab2/#program-status-registers","text":"The Program Status Register is composed of three status registers: Application PSR (APSR) Execution PSR (EPSR) Interrupt PSR (IPSR) These three registers can be accessed as one combined register, referred to as xPSR in some documentation. In the ARM assembler, when accessing xPSR (Figure 2.3), the symbol PSR is used. Figure 2.3 Combined xPSR The main 4 status bits of interest are: N : Negative flag - set to 1 when the result of an operation is negative Z : Zero flag - set to 1 when the result of an operation is zero C : Carry (or NOT borrow) flag - set to 1 if the addition produces a carry - set to 0 if the subtraction produces a borrow V : Overflow flag - set to 1 if the result of an operation is outside the range of a signed 32-bit integer Reference: Yiu, Ch 4","title":"Program status registers"},{"location":"seh500/lab2/#preparation","text":"Have a look at the following instruction set and ensure you understand how to lookup an instruction.","title":"Preparation"},{"location":"seh500/lab2/#assembly-instruction","text":"Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Assembly Instruction"},{"location":"seh500/lab2/#procedures","text":"Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. Figure 2.3 New Project In the new project configuration, rename the project then leave all other settings as default. Even though we will be programming in assembly language, we'll still like the IDE to use the SDK template to set up the Freedom board so we don't have to bother with the startup configuration (ie. vector table, ISR, stack address, heap address, etc.) Figure 2.4 New Project Name and Settings Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". Figure 2.5 Rename File Replace the code within the file with the following: @ add directives .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .text @ put code into the text section of memory .global main @ declare main as a global variable .type main, %function @ set main to function type main: @ start of main code with an label ldr r0, =0x20000000 @ load 0x20000000 to R0 mov r1, #8 @ move #8 to R1 add r1, r1, #4 @ add #4 to R1 and write to R1 str r1, [r0] @ store value of R1 to address of R0 stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Your code should now look like this. Figure 2.6 Assembly Code Build and run the code using the debug option. Open both the register view and the memory view and set to address 0x20000000. Figure 2.7 Register and Memory View Step through (using Step Into or Step Over) the code and pay attention to the changes in the registers (register view) and memory (memory monitor). Step until you reach the stop label. Your code should not go any further as it will loop between the nop and b instructions. You can also see the program counter jumping back and forward. Next, re-run the code but this time, expand the program status register and notice the flags that change especially after an arithmetics instruction. Figure 2.8 Program Status Register Flags","title":"Procedures"},{"location":"seh500/lab2/#lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Referring to the Cortex-M4 technical manual, how many \"Add\" instructions can you find in the manual and what are they? Write the instruction that loads the address 0x20000010 into register R0. Write a functional assembly code that performs Exercise #2 from the module 3 lecture: Perform the calculation: A + B \u2013 C = D. Use 0x20000010 for variable A = first 2 digits of your student # Use 0x20000014 for variable B = next 2 digits of your student # Use 0x20000018 for variable C = next 2 digits of your student # Use 0x2000001C for variable D = 0 We will not be using variables at this point. Run the code and verify that your answer is correct. Paste your assembly code into Blackboard along with a screenshot of the memory view showing the content of the four memory addresses. Complete the code as necessary (ie. add all the necessary directives) and run it on your processor board. Comment out any line(s) that are invalid with \"@\" and explain why in the comment. Answer each question (indicated with ?) directly in the comment of your code and paste your code into Blackboard for submission. mov R2, # @ use the first 2 digits of your student ID mov R3, # @ use the last 2 digits of your student ID @Other examples to move immediate values mov R5, #0x1234 @ R5 = ? movt R5, #0x8765 @ R5 = ? movt R5, #0x5678 @ R5 = ? movw R6, #0x12345678 @ R6 = ? movw R5, #0x5678 @ R6 = ? ldr R7, =0x87654321 @ R7 = ? add R1, R2, R3 @ R1 = ? movt R3, #0xFFFF @ R3 = ? adds R1, R2, R3 @ R1 = ? @ What are the PSR (N, Z, C, V) flags now? subs R1, R2, R3 @ R1 = ? @ How are the PSR flags affected? mov R4, #0xFFFFFFFF @ R4 = ? add R1, R2, R4 @ R1 = ? @ How are the PSR flags affected? adds R1, R2, R4 @ R1 = ? @ What happened to the PSR flags now? mov R2, #0x00000002 @ R2 = ? adds R1, R2, R4 @ R1 = ? @ again, what happened to the PSR flags? mov R2, #0x00000001 @ R2 = ? mov R3, #0x00000002 @ R3 = ? adds R1, R2, R3 @ R1 = ? @ After adding some small numbers and checking the PSR flags again, what happened? @ Add numbers that will create an overflow mov R2, #0x7FFFFFFF @ R2 = ? mov R3, #0x7FFFFFFF @ R3 = ? adds R1, R2, R3 @ R1 = ? @ Check and see what happened to the PSR flags.","title":"Lab Questions"},{"location":"seh500/lab2/#reference","text":"[1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Reference"},{"location":"seh500/lab3/","text":"Lab 3 : Branching in Assembly Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) As you've seen in the previous lab, the ARM processor has a Program Status Register with 4 flags that might get set or clear depending on the previous ALU operation. N : Negative flag - set to 1 when the result of an operation is negative Z : Zero flag - set to 1 when the result of an operation is zero C : Carry (or NOT borrow) flag set to 1 if the addition produces a carry set to 0 if the subtraction produces a borrow V : Overflow flag - set to 1 if the result of an operation is outside the range of a signed 32-bit integer These flags can then be used for decision-making within the program. Below are instructions that might set or clear the status flag. Arithmetic Instructions Instruction Mnemonic Meaning Addition ADD R0, R1, R2 R0 = R1 + R2 Addition ADDS R0, R1, R2 R0 = R1 + R2, and FLAGs are updated Subtraction SUB R1, R2, R3 R1 = R2 - R3 Subtraction SUBS R1, R2, R3 R1 = R2 - R3, and FLAGs are updated Subtraction SUBS R7, R6, #20 R7 = R6 - 20, and sets the FLAGs on the result Reverse Subtraction RSB R4, R4, #120 R4 = 120 - R4 Multiply MUL R0, R1, R2 R0 = R1 * R2 Division SDIV R0, R2, R4 Signed divide, R0 = R2/R4 Division UDIV R8, R8, R1 Unsigned divide, R8 = R8/R1 Move Instructions Mnemonic Meaning MOV R1, #0xFA05 Write value of 0xFA05 to R1, flags are not updated MOVS R11, #0x000B Write value of 0x000B to R11, flags get updated MOVS R10, R12 Write value in R12 to R10, flags get updated MOV R3, #23 Write value of 23 to R3 MOV R8, SP Write value of stack pointer to R8 MVNS R2, #0xF Write value of 0xFFFFFFF0 (bitwise inverse of 0xF), to the R2 and update flags. Logical Operation Instructions Mnemonic Meaning AND R9, R2, R1 R9 = R2 AND R1 AND R9, R2, #0xFF00 R9 = R2 AND #0xFF00 ANDS R9, R8, #0x19 with flags update ORR R9, R2, R1 R9 = R2 OR R1 ORR R9, R2, #0xFF00 ORREQ R2, R0, R5 EOR R7, R11, R10 R7 = R11 XOR R10 EORS R7, R11, #0x18181818 with flags update BIC R0, R1, #0xab R0 = R1 AND (NOT(#0xab)) ORN R7, R11, R14, ROR #4 R7 = R11 OR (NOT(R14 ROR #4)) ORNS R7, R11, R14, ROR #2 with flags update Shift Instructions Mnemonic Meaning LSL R4, R5, #2 Logical shift left by 2 bits LSR R4, R5, #6 Logical shift right by 6 bits LSLS R1, R2, #3 Logical shift left by 3 bits with flags update ROR R4, R5, R6 Rotate right by the value in the bottom byte of R6 RRX R4, R5 Rotate right with extend (one bit only). Branching Instructions Mnemonic Meaning B <label> Branch B{cond} <label> Branch with condition BL <label> Branch with Link BL{cond} <label> Branch with Link with condition BX <Rm> Branch to register value BX{cond} <Rm> Branch to register value with condition BLX <Rm> Branch with Link to register value BLX{cond} <Rm> Branch with Link to register value with condition See below for conditions that are set by a compare, usually by using the CMP, instruction. The CMP Rm, Rn instruction operates \"Rm - Rn\" for the sole purpose of setting the condition flags. Unlike a subtraction operation, the result of the compare operation is discarded. Branching Conditions The APSR contains the following condition flags: N : Set to 1 when the result of the operation was negative, cleared to 0 otherwise. Z : Set to 1 when the result of the operation was zero, cleared to 0 otherwise. C : Set to 1 when the operation resulted in a carry, cleared to 0 otherwise. V : Set to 1 when the operation caused overflow, cleared to 0 otherwise. Depending on how you want branching to be done, the condition suffix can be added to the branching instruction to form a conditional branching instruction. Suffix {cond} Flags Meaning EQ Z = 1 Equal NE Z = 0 Not equal CS or HS C = 1 Higher or same, unsigned CC or LO C = 0 Lower, unsigned MI N = 1 Negative PL N = 0 Positive or zero VS V = 1 Overflow VC V = 0 No overflow HI C = 1 and Z = 0 Higher, unsigned LS C = 0 or Z = 1 Lower or same, unsigned GE N = V Greater than or equal, signed LT N != V Less than, signed GT Z = 0 and N = V Greater than, signed LE Z = 1 and N != V Less than or equal, signed AL Can have any value Always. This is the default when no suffix is specified. Variables When defining a variable, the compiler assigns an address in memory with sufficient size to store the data. All variables are defined in the .data section of the code that should be placed above the .text section. Some possible data types are: .byte : 1 byte .short : 2 bytes .word : 4 bytes .quad : 8 bytes .octa : 16 bytes Procedures Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, rename the project then leave all other settings as default. Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". Replace the code within the file with the following: .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .global main @ declare main as a global variable .type main, %function @ set main to function type main: @ start of main code with a label mov r0, # @ x = <use the last digit of your student ID + 1> mul r1, r0, r0 @ r1 = x^2, @ record r1 and psr value mov r4, #5 muls r1, r1, r4 @ r1 = 5x^2, @ record r1 and psr value mov r5, #6 mul r2, r0, r5 @ r2 = 6x, @ record r2 and psr value subs r3, r1, r2 @ r3 = 5x^2 - 6x, @ record r3 and psr value add r3, r3, #8 @ r3 = 5x^2 - 6x + 8, @ record r3 and psr value stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above and pay attention to what is happening in each register then record the PSR flags after each arithmetic instruction. Submit it as part of the lab question. Below is another example with variables and shifting. Although variables cannot be declared in the same way as a high-level programming language, it is possible to tell the assembler to automatically assign an address with a label and always reference it using the same label. Replace the code within the file with the following: .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put variables in the data section sum: .word # @ declare a label for data of word size num: .word # @ sum and num with values of 0 and 5 .text @ put code in the text section .global main @ declare main as a global variable .type main, %function @ set main to function type main: @ start of main code with a label ldr r1, =num @ Load count into R1 ldr r1, [r1] @ Load count into R1 mov r0, #0 @ Clear accumulator R0 loop: add r0, r0, r1 @ Add number into R0, @ record psr value for each loop subs r1, r1, #1 @ Decrement loop counter R1, @ record psr value for each loop bgt loop @ Branch back if not done ldr r3, =sum @ Load address of SUM to R3 str r0, [r3] @ Store SUM ldr r4, [r3] stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention the what is happening in each register then record the PSR flags after each arithmetic instruction and submit it as part of the lab question. Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Execute the code from step 4 then record the PSR flags. Copy and paste your code with PSR flags into Blackboard. Execute the code from step 6 then record the PSR flags. Copy and paste your code with PSR flags into Blackboard. Write a program that converts Celsius to Fahrenheit or from Fahrenheit to Celsius depending on the input. If the input is above 32, it will assume the value is Fahrenheit and convert it to Celsius. If not, it will assume the value is Celsius and convert it to Fahrenheit. You will provide the input as data is saved into R0. No user input (ie. scanf) is required. The input data will be the last two digits of your student number. Do NOT modify R0 afterward. Your code must be written in assembly with the output saved in a variable (labelled space in memory). Your code must consider both cases and determine which formula to use depending on the input (ie. the code should function with input above or below 32). You can use the following as your conversion equation. You can assume the input data will always be a positive integer. C = 5 * (F - 32) / 9 F = (9 * C / 5) + 32 Put your name and student number as comments in the code then copy and paste your code into Blackboard. Also, take a screenshot of your register bank as well as your memory space highlighting the final variable value and paste them into Blackboard as well. Reference [1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Lab 3 : Branching in Assembly"},{"location":"seh500/lab3/#lab-3-branching-in-assembly","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 3 : Branching in Assembly"},{"location":"seh500/lab3/#introduction","text":"Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) As you've seen in the previous lab, the ARM processor has a Program Status Register with 4 flags that might get set or clear depending on the previous ALU operation. N : Negative flag - set to 1 when the result of an operation is negative Z : Zero flag - set to 1 when the result of an operation is zero C : Carry (or NOT borrow) flag set to 1 if the addition produces a carry set to 0 if the subtraction produces a borrow V : Overflow flag - set to 1 if the result of an operation is outside the range of a signed 32-bit integer These flags can then be used for decision-making within the program. Below are instructions that might set or clear the status flag.","title":"Introduction"},{"location":"seh500/lab3/#arithmetic-instructions","text":"Instruction Mnemonic Meaning Addition ADD R0, R1, R2 R0 = R1 + R2 Addition ADDS R0, R1, R2 R0 = R1 + R2, and FLAGs are updated Subtraction SUB R1, R2, R3 R1 = R2 - R3 Subtraction SUBS R1, R2, R3 R1 = R2 - R3, and FLAGs are updated Subtraction SUBS R7, R6, #20 R7 = R6 - 20, and sets the FLAGs on the result Reverse Subtraction RSB R4, R4, #120 R4 = 120 - R4 Multiply MUL R0, R1, R2 R0 = R1 * R2 Division SDIV R0, R2, R4 Signed divide, R0 = R2/R4 Division UDIV R8, R8, R1 Unsigned divide, R8 = R8/R1","title":"Arithmetic Instructions"},{"location":"seh500/lab3/#move-instructions","text":"Mnemonic Meaning MOV R1, #0xFA05 Write value of 0xFA05 to R1, flags are not updated MOVS R11, #0x000B Write value of 0x000B to R11, flags get updated MOVS R10, R12 Write value in R12 to R10, flags get updated MOV R3, #23 Write value of 23 to R3 MOV R8, SP Write value of stack pointer to R8 MVNS R2, #0xF Write value of 0xFFFFFFF0 (bitwise inverse of 0xF), to the R2 and update flags.","title":"Move Instructions"},{"location":"seh500/lab3/#logical-operation-instructions","text":"Mnemonic Meaning AND R9, R2, R1 R9 = R2 AND R1 AND R9, R2, #0xFF00 R9 = R2 AND #0xFF00 ANDS R9, R8, #0x19 with flags update ORR R9, R2, R1 R9 = R2 OR R1 ORR R9, R2, #0xFF00 ORREQ R2, R0, R5 EOR R7, R11, R10 R7 = R11 XOR R10 EORS R7, R11, #0x18181818 with flags update BIC R0, R1, #0xab R0 = R1 AND (NOT(#0xab)) ORN R7, R11, R14, ROR #4 R7 = R11 OR (NOT(R14 ROR #4)) ORNS R7, R11, R14, ROR #2 with flags update","title":"Logical Operation Instructions"},{"location":"seh500/lab3/#shift-instructions","text":"Mnemonic Meaning LSL R4, R5, #2 Logical shift left by 2 bits LSR R4, R5, #6 Logical shift right by 6 bits LSLS R1, R2, #3 Logical shift left by 3 bits with flags update ROR R4, R5, R6 Rotate right by the value in the bottom byte of R6 RRX R4, R5 Rotate right with extend (one bit only).","title":"Shift Instructions"},{"location":"seh500/lab3/#branching-instructions","text":"Mnemonic Meaning B <label> Branch B{cond} <label> Branch with condition BL <label> Branch with Link BL{cond} <label> Branch with Link with condition BX <Rm> Branch to register value BX{cond} <Rm> Branch to register value with condition BLX <Rm> Branch with Link to register value BLX{cond} <Rm> Branch with Link to register value with condition See below for conditions that are set by a compare, usually by using the CMP, instruction. The CMP Rm, Rn instruction operates \"Rm - Rn\" for the sole purpose of setting the condition flags. Unlike a subtraction operation, the result of the compare operation is discarded.","title":"Branching Instructions"},{"location":"seh500/lab3/#branching-conditions","text":"The APSR contains the following condition flags: N : Set to 1 when the result of the operation was negative, cleared to 0 otherwise. Z : Set to 1 when the result of the operation was zero, cleared to 0 otherwise. C : Set to 1 when the operation resulted in a carry, cleared to 0 otherwise. V : Set to 1 when the operation caused overflow, cleared to 0 otherwise. Depending on how you want branching to be done, the condition suffix can be added to the branching instruction to form a conditional branching instruction. Suffix {cond} Flags Meaning EQ Z = 1 Equal NE Z = 0 Not equal CS or HS C = 1 Higher or same, unsigned CC or LO C = 0 Lower, unsigned MI N = 1 Negative PL N = 0 Positive or zero VS V = 1 Overflow VC V = 0 No overflow HI C = 1 and Z = 0 Higher, unsigned LS C = 0 or Z = 1 Lower or same, unsigned GE N = V Greater than or equal, signed LT N != V Less than, signed GT Z = 0 and N = V Greater than, signed LE Z = 1 and N != V Less than or equal, signed AL Can have any value Always. This is the default when no suffix is specified.","title":"Branching Conditions"},{"location":"seh500/lab3/#variables","text":"When defining a variable, the compiler assigns an address in memory with sufficient size to store the data. All variables are defined in the .data section of the code that should be placed above the .text section. Some possible data types are: .byte : 1 byte .short : 2 bytes .word : 4 bytes .quad : 8 bytes .octa : 16 bytes","title":"Variables"},{"location":"seh500/lab3/#procedures","text":"Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, rename the project then leave all other settings as default. Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". Replace the code within the file with the following: .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .global main @ declare main as a global variable .type main, %function @ set main to function type main: @ start of main code with a label mov r0, # @ x = <use the last digit of your student ID + 1> mul r1, r0, r0 @ r1 = x^2, @ record r1 and psr value mov r4, #5 muls r1, r1, r4 @ r1 = 5x^2, @ record r1 and psr value mov r5, #6 mul r2, r0, r5 @ r2 = 6x, @ record r2 and psr value subs r3, r1, r2 @ r3 = 5x^2 - 6x, @ record r3 and psr value add r3, r3, #8 @ r3 = 5x^2 - 6x + 8, @ record r3 and psr value stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above and pay attention to what is happening in each register then record the PSR flags after each arithmetic instruction. Submit it as part of the lab question. Below is another example with variables and shifting. Although variables cannot be declared in the same way as a high-level programming language, it is possible to tell the assembler to automatically assign an address with a label and always reference it using the same label. Replace the code within the file with the following: .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put variables in the data section sum: .word # @ declare a label for data of word size num: .word # @ sum and num with values of 0 and 5 .text @ put code in the text section .global main @ declare main as a global variable .type main, %function @ set main to function type main: @ start of main code with a label ldr r1, =num @ Load count into R1 ldr r1, [r1] @ Load count into R1 mov r0, #0 @ Clear accumulator R0 loop: add r0, r0, r1 @ Add number into R0, @ record psr value for each loop subs r1, r1, #1 @ Decrement loop counter R1, @ record psr value for each loop bgt loop @ Branch back if not done ldr r3, =sum @ Load address of SUM to R3 str r0, [r3] @ Store SUM ldr r4, [r3] stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention the what is happening in each register then record the PSR flags after each arithmetic instruction and submit it as part of the lab question.","title":"Procedures"},{"location":"seh500/lab3/#lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Execute the code from step 4 then record the PSR flags. Copy and paste your code with PSR flags into Blackboard. Execute the code from step 6 then record the PSR flags. Copy and paste your code with PSR flags into Blackboard. Write a program that converts Celsius to Fahrenheit or from Fahrenheit to Celsius depending on the input. If the input is above 32, it will assume the value is Fahrenheit and convert it to Celsius. If not, it will assume the value is Celsius and convert it to Fahrenheit. You will provide the input as data is saved into R0. No user input (ie. scanf) is required. The input data will be the last two digits of your student number. Do NOT modify R0 afterward. Your code must be written in assembly with the output saved in a variable (labelled space in memory). Your code must consider both cases and determine which formula to use depending on the input (ie. the code should function with input above or below 32). You can use the following as your conversion equation. You can assume the input data will always be a positive integer. C = 5 * (F - 32) / 9 F = (9 * C / 5) + 32 Put your name and student number as comments in the code then copy and paste your code into Blackboard. Also, take a screenshot of your register bank as well as your memory space highlighting the final variable value and paste them into Blackboard as well.","title":"Lab Questions"},{"location":"seh500/lab3/#reference","text":"[1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Reference"},{"location":"seh500/lab4/","text":"Lab 4 : Branching, Array and String in Assembly Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) In the previous lab, we explored how to use the program status flags and how to perform branching. In this lab, we'll further explore branching and variables in the form of arrays and strings. Review of Branching Instructions Mnemonic Meaning B label Branch B{cond} label Branch with condition BL label Branch with Link BL{cond} label Branch with Link with condition BX Rm Branch to register value BX{cond} Rm Branch to register value with condition BLX Rm Branch with Link to register value BLX{cond} Rm Branch with Link to register value with condition See below for conditions that are set by a compare, usually CMP , instruction. The CMP Rm, Rn instruction operates Rm-Rn for the sole purpose of setting the condition flags. Review of Branching Conditions The APSR contains the following condition flags: N : Set to 1 when the result of the operation was negative, cleared to 0 otherwise. Z : Set to 1 when the result of the operation was zero, cleared to 0 otherwise. C : Set to 1 when the operation resulted in a carry, cleared to 0 otherwise. V : Set to 1 when the operation caused overflow, cleared to 0 otherwise. Suffix Flags Meaning EQ Z = 1 Equal NE Z = 0 Not equal CS or HS C = 1 Higher or same, unsigned, >= CC or LO C = 0 Lower, unsigned, < MI N = 1 Negative PL N = 0 Positive or zero VS V = 1 Overflow VC V = 0 No overflow HI C = 1 and Z = 0 Higher, unsigned, > LS C = 0 or Z = 1 Lower or same, unsigned, <= GE N = V Greater than or equal, signed, >= LT N != V Less than, signed, < GT Z = 0 and N = V Greater than, signed, > LE Z = 1 and N != V Less than or equal, signed, <= AL Can have any value Always. This is the default when no suffix is specified. Examples of Compare Instructions Mnemonic Meaning CBZ R5, label Compare and branch to label if R5 is zero CBNZ R0, label Compare and branch to label if R0 is not zero CMP R2, R9 Compare R2 - R9, update the N, Z, C and V flags Same as SUBS except the result is discarded CMN R0, #64 Compare (negative) R0 + #64, update the N, Z, C and V flags Same as ADDS except the result is discarded Example of Branching Instructions Following a compare instruction, branching instructions can be used as follows: Instruction Action B label Branch to label unconditionally BEQ label Conditionally branch to label, when Z = 1 BNE label branch to label when Z = 0 BMI label branch to label when N = 1 BPL label branch to label when N = 0 BLT label Conditionally branch to label, when N is set and V is clear or N is clear and V is set i.e. N != V BLE label Conditionally branch to label, when less than or equal, Z is set or N is set and V is clear or N is clear and V is set i.e. Z = 1 or N != V BGT label Conditionally branch to label, when Z is clear and either N is set and V is set or N is clear and V is clear i.e. Z = 0 and N == V BGE label Conditionally branch to label, when greater than or equal to zero, Z is set or N is set and V is clear or N is clear and V is set i.e. Z = 1 or N == V BL label Branch with link (Call) to label, with return address stored in LR (register R14) BX LR Return from function call, loading LR into PC BXNE R0 Conditionally branch to address stored in R0 BLX R0 Branch with link (Call) to an address stored in R0, with return address stored in LR (register R14) Register Addressing Mode In addition to the basic LDR and STR, there are also a few other different ways to specify the address for load and store instructions. Name Examples Meaning Register to register Register direct MOV R0, R1 Absolute Direct LDR R0, =address Literal Immediate MOV R0, #15 ADD R1, R2, #12 Indexed, base Register indirect LDR R0, [R1] Load R0 with the word pointed by R1 Pre-indexed, base with displacement Register indirect with offset LDR R0, [R1, #4] Load R0 with the word pointed by R1+4 Pre-indexed, autoindexing Register indirect pre-incrementing LDR R0, [R1, #4]! Load R0 with the word pointed by R1+4 then add 4 to R1 Post-indexing, autoindexed Register indirect post-increment LDR R0, [R1], #4 Load R0 with the word pointed by R1 then add 4 to R1 Double Reg indirect Register indirect register indexed LDR R0, [R1, R2] Load R0 with the word pointed by R1+R2 Program counter relative LDR R0, [PC, #offset] Load R0 with the word pointed by PC+offset IT (If-Then) Block The IT (If-Then) block is a feature with an ARM processor that validates the conditions specified in the IT instructions against the conditions specified in the following instructions. In other words, an IT black helps ensure there are no semantic errors during assembly programming. NOTE : An IT block is not always required as some IDE will insert it for you automatically. An IT block has the following syntax: IT{x{y{z}}} {cond} Where: x - specifies the condition switch for the second instruction in the IT block. y - specifies the condition switch for the third instruction in the IT block. z - specifies the condition switch for the fourth instruction in the IT block. cond - specifies the condition for the first instruction in the IT block. The condition switch for the second, third and fourth instruction in the IT block can be either: T/t - Then. Applies the condition to the instruction.cond E/e - Else. Applies the inverse condition to the instruction.cond Example: itte ne @ define the two condition switches in IT block andne r0,r0,r1 @ first line in IT block, always an if addsne r2,r2,#1 @ second line in IT block, then moveq r2,r3 @ third line in IT block, else add r0,r0,r1 @ not in IT block itt eq @ define the one condition switches in IT block moveq r0,r1 @ first line in IT block, always an if beq main @ branch at end of IT block is permitted Procedures Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, rename the project then leave all other settings as default. Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". In the previous lab, we also explored the idea of using a label to reference address in memory used in the same manner as variables in high-level programming language, this time, we'll explore the use of string. Replace the code within the file with the following: @ Example Code #1 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section myString: .string \"\" @ put your name within the \"\" @ declare a label for a string with a null terminator .text .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r0, =myString @ Load the address of myString into R0 @ R0 = ? mov r1, #0 @ Initialize the counter @ R1 = ? loopCount: ldrb r2, [r0] @ Load the character from the address in R0 cmp r2, #0 @ check for null terminator @ R2 = ? During the first loop @ R2 = ? At the end of the program @ Which ASCII characters are they? beq countDone @ If it is zero...null terminated... @ We are done with the string. @ The length is in R1. add r0, #1 @ Otherwise, increment the @ address to the next character @ R0 = ? During the first loop @ R0 = ? At the end of the program add r1, #1 @ increment the counter for length @ R1 = ? During the first loop @ R1 = ? At the end of the program @ What is the length of the string? b loopCount countDone: stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address where the string is saved then take a screenshot showing the memory address along with the value and ASCII character saved in it. Submit your code and screenshot as part of the lab question. In the previous code, we explored the idea of using string. In this code, we'll take a look at the use of an array. Replace the code within the file with the following: @ Example Code #2 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section sump: .word sum @ a pointer for sum pointer: .word num1 @ a pointer for num1 n: .word 5 @ variable n, word size, value 5 num1: .word #, -#, -#, -#, # @ replace it with the last 5 digits of your student number and maintain the negative @ array num1 with 5 elements, word size sum: .word 0 @ variable sum, word size, value 0 .text .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r1, =n ldr r1, [r1] @ load size of array, R1 = ? @ a counter for how many elements are left to process ldr r2, =pointer ldr r2, [r2] @ load base pointer of array, R2 = ? mov r0, #0 @ initialize counter, R0 = ? loop: ldr r3, [r2], #4 @ load value from array @ R3 = ? for the first loop @ R3 = ? for the second loop @ increment array pointer to next word (index) add r0, r0, r3 @ add value from array to counter @ R0 = ? for the first loop @ R0 = ? for the second loop subs r1, r1, #1 @ decrement word counter @ R1 = ? for the first loop @ R1 = ? for the second loop bgt loop @ keep looping until the counter is zero ldr r4, =sump ldr r4, [r4] @ get memory address to store sum str r0, [r4] @ store answer ldr r6, [r4] @ Check the value in the sum stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address where the array is saved then take a screenshot showing the memory address along with the value and highlight the negative. Submit your code and screenshot as part of the lab question. Lastly, the code from the first example can also be written as follows using an array instead of a string. Also, a different comparison statement is used. @ Example Code #3 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section myString: .ascii \"\\0\" @ put your name before \\0 @ declare a label for a string with a null terminator .text .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r0, =myString @ Load the address of myString into R0 mov r1, #0 @ Initialize the counter loopCount: ldrb r2, [r0], #1 @ Load the character from the address in R0 @ and update the pointer R0 cbz r2, countDone @ check for null terminator in one line @ If it is zero...null terminated... @ We are done with the string. @ The length is in R1. add r1, #1 @ increment the counter for length b loopCount countDone: stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Compare the third example code with the first example code and find the difference between then explain which line got added, removed, changed and why. Also, discuss its effect on the code then put your answer in the lab question. Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Execute Example Code #1 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Which line(s) in Example #1 is responsible for looping through the char array and explain how it works? Execute Example Code #2 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Which line(s) in Example #2 is responsible for looping through the char array and explain how it works? How are Example Code #3 and Example Code #1 different in terms of loop(s) and comparison statement(s)? Write a program in assembly language that counts how many vowels and non-vowels are in \"SEH500 is very cool! (your name here)\" (REPLACE (your name here) with your name). Hint: put your string into memory using the .string directive use R0 to hold the address for the string or character use R1 as the counter for vowel use R2 as the counter for non-vowel For the code above, at the end of execution, take a screenshot of your register bank, and your memory space highlighting the string then copy your code into Blackboard. Reference [1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Lab 4 : Branching, Array and String in Assembly"},{"location":"seh500/lab4/#lab-4-branching-array-and-string-in-assembly","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 4 : Branching, Array and String in Assembly"},{"location":"seh500/lab4/#introduction","text":"Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) In the previous lab, we explored how to use the program status flags and how to perform branching. In this lab, we'll further explore branching and variables in the form of arrays and strings.","title":"Introduction"},{"location":"seh500/lab4/#review-of-branching-instructions","text":"Mnemonic Meaning B label Branch B{cond} label Branch with condition BL label Branch with Link BL{cond} label Branch with Link with condition BX Rm Branch to register value BX{cond} Rm Branch to register value with condition BLX Rm Branch with Link to register value BLX{cond} Rm Branch with Link to register value with condition See below for conditions that are set by a compare, usually CMP , instruction. The CMP Rm, Rn instruction operates Rm-Rn for the sole purpose of setting the condition flags.","title":"Review of Branching Instructions"},{"location":"seh500/lab4/#review-of-branching-conditions","text":"The APSR contains the following condition flags: N : Set to 1 when the result of the operation was negative, cleared to 0 otherwise. Z : Set to 1 when the result of the operation was zero, cleared to 0 otherwise. C : Set to 1 when the operation resulted in a carry, cleared to 0 otherwise. V : Set to 1 when the operation caused overflow, cleared to 0 otherwise. Suffix Flags Meaning EQ Z = 1 Equal NE Z = 0 Not equal CS or HS C = 1 Higher or same, unsigned, >= CC or LO C = 0 Lower, unsigned, < MI N = 1 Negative PL N = 0 Positive or zero VS V = 1 Overflow VC V = 0 No overflow HI C = 1 and Z = 0 Higher, unsigned, > LS C = 0 or Z = 1 Lower or same, unsigned, <= GE N = V Greater than or equal, signed, >= LT N != V Less than, signed, < GT Z = 0 and N = V Greater than, signed, > LE Z = 1 and N != V Less than or equal, signed, <= AL Can have any value Always. This is the default when no suffix is specified.","title":"Review of Branching Conditions"},{"location":"seh500/lab4/#examples-of-compare-instructions","text":"Mnemonic Meaning CBZ R5, label Compare and branch to label if R5 is zero CBNZ R0, label Compare and branch to label if R0 is not zero CMP R2, R9 Compare R2 - R9, update the N, Z, C and V flags Same as SUBS except the result is discarded CMN R0, #64 Compare (negative) R0 + #64, update the N, Z, C and V flags Same as ADDS except the result is discarded","title":"Examples of Compare Instructions"},{"location":"seh500/lab4/#example-of-branching-instructions","text":"Following a compare instruction, branching instructions can be used as follows: Instruction Action B label Branch to label unconditionally BEQ label Conditionally branch to label, when Z = 1 BNE label branch to label when Z = 0 BMI label branch to label when N = 1 BPL label branch to label when N = 0 BLT label Conditionally branch to label, when N is set and V is clear or N is clear and V is set i.e. N != V BLE label Conditionally branch to label, when less than or equal, Z is set or N is set and V is clear or N is clear and V is set i.e. Z = 1 or N != V BGT label Conditionally branch to label, when Z is clear and either N is set and V is set or N is clear and V is clear i.e. Z = 0 and N == V BGE label Conditionally branch to label, when greater than or equal to zero, Z is set or N is set and V is clear or N is clear and V is set i.e. Z = 1 or N == V BL label Branch with link (Call) to label, with return address stored in LR (register R14) BX LR Return from function call, loading LR into PC BXNE R0 Conditionally branch to address stored in R0 BLX R0 Branch with link (Call) to an address stored in R0, with return address stored in LR (register R14)","title":"Example of Branching Instructions"},{"location":"seh500/lab4/#register-addressing-mode","text":"In addition to the basic LDR and STR, there are also a few other different ways to specify the address for load and store instructions. Name Examples Meaning Register to register Register direct MOV R0, R1 Absolute Direct LDR R0, =address Literal Immediate MOV R0, #15 ADD R1, R2, #12 Indexed, base Register indirect LDR R0, [R1] Load R0 with the word pointed by R1 Pre-indexed, base with displacement Register indirect with offset LDR R0, [R1, #4] Load R0 with the word pointed by R1+4 Pre-indexed, autoindexing Register indirect pre-incrementing LDR R0, [R1, #4]! Load R0 with the word pointed by R1+4 then add 4 to R1 Post-indexing, autoindexed Register indirect post-increment LDR R0, [R1], #4 Load R0 with the word pointed by R1 then add 4 to R1 Double Reg indirect Register indirect register indexed LDR R0, [R1, R2] Load R0 with the word pointed by R1+R2 Program counter relative LDR R0, [PC, #offset] Load R0 with the word pointed by PC+offset","title":"Register Addressing Mode"},{"location":"seh500/lab4/#it-if-then-block","text":"The IT (If-Then) block is a feature with an ARM processor that validates the conditions specified in the IT instructions against the conditions specified in the following instructions. In other words, an IT black helps ensure there are no semantic errors during assembly programming. NOTE : An IT block is not always required as some IDE will insert it for you automatically. An IT block has the following syntax: IT{x{y{z}}} {cond} Where: x - specifies the condition switch for the second instruction in the IT block. y - specifies the condition switch for the third instruction in the IT block. z - specifies the condition switch for the fourth instruction in the IT block. cond - specifies the condition for the first instruction in the IT block. The condition switch for the second, third and fourth instruction in the IT block can be either: T/t - Then. Applies the condition to the instruction.cond E/e - Else. Applies the inverse condition to the instruction.cond Example: itte ne @ define the two condition switches in IT block andne r0,r0,r1 @ first line in IT block, always an if addsne r2,r2,#1 @ second line in IT block, then moveq r2,r3 @ third line in IT block, else add r0,r0,r1 @ not in IT block itt eq @ define the one condition switches in IT block moveq r0,r1 @ first line in IT block, always an if beq main @ branch at end of IT block is permitted","title":"IT (If-Then) Block"},{"location":"seh500/lab4/#procedures","text":"Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, rename the project then leave all other settings as default. Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". In the previous lab, we also explored the idea of using a label to reference address in memory used in the same manner as variables in high-level programming language, this time, we'll explore the use of string. Replace the code within the file with the following: @ Example Code #1 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section myString: .string \"\" @ put your name within the \"\" @ declare a label for a string with a null terminator .text .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r0, =myString @ Load the address of myString into R0 @ R0 = ? mov r1, #0 @ Initialize the counter @ R1 = ? loopCount: ldrb r2, [r0] @ Load the character from the address in R0 cmp r2, #0 @ check for null terminator @ R2 = ? During the first loop @ R2 = ? At the end of the program @ Which ASCII characters are they? beq countDone @ If it is zero...null terminated... @ We are done with the string. @ The length is in R1. add r0, #1 @ Otherwise, increment the @ address to the next character @ R0 = ? During the first loop @ R0 = ? At the end of the program add r1, #1 @ increment the counter for length @ R1 = ? During the first loop @ R1 = ? At the end of the program @ What is the length of the string? b loopCount countDone: stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address where the string is saved then take a screenshot showing the memory address along with the value and ASCII character saved in it. Submit your code and screenshot as part of the lab question. In the previous code, we explored the idea of using string. In this code, we'll take a look at the use of an array. Replace the code within the file with the following: @ Example Code #2 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section sump: .word sum @ a pointer for sum pointer: .word num1 @ a pointer for num1 n: .word 5 @ variable n, word size, value 5 num1: .word #, -#, -#, -#, # @ replace it with the last 5 digits of your student number and maintain the negative @ array num1 with 5 elements, word size sum: .word 0 @ variable sum, word size, value 0 .text .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r1, =n ldr r1, [r1] @ load size of array, R1 = ? @ a counter for how many elements are left to process ldr r2, =pointer ldr r2, [r2] @ load base pointer of array, R2 = ? mov r0, #0 @ initialize counter, R0 = ? loop: ldr r3, [r2], #4 @ load value from array @ R3 = ? for the first loop @ R3 = ? for the second loop @ increment array pointer to next word (index) add r0, r0, r3 @ add value from array to counter @ R0 = ? for the first loop @ R0 = ? for the second loop subs r1, r1, #1 @ decrement word counter @ R1 = ? for the first loop @ R1 = ? for the second loop bgt loop @ keep looping until the counter is zero ldr r4, =sump ldr r4, [r4] @ get memory address to store sum str r0, [r4] @ store answer ldr r6, [r4] @ Check the value in the sum stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address where the array is saved then take a screenshot showing the memory address along with the value and highlight the negative. Submit your code and screenshot as part of the lab question. Lastly, the code from the first example can also be written as follows using an array instead of a string. Also, a different comparison statement is used. @ Example Code #3 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section myString: .ascii \"\\0\" @ put your name before \\0 @ declare a label for a string with a null terminator .text .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r0, =myString @ Load the address of myString into R0 mov r1, #0 @ Initialize the counter loopCount: ldrb r2, [r0], #1 @ Load the character from the address in R0 @ and update the pointer R0 cbz r2, countDone @ check for null terminator in one line @ If it is zero...null terminated... @ We are done with the string. @ The length is in R1. add r1, #1 @ increment the counter for length b loopCount countDone: stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Compare the third example code with the first example code and find the difference between then explain which line got added, removed, changed and why. Also, discuss its effect on the code then put your answer in the lab question.","title":"Procedures"},{"location":"seh500/lab4/#lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Execute Example Code #1 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Which line(s) in Example #1 is responsible for looping through the char array and explain how it works? Execute Example Code #2 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Which line(s) in Example #2 is responsible for looping through the char array and explain how it works? How are Example Code #3 and Example Code #1 different in terms of loop(s) and comparison statement(s)? Write a program in assembly language that counts how many vowels and non-vowels are in \"SEH500 is very cool! (your name here)\" (REPLACE (your name here) with your name). Hint: put your string into memory using the .string directive use R0 to hold the address for the string or character use R1 as the counter for vowel use R2 as the counter for non-vowel For the code above, at the end of execution, take a screenshot of your register bank, and your memory space highlighting the string then copy your code into Blackboard.","title":"Lab Questions"},{"location":"seh500/lab4/#reference","text":"[1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Reference"},{"location":"seh500/lab5/","text":"Lab 5 : More Branching, Subroutine, and Stack Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) In the previous lab, we explored how to use basic branching to control the flow of a program. In this lab, we'll further explore branching and use the stack point to create subroutine and function call procedure. Review of Branching Instructions with Link Mnemonic Meaning B label Branch B{cond} label Branch with condition BL label Branch with Link BL{cond} label Branch with Link with condition BX Rm Branch to register value BX{cond} Rm Branch to register value with condition BLX Rm Branch with Link to register value BLX{cond} Rm Branch with Link to register value with condition See below for conditions that are set by a compare, usually CMP , instruction. The CMP Rm, Rn instruction operates Rm-Rn for the sole purpose of setting the condition flags. Review of Branching Conditions Suffix Flags Meaning EQ Z = 1 Equal NE Z = 0 Not equal CS or HS C = 1 Higher or same, unsigned, >= CC or LO C = 0 Lower, unsigned, < MI N = 1 Negative PL N = 0 Positive or zero VS V = 1 Overflow VC V = 0 No overflow HI C = 1 and Z = 0 Higher, unsigned, > LS C = 0 or Z = 1 Lower or same, unsigned, <= GE N = V Greater than or equal, signed, >= LT N != V Less than, signed, < GT Z = 0 and N = V Greater than, signed, > LE Z = 1 and N != V Less than or equal, signed, <= AL Can have any value Always. This is the default when no suffix is specified. Register Use in the ARM Procudure Call Standard So far, we've been using the general purpose registers freely without much condition of what there are ideal for or any standards. However, below is a common convention to consider when using registers: Purpose Register Argument 1 r0 Argument 2 r1 Argument 3 r2 Argument 4 r3 Variable 1 r4 Variable 2 r5 Variable 3 r6 Variable 4 r7 Variable 5 r8 Variable 6 / Stack Base r9 Variable 7 / Stack Limit r10 Variable 8 / Frame Pointer r11 Intra-Procedure Scratch r12 Stack Pointer (SP) r13 Link Register (LR) r14 Program Counter (PC) r15 Note that even though SP, LR and PC are special register used by the processor, they can still be modified with code and used the same way as other registers. Introduction to Stack The stack is a data structure, known as last in first out (LIFO). In a stack, items entered at one end and leave in the reversed order. Stacks in microprocessors are implemented by using a stack pointer to point to the top of the stack in memory. As items are added to the stack (pushed), the stack pointer is moving up, and as items are removed from the stack (pulled or popped), the stack pointer is moved down. ARM stacks are very flexible since the implementation is completely left to the software. Stack pointer is a register that points to the top of the stack. In the ARM processor, any one of the general purpose registers could be used as a stack pointer. Since it is left to the software to implement a stack, different implemenation choices result different types of stacks. Normally, there are two types of the stacks depending on which way the stack grows. Ascending Stack - When items are pushed on to the stack, the stack pointer is increasing. That means the stack grows towards higher address. Descending Stack - When items are pushed on to the stack, the stack pointer is decreasing. That means the stack is growing towards lower address. Depending on what the stack pointer points to we can categorize the stacks into the following two types: Empty Stack - Stack pointer points to the location in which the next/first item will be stored. e.g. A push will store the value, and increment the stack pointer for an Ascending Stack. Full Stack - Stack pointer points to the location in which the last item was stored. e.g. A pop will decrement the stack pointer and pull the value for an Ascending Stack. So now we can have four possible types of stacks. They are: full-ascending stack, full-descending stack, empty-ascending stack, empty-descending stack. They can be implemented by using the register load and store instructions. Here are some instructions used to deal with stack: PUSH {R3} @ Push R3 onto the stack PUSH {R0, R4-R7} @ Push R0, R4, R5, R6, R7 onto the stack PUSH {R2, LR} @ Push R2 and the link register onto the stack POP {R0, R5, PC} @ pop and return from subroutine, branch to PC POP {R3} @ Pop stack value and save to R3 Push registers onto and pop registers off a full-descending stack. Subroutine and Stack A subroutine call can be implemented by pushing the return address on the stack and then jumping to the branch target address. When the subroutine is done, remember to pop out the saved information so that it will be able to return to the next instruction immediately after the calling point. Procedures Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, rename the project then leave all other settings as default. Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". In this example, let's take a look as a simple subroutine call. Replace the code within the file with the following: @ Lab 5 Example 1 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section sump: .word sum @ declare a pointer to sum sump2: .word sum2 @ declare a pointer to sum2 n: .word 5 @ declare variable n with value of 5 sum: .word 0 @ declare sum with value of 0 sum2: .word 0 @ declare sum2 with value of 0 .text @ put code in the code section .global sumup @ declare sumup as a global variable .type sumup, %function @ set sumup to function type sumup: add r0, r0, r1 @ R0 = ? after first execution only subs r1, r1, #1 @ R1 = ? after first execution only bgt sumup @ Branch back if not done bx lr @ PC = ?, LR = ? @ After execution, PC = ? .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r1, =n @ Load count into R1 ldr r1, [r1] @ R1 = ? mov r0, #0 @ Clear accumulator R0 bl sumup @ PC = ?, LR = ? ldr r3, =sump @ Load address of SUM to R3 ldr r3, [r3] @ R3 = ? str r0, [r3] @ Store SUM ldr r4, [r3] @ R4 = ? mov r7, #8 ldr r5, =sump2 @ Load address of SUM2 to R5 ldr r5, [r5] @ R5 = ? str r7, [r5] @ Store SUM2 ldr r6, [r5] @ R6 = ? stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address at where the variable is saved then take a screenshot showing the memory address along with its data. Submit your code and screenshot it as part of the lab question. In this code, we'll take a look at subroutine and stack. Replace the code within the file with the following: @ Lab 5 Example 2 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section sump: .word sum @ declare a pointer to sum sump2: .word sum2 @ declare a pointer to sum2 n: .word 5 @ declare variable n with value of 5 sum: .word 0 @ declare sum with value of 0 sum2: .word 0 @ declare sum2 with value of 0 .text @ put code in the code section .global function1 @ declare as a global variable .type function1, %function @ set to function type function1: push {r5, lr} @ Save values in the stack @ which address did R5 and LR got saved to? mov r5, #8 @ Set initial value for the delay loop delay: subs r5, r5, #1 @ R5 = ? after first execution bne delay pop {r5, pc} @ pop out the saved value from the stack, @ check the value in the R5 @ and see if it is the saved value @ R5 = ?, PC = ? .global main @ declare main as a global variable .type main, %function @ set main to function type main: mov r0, #1 @ SP = ? then memory monitor to SP address mov r3, #0x75 push {r0, r3} @ SP = ? which address did #0x75 @ and #1 got saved to? mov r0, #6 @ R0 = ? mov r3, #7 @ R3 = ? pop {r0, r3} @ after pop, R0 = ?, R3 = ?, SP = ? @ did the value in memory address changed loop: add r0, r0, #1 cmp r0, #5 bne loop mov r5, #9 @ prepare for function call bl function1 @ PC = ?, LR = ?, R5 = ? mov r3, #12 stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address at where the variable is saved then take a screenshot showing the memory address along with its data. Submit your code and screenshot it as part of the lab question. Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Execute Lab Example Code 1 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Execute Lab Example Code 2 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Which one of the four types of stack are you using in Example Code 2? Justify your answer with the stack pointer and memory space. Use screenshots if necessary. Rewrite the program from the last lab in assembly language that counts how many vowels and non-vowels are in \"SEH500 is very cool! (your name here)\" (REPLACE (your name here) with your name). But this time, you must use at least one subroutine in your code along with the stack. Hint: put your string into memory using the .string directive use R0 to hold the address for the string or character use R1 as the counter for vowel use R2 as the counter for non-vowel For the code above, at the end of execution, take a screenshot of your register bank, and your memory space highlighting the string then copy your screenshot and code into Blackboard. Reference [1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Lab 5 : More Branching, Subroutine, and Stack"},{"location":"seh500/lab5/#lab-5-more-branching-subroutine-and-stack","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 5 : More Branching, Subroutine, and Stack"},{"location":"seh500/lab5/#introduction","text":"Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) In the previous lab, we explored how to use basic branching to control the flow of a program. In this lab, we'll further explore branching and use the stack point to create subroutine and function call procedure.","title":"Introduction"},{"location":"seh500/lab5/#review-of-branching-instructions-with-link","text":"Mnemonic Meaning B label Branch B{cond} label Branch with condition BL label Branch with Link BL{cond} label Branch with Link with condition BX Rm Branch to register value BX{cond} Rm Branch to register value with condition BLX Rm Branch with Link to register value BLX{cond} Rm Branch with Link to register value with condition See below for conditions that are set by a compare, usually CMP , instruction. The CMP Rm, Rn instruction operates Rm-Rn for the sole purpose of setting the condition flags.","title":"Review of Branching Instructions with Link"},{"location":"seh500/lab5/#review-of-branching-conditions","text":"Suffix Flags Meaning EQ Z = 1 Equal NE Z = 0 Not equal CS or HS C = 1 Higher or same, unsigned, >= CC or LO C = 0 Lower, unsigned, < MI N = 1 Negative PL N = 0 Positive or zero VS V = 1 Overflow VC V = 0 No overflow HI C = 1 and Z = 0 Higher, unsigned, > LS C = 0 or Z = 1 Lower or same, unsigned, <= GE N = V Greater than or equal, signed, >= LT N != V Less than, signed, < GT Z = 0 and N = V Greater than, signed, > LE Z = 1 and N != V Less than or equal, signed, <= AL Can have any value Always. This is the default when no suffix is specified.","title":"Review of Branching Conditions"},{"location":"seh500/lab5/#register-use-in-the-arm-procudure-call-standard","text":"So far, we've been using the general purpose registers freely without much condition of what there are ideal for or any standards. However, below is a common convention to consider when using registers: Purpose Register Argument 1 r0 Argument 2 r1 Argument 3 r2 Argument 4 r3 Variable 1 r4 Variable 2 r5 Variable 3 r6 Variable 4 r7 Variable 5 r8 Variable 6 / Stack Base r9 Variable 7 / Stack Limit r10 Variable 8 / Frame Pointer r11 Intra-Procedure Scratch r12 Stack Pointer (SP) r13 Link Register (LR) r14 Program Counter (PC) r15 Note that even though SP, LR and PC are special register used by the processor, they can still be modified with code and used the same way as other registers.","title":"Register Use in the ARM Procudure Call Standard"},{"location":"seh500/lab5/#introduction-to-stack","text":"The stack is a data structure, known as last in first out (LIFO). In a stack, items entered at one end and leave in the reversed order. Stacks in microprocessors are implemented by using a stack pointer to point to the top of the stack in memory. As items are added to the stack (pushed), the stack pointer is moving up, and as items are removed from the stack (pulled or popped), the stack pointer is moved down. ARM stacks are very flexible since the implementation is completely left to the software. Stack pointer is a register that points to the top of the stack. In the ARM processor, any one of the general purpose registers could be used as a stack pointer. Since it is left to the software to implement a stack, different implemenation choices result different types of stacks. Normally, there are two types of the stacks depending on which way the stack grows. Ascending Stack - When items are pushed on to the stack, the stack pointer is increasing. That means the stack grows towards higher address. Descending Stack - When items are pushed on to the stack, the stack pointer is decreasing. That means the stack is growing towards lower address. Depending on what the stack pointer points to we can categorize the stacks into the following two types: Empty Stack - Stack pointer points to the location in which the next/first item will be stored. e.g. A push will store the value, and increment the stack pointer for an Ascending Stack. Full Stack - Stack pointer points to the location in which the last item was stored. e.g. A pop will decrement the stack pointer and pull the value for an Ascending Stack. So now we can have four possible types of stacks. They are: full-ascending stack, full-descending stack, empty-ascending stack, empty-descending stack. They can be implemented by using the register load and store instructions. Here are some instructions used to deal with stack: PUSH {R3} @ Push R3 onto the stack PUSH {R0, R4-R7} @ Push R0, R4, R5, R6, R7 onto the stack PUSH {R2, LR} @ Push R2 and the link register onto the stack POP {R0, R5, PC} @ pop and return from subroutine, branch to PC POP {R3} @ Pop stack value and save to R3 Push registers onto and pop registers off a full-descending stack.","title":"Introduction to Stack"},{"location":"seh500/lab5/#subroutine-and-stack","text":"A subroutine call can be implemented by pushing the return address on the stack and then jumping to the branch target address. When the subroutine is done, remember to pop out the saved information so that it will be able to return to the next instruction immediately after the calling point.","title":"Subroutine and Stack"},{"location":"seh500/lab5/#procedures","text":"Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, rename the project then leave all other settings as default. Once the project is created, rename the C-code file from \".c\" to \".s\". If the IDE is not allowing you to rename, delete the C-code file and create a new file of the same name but with the extension \".s\". In this example, let's take a look as a simple subroutine call. Replace the code within the file with the following: @ Lab 5 Example 1 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section sump: .word sum @ declare a pointer to sum sump2: .word sum2 @ declare a pointer to sum2 n: .word 5 @ declare variable n with value of 5 sum: .word 0 @ declare sum with value of 0 sum2: .word 0 @ declare sum2 with value of 0 .text @ put code in the code section .global sumup @ declare sumup as a global variable .type sumup, %function @ set sumup to function type sumup: add r0, r0, r1 @ R0 = ? after first execution only subs r1, r1, #1 @ R1 = ? after first execution only bgt sumup @ Branch back if not done bx lr @ PC = ?, LR = ? @ After execution, PC = ? .global main @ declare main as a global variable .type main, %function @ set main to function type main: ldr r1, =n @ Load count into R1 ldr r1, [r1] @ R1 = ? mov r0, #0 @ Clear accumulator R0 bl sumup @ PC = ?, LR = ? ldr r3, =sump @ Load address of SUM to R3 ldr r3, [r3] @ R3 = ? str r0, [r3] @ Store SUM ldr r4, [r3] @ R4 = ? mov r7, #8 ldr r5, =sump2 @ Load address of SUM2 to R5 ldr r5, [r5] @ R5 = ? str r7, [r5] @ Store SUM2 ldr r6, [r5] @ R6 = ? stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address at where the variable is saved then take a screenshot showing the memory address along with its data. Submit your code and screenshot it as part of the lab question. In this code, we'll take a look at subroutine and stack. Replace the code within the file with the following: @ Lab 5 Example 2 .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .data @ put data in the data section sump: .word sum @ declare a pointer to sum sump2: .word sum2 @ declare a pointer to sum2 n: .word 5 @ declare variable n with value of 5 sum: .word 0 @ declare sum with value of 0 sum2: .word 0 @ declare sum2 with value of 0 .text @ put code in the code section .global function1 @ declare as a global variable .type function1, %function @ set to function type function1: push {r5, lr} @ Save values in the stack @ which address did R5 and LR got saved to? mov r5, #8 @ Set initial value for the delay loop delay: subs r5, r5, #1 @ R5 = ? after first execution bne delay pop {r5, pc} @ pop out the saved value from the stack, @ check the value in the R5 @ and see if it is the saved value @ R5 = ?, PC = ? .global main @ declare main as a global variable .type main, %function @ set main to function type main: mov r0, #1 @ SP = ? then memory monitor to SP address mov r3, #0x75 push {r0, r3} @ SP = ? which address did #0x75 @ and #1 got saved to? mov r0, #6 @ R0 = ? mov r3, #7 @ R3 = ? pop {r0, r3} @ after pop, R0 = ?, R3 = ?, SP = ? @ did the value in memory address changed loop: add r0, r0, #1 cmp r0, #5 bne loop mov r5, #9 @ prepare for function call bl function1 @ PC = ?, LR = ?, R5 = ? mov r3, #12 stop: @ define a new label called stop nop @ do nothing b stop @ jump back label stop to form a loop Execute the code above, pay attention to what is happening in each register and record their value as per the code comment. Afterward, take a look at the memory address at where the variable is saved then take a screenshot showing the memory address along with its data. Submit your code and screenshot it as part of the lab question.","title":"Procedures"},{"location":"seh500/lab5/#lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Execute Lab Example Code 1 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Execute Lab Example Code 2 then answer the questions in the comment. Copy and paste your code with your answers along with any screenshots into Blackboard. Which one of the four types of stack are you using in Example Code 2? Justify your answer with the stack pointer and memory space. Use screenshots if necessary. Rewrite the program from the last lab in assembly language that counts how many vowels and non-vowels are in \"SEH500 is very cool! (your name here)\" (REPLACE (your name here) with your name). But this time, you must use at least one subroutine in your code along with the stack. Hint: put your string into memory using the .string directive use R0 to hold the address for the string or character use R1 as the counter for vowel use R2 as the counter for non-vowel For the code above, at the end of execution, take a screenshot of your register bank, and your memory space highlighting the string then copy your screenshot and code into Blackboard.","title":"Lab Questions"},{"location":"seh500/lab5/#reference","text":"[1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Reference"},{"location":"seh500/lab6/","text":"Lab 6 : Timer Interrupt and C Code Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) In our labs so far, we've been programming the processor directly using assembly language. In this lab, we'll explore combining assembly language with C programming language and how to use them interchangeablely in a program. Procedures Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, this time, also select \"pit\" as one of the driver. Rename the project then leave all other settings as default. Figure 6.1 Select pit in the project setting In previous labs, we wrote all of our code in assembly language using the .s file extension. In this lab, we are going to explore how to integrate C-code together with assembly code in a single project. The first way of integrating assembly code into a C-program is by using the inline assembler method. __asm volatile (\" <Assembly Code Here> \"); Replace (or comment out) the PRINTF \"Hello World\" line with the following: __asm volatile (\" mov r0, #1 \"); Build and create the dissambly code (or from the dissambly view window during debug). Find the inline assembly code that you wrote. Take a screenshot of it and confirm that the C-code and the assembly code are the same. Paste your result into the Post-Lab question on blackboard. You can also write multi-line inline assembly code as below. As the __asm function is a direct replicate of what you wrote into assembly, you'll need to use newline character to specify a newline in assembly. You can also align your C-code to make it more readable. __asm volatile (\" mov r1, #1 \\n\" \" mov r3, #0x75 \"); Transfer the following code from Lab 5 into inline assembly code and include it into the inline code you have. main: mov r0, #1 mov r3, #0x75 push {r0, r3} mov r0, #6 mov r3, #7 pop {r0, r3} Another method to include assembly code is by adding a .s file into the project. Create a function.s file in the source folder and paste the following extract from Lab 5 into it. .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .text @ put code in the code section .global function1 @ declare as a global variable .type function1, %function @ set to function type function1: push {r5, lr} @ Save values in the stack mov r5, #8 @ Set initial value for the delay loop delay: subs r5, r5, #1 bne delay pop {r5, pc} @ pop out the saved value from the stack Next, place a function prototype at the top of your code and a function call after your inline assembly code but before the while loop into your main function. Add this on top: void function1(); And this after your inline assembly code: function1(); Set a breakpoint at the __asm function then debug your code. Once the program started, hit resume until it reach the breakpoint then \"Step Into (F5)\" the code and see what happens. You program should jump to the code in your assembly file when it hit the function call. Your task now is to translate the assembly code in the loop portion of Lab 5 (see below) into C-code without using any assembly code except for moving data into register (use inline assembly for such task). Use variables and move the function call as necessary. The programmer's intentioned of the C-code should be the same as the assembly code. Translate the following: loop: add r0, r0, #1 cmp r0, #5 bne loop mov r5, #9 bl function1 mov r3, #12 You can use a for loop or a while loop. After you are done and get the desired result, compare the compiled assembly code with the one we have from Lab 5 and comment on the difference in terms of the type and number of instructions used. Copy your while or for loop C-code and it's assembly code and paste it into Blackboard. Lastly, we are going to include a periodic interrupt timer (PIT) into our code to generate an interrupt once every second. We'll use the built-in ConfigTools in MCUXpresso for ease of implementation. The ConfigTools allow us to setup components of the processor and the microcontroller board in a quick and fast manner instead of manually coding all the necessary settings. Go to \"ConfigTools > Peripherals\" from the top menu. In the \"Components\" tab, Under \"Peripheral drivers (Device specific)\" add the \"PIT\" configuration components. Under the PIT settings, uncheck \"start channel\". Leave everything default so the setting page should look like this: Figure 6.2 PIT settings Once confirmed, click \"Update Code\" at the top menu button bar and click yes when prompted. The peripherals.c and peripherals.h will not be updated accordingly to include the timer interrupt settings. Next, we'll need to add some code for the interrupt handler and to start the interrupt. Paste the following handler code into your program. void PIT_CHANNEL_0_IRQHANDLER(void) /*ISR to process PIT channel 0 interrupts*/ { PIT_ClearStatusFlags(PIT, PIT_CHANNEL_0, kPIT_TimerFlag); //clear PIT channel 0 interrupt status flag PRINTF(\"*\\r\\n\"); } Then use the following code to start the PIT in your main function. You can put it at the beginning of main after all the initialization or just before the empty while loop. PIT_StartTimer(PIT_PERIPHERAL, PIT_CHANNEL_0); Build and debug. Open a serial monitor to see the serial output. Let the program run and you should see an \"*\" being printed every second. Verify with a watch that the output is once per second. Take a screenshot of your serial monitor output and paste it into blackboard. Post-Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Answer all the questions in the lab on Blackboard. Modify your code from Step 16 so instead of printing \"*\" every second (using your timer interrupt function), print a statement that display the number of minutes and seconds since the timer started. Paste your code and a screenshot of the output into blackboard. Reference [1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Lab 6 : Timer Interrupt and C Code"},{"location":"seh500/lab6/#lab-6-timer-interrupt-and-c-code","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 6 : Timer Interrupt and C Code"},{"location":"seh500/lab6/#introduction","text":"Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) In our labs so far, we've been programming the processor directly using assembly language. In this lab, we'll explore combining assembly language with C programming language and how to use them interchangeablely in a program.","title":"Introduction"},{"location":"seh500/lab6/#procedures","text":"Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, this time, also select \"pit\" as one of the driver. Rename the project then leave all other settings as default. Figure 6.1 Select pit in the project setting In previous labs, we wrote all of our code in assembly language using the .s file extension. In this lab, we are going to explore how to integrate C-code together with assembly code in a single project. The first way of integrating assembly code into a C-program is by using the inline assembler method. __asm volatile (\" <Assembly Code Here> \"); Replace (or comment out) the PRINTF \"Hello World\" line with the following: __asm volatile (\" mov r0, #1 \"); Build and create the dissambly code (or from the dissambly view window during debug). Find the inline assembly code that you wrote. Take a screenshot of it and confirm that the C-code and the assembly code are the same. Paste your result into the Post-Lab question on blackboard. You can also write multi-line inline assembly code as below. As the __asm function is a direct replicate of what you wrote into assembly, you'll need to use newline character to specify a newline in assembly. You can also align your C-code to make it more readable. __asm volatile (\" mov r1, #1 \\n\" \" mov r3, #0x75 \"); Transfer the following code from Lab 5 into inline assembly code and include it into the inline code you have. main: mov r0, #1 mov r3, #0x75 push {r0, r3} mov r0, #6 mov r3, #7 pop {r0, r3} Another method to include assembly code is by adding a .s file into the project. Create a function.s file in the source folder and paste the following extract from Lab 5 into it. .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .text @ put code in the code section .global function1 @ declare as a global variable .type function1, %function @ set to function type function1: push {r5, lr} @ Save values in the stack mov r5, #8 @ Set initial value for the delay loop delay: subs r5, r5, #1 bne delay pop {r5, pc} @ pop out the saved value from the stack Next, place a function prototype at the top of your code and a function call after your inline assembly code but before the while loop into your main function. Add this on top: void function1(); And this after your inline assembly code: function1(); Set a breakpoint at the __asm function then debug your code. Once the program started, hit resume until it reach the breakpoint then \"Step Into (F5)\" the code and see what happens. You program should jump to the code in your assembly file when it hit the function call. Your task now is to translate the assembly code in the loop portion of Lab 5 (see below) into C-code without using any assembly code except for moving data into register (use inline assembly for such task). Use variables and move the function call as necessary. The programmer's intentioned of the C-code should be the same as the assembly code. Translate the following: loop: add r0, r0, #1 cmp r0, #5 bne loop mov r5, #9 bl function1 mov r3, #12 You can use a for loop or a while loop. After you are done and get the desired result, compare the compiled assembly code with the one we have from Lab 5 and comment on the difference in terms of the type and number of instructions used. Copy your while or for loop C-code and it's assembly code and paste it into Blackboard. Lastly, we are going to include a periodic interrupt timer (PIT) into our code to generate an interrupt once every second. We'll use the built-in ConfigTools in MCUXpresso for ease of implementation. The ConfigTools allow us to setup components of the processor and the microcontroller board in a quick and fast manner instead of manually coding all the necessary settings. Go to \"ConfigTools > Peripherals\" from the top menu. In the \"Components\" tab, Under \"Peripheral drivers (Device specific)\" add the \"PIT\" configuration components. Under the PIT settings, uncheck \"start channel\". Leave everything default so the setting page should look like this: Figure 6.2 PIT settings Once confirmed, click \"Update Code\" at the top menu button bar and click yes when prompted. The peripherals.c and peripherals.h will not be updated accordingly to include the timer interrupt settings. Next, we'll need to add some code for the interrupt handler and to start the interrupt. Paste the following handler code into your program. void PIT_CHANNEL_0_IRQHANDLER(void) /*ISR to process PIT channel 0 interrupts*/ { PIT_ClearStatusFlags(PIT, PIT_CHANNEL_0, kPIT_TimerFlag); //clear PIT channel 0 interrupt status flag PRINTF(\"*\\r\\n\"); } Then use the following code to start the PIT in your main function. You can put it at the beginning of main after all the initialization or just before the empty while loop. PIT_StartTimer(PIT_PERIPHERAL, PIT_CHANNEL_0); Build and debug. Open a serial monitor to see the serial output. Let the program run and you should see an \"*\" being printed every second. Verify with a watch that the output is once per second. Take a screenshot of your serial monitor output and paste it into blackboard.","title":"Procedures"},{"location":"seh500/lab6/#post-lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Answer all the questions in the lab on Blackboard. Modify your code from Step 16 so instead of printing \"*\" every second (using your timer interrupt function), print a statement that display the number of minutes and seconds since the timer started. Paste your code and a screenshot of the output into blackboard.","title":"Post-Lab Questions"},{"location":"seh500/lab6/#reference","text":"[1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Reference"},{"location":"seh500/lab7/","text":"Lab 7 : GPIO and Interrupt Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) Documentation of the Freedom K64 and K66 board and it's microcontroller can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) In our labs so far, we've been programming the processor directly using assembly language. In this lab, we'll explore combining assembly language with C programming language and how to use them interchangeablely in a program. Freedom Board Tricolour LED The Tricolour LED connections on the Freedom K64 board can be found in the FRDM-K64F Freedom Module User\u2019s Guide Section 10. Red : Port B Pin 22 (PTB22) Green : Port E Pin 26 (PTE26) Blue : Port B Pin 21 (PTB21) Figure 7.1 Tricolour LED connection and schematics If you are using the Freedom K66F board , the pin configurations is difference. Refer to the FRDM-K66F Freedom Module User\u2019s Guide Section 11 for pin configuration. Red : Port C Pin 9 (PTC9) Green : Port E Pin 6 (PTE6) Blue : Port A Pin 11 (PTA11) Freedom Board Push Button Switches The Push Button Switches connections on the Freedom K64 board can be found in the FRDM-K64F Freedom Module User\u2019s Guide Section 13. SW2 : Port C Pin 6 (PTC6) SW3 : Port A Pin 4 (PTA4) Figure 7.2 Buttons connection If you are using the Freedom K66F board , the pin configurations is difference. Refer to the FRDM-K66F Freedom Module User\u2019s Guide Section 14 for pin configuration. SW2 : Port D Pin 11 (PTD11) SW3 : Port A Pin 10 (PTA10) Procedures Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, similar to the previous lab, also select \"pit\" as one of the driver. Rename the project then leave all other settings as default. First, we'll setup the GPIO for the LED output using assembly code. Create a file called function.s in the source folder. Write the following code to it. In the code, create three functions, one for setting up the pins as GPIO output and the other for turning the LED on and off. If you are using the Freedom K66F board, the pin configurations is difference. Read the lab manual carefully and refer to the K66 documentation as necessary for pin configuration. .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .text @ put code in the code section .global setup @ declare as a global variable .type setup, %function @ set to function type setup: ldr r1, =0x40048038 @ System Clock Gate Control Register 5 (SIM_SCGC5) ldr r0, [r1] @ read current register value orr r0, r0, #(1<<10) @ enable clock for port B (bit 10) @ orr r0, r0, #(1<<11) @ For K66, red LED is at port C (bit 11) str r0, [r1] @ apply the new settings ldr r1, =0x4004A058 @ PTB22 Pin Control Register (PORTB_PCR22) @ldr r1, =0x4004B024 @ For K66, PTC9 Pin Control Register (PORTC_PCR9) mov r0, #0x00000100 @ set pin to GPIO mode str r0, [r1] @ apply the new settings ldr r1, =0x400FF054 @ GPIOB Port Data Direction Register (GPIOB_PDDR) @ldr r1, =0x400FF094 @ For K66, GPIOC Port Data Direction Register (GPIOC_PDDR) mov r0, #(1<<22) @ set pin 22 to output mode @mov r0, #(1<<9) @ For K66, set pin 9 to output mode str r0, [r1] @ apply the new settings bx lr .global func_led_on @ declare as a global variable .type func_led_on, %function @ set to function type func_led_on: ldr r1, =0x400FF040 @ GPIOB Port Data Output Register (GPIOB_PDOR) @ldr r1, =0x400FF080 @ For K66, GPIOC Port Data Output Register (GPIOC_PDOR) mov r0, #0 @ set output to LOW, LED on str r0, [r1] @ apply settings bx lr .global func_led_off @ declare as a global variable .type func_led_off, %function @ set to function type func_led_off: ldr r1, =0x400FF040 @ GPIOB Port Data Output Register (GPIOB_PDOR) @ldr r1, =0x400FF080 @ For K66, GPIOC Port Data Output Register (GPIOC_PDOR) mov r0, #(1<<22) @ set pin 22 output to HIGH, LED off @mov r0, #(1<<9) @ For K66, set pin 9 output to HIGH, LED off str r0, [r1] @ apply settings bx lr If you are using the Freedom K66F board, the pin configurations is difference. Read the lab manual carefully and refer to the K66 documentation as necessary for pin configuration. Code Explained The ARM Cortex M4 has been designed with gates to disable the clock to regions of the processor and therefore reduce the dynamic power that is consumed the logic local to the clock gate. By default, the clock gates to General Purpose Input/Output (GPIO) ports are disabled. In order to use the Red LED at Port B Pin 22, we need to enable the Port B clock gate. ldr r1, =0x40048038 @ System Clock Gate Control Register 5 (SIM_SCGC5) ldr r0, [r1] @ read current register value orr r0, r0, #(1<<10) @ enable clock for port B (bit 10) @ orr r0, r0, #(1<<11) @ For K66, red LED is at port C (bit 11) str r0, [r1] @ apply the new settings The System Clock Gate Control Register 5 (SIM_SCGC5) stores all the clock gate setting for the GPIO modules. Details of the register can be found in the Kinetis K64 Reference Manual Section 12.2.12. We'll first read the current control settings from SIM_SCGC5 at address 0x40048038. Once the current value is read, we'll change the value for bit 10 to enable clock for port B using the orr instruction. For K66, the red LED is at port C so bit 11 should be enabled instead. Refer to the Kinetis K66 Reference Manual Section 13.2.15. After the value is updated, store the new settings to the control register. ldr r1, =0x4004A058 @ PTB22 Pin Control Register (PORTB_PCR22) @ldr r1, =0x4004B024 @ For K66, PTC9 Pin Control Register (PORTC_PCR9) mov r0, #(0b001<<8) @ set pin to GPIO mode str r0, [r1] @ apply the new settings Next, we'll need to set the red LED pin to GPIO mode so the microcontroller will connect the pin to input/output circuitary. The Pin Control Register (PCR) (PORTB_PCR22) at address 0x4004A058 controls the settings for Port B Pin 22. Refer to the Kinetis K64 Reference Manual Section 11.5.1 for PCR details and Section 11.5 for PORT memory map. For K66, (PORTC_PCR9) is at address 0x4004B024 . Refer to the Kinetis K66 Reference Manual Section 12.5.1 for PCR details and Section 12.5 for PORT memory map. We need to set Pin MUX Control (bit 8-10) to GPIO 0b001 . Since PORTB_PCR22 will only affect Port B Pin 22, we can overwrite the entire setting to ensure the pin will only operate in GPIO mode by storing the new settings as 0x00000100 . ldr r1, =0x400FF054 @ GPIOB Port Data Direction Register (GPIOB_PDDR) @ldr r1, =0x400FF094 @ For K66, GPIOC Port Data Direction Register (GPIOC_PDDR) mov r0, #(1<<22) @ set pin 22 to output mode @mov r0, #(1<<9) @ For K66, set pin 9 to output mode str r0, [r1] @ apply the new settings Lastly, in order for the microcontroller to know how to handle the GPIO pin, we need to set the signal flow of the pin as either input or output. The GPIOB Port Data Direction Register (PDDR) (GPIOB_PDDR) at address 0x400FF054 control such settings and we need to set bit 22 for pin 22 to 1 so it's configured as an output pin. The circuitary for a pin in input mode and output mode is not the same so they must be configured properly. Refer to the Kinetis K64 Reference Manual Section 55.2.6 for GPIO PDDR details and Section 55.2 for GPIO memory map. For K66, (GPIOC_PDDR) is at address 0x400FF094 . Refer to the Kinetis K66 Reference Manual Section 63.3.6 for GPIO PDDR details and Section 63.3 for GPIO memory map. ldr r1, =0x400FF040 @ GPIOB Port Data Output Register (GPIOB_PDOR) @ldr r1, =0x400FF080 @ For K66, GPIOC Port Data Output Register (GPIOC_PDOR) mov r0, #(1<<22) @ set pin 22 output to HIGH, LED off @mov r0, #(1<<9) @ For K66, set pin 9 output to HIGH, LED off str r0, [r1] @ apply settings To control the power output of each pin, we need to set the output setting of the pin to HIGH. This can be set using the GPIOB Port Data Output Register (PDOR) (GPIOB_PDOR) at address 0x400FF040 . For the Freedom board, the LED circuit is connected so a logic level of LOW will turn the LED on and HIGH will turn the LED off. Therefore, we'll set bit 22 for pin 22 to 1 or 0 depending on how we want to control the LED. Refer to the Kinetis K64 Reference Manual Section 55.2.1 for GPIO PDOR details and Section 55.2 for GPIO memory map. For K66, (GPIOC_PDOR) is at address 0x400FF080 . Refer to the Kinetis K66 Reference Manual Section 63.3.1 for GPIO PDOR details and Section 63.3 for GPIO memory map. Next, place a setup() , func_led_on() and func_led_off() function prototype at the top of your C-code and function calls before the while loop in your main function. You can also comment out or remove the print statement. void setup(); void func_led_on(); void func_led_off(); Add the following before the while loop: setup(); func_led_on(); func_led_off(); Build and run your code in debug mode. Step Over (F6) the initial functions until you get to the setup function. Then Step Into (F5) the setup() , func_led_on() , and func_led_off() functions. You should see the debug cursor jump into the assembly code. Keep stepping through the code and the RED led should turn on and off. Next, we'll setup an interrupt with the onboard switch to control the LED. To do that, we'll use the ConfigTools to help setup the interrupt as setting it up using assembly require knowledge of the vector table and interrupt register (a more lengthy process). Right click on your project in the Project Explorer and Open the MCUXpresso Config Tools > Open Tools Overview windows. Under Pins > Functional groups, enable: BOARD_InitPins BOARD_InitBUTTONsPins BOARD_InitLEDsPins BOARD_InitDEBUG_UARTPins By clicking on the flag to ensure there's a check mark. Under Peripherals > Functional groups, enable: BOARD_InitPeripherals Close and Update Code. Figure 7.3 Next, open the ConfigTools > Peripherals Windows or right-click on the project from the Project Explorer Project > MCUXpresso Config Tools > Open Perripheral . On the left hand side, go to the \"Peripherals\" tab. Check GPIOC for SW2 at Port C Pin 6 (PTC6). While prompted to \"Add Configuration Component Instance\", select the GPIO component with General Purpose Input/Output (GPIO) in the component description. If you've previously added another component, right click on GPIOC and remover them. Check Enable interrupt request. Afterward, check \"Enable custom handler name\" and we'll name it: SW2_GPIOC_IRQHANDLER. Once done, click \"Update Code\" near the top. Figure 7.4 For Freedom K66, SW2 is at Port D Pin 11 (PTD11), ie. GPIOD and use SW2_GPIOD_IRQHANDLER as the function name. Repeat the last step for switch 3 at Port A Pin 4 (PTA4), ie. GPIOA. Name the handler as SW3_GPIOA_IRQHANDLER. Lastly, add the following two functions at the end of your C-code (outside of your main function) and comment out or remove the function call: setup() , func_led_on() , func_led_off() to the assembly code. We'll use he built in LED function from MCUXpresso to control the LED. void SW2_GPIOC_IRQHANDLER(void) //Interrupt Service Routine for SW2 { // clear interrupt flag set by button SW2 connected to pin PTC6 GPIO_PortClearInterruptFlags(GPIOC, 1U << 6U); LED_RED_ON(); // turn ON RED LED } void SW3_GPIOA_IRQHANDLER(void) //Interrupt Service Routine for SW3 { // clear interrupt flag set by button SW3 connected to pin PTA4 GPIO_PortClearInterruptFlags(GPIOA, 1U << 4U); LED_RED_OFF(); // turn OFF RED LED } For K66: void SW2_GPIOD_IRQHANDLER(void) //Interrupt Service Routine for SW2 { // clear interrupt flag set by button SW2 connected to pin PTD11 GPIO_PortClearInterruptFlags(GPIOD 1U << 11U); LED_RED_ON(); // turn ON RED LED } void SW3_GPIOA_IRQHANDLER(void) //Interrupt Service Routine for SW3 { // clear interrupt flag set by button SW3 connected to pin PTA10 GPIO_PortClearInterruptFlags(GPIOA, 1U << 10U); LED_RED_OFF(); // turn OFF RED LED } Run your code and the LED should turn on and off as you press the buttons. Post-Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Using the Reference Manual of the processor on your Freedom board, find address of the Pin Control Register (PCR), Port Data Direction Register (PDDR), and Port Data Output Register (PDOR) for the Green LED and Blue LED. Modify the example assembly code so all three colours of the LED will turn on and off at the same time. Paste your code and a photo of the LED turned into blackboard. RGB turned on together should be a white light. Implement the same timer interrupt from Lab 6 and use it to turn the LED (any colour) on and off at regular interval. Paste your code into blackboard. Reference [1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Lab 7 : GPIO and Interrupt"},{"location":"seh500/lab7/#lab-7-gpio-and-interrupt","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 7 : GPIO and Interrupt"},{"location":"seh500/lab7/#introduction","text":"Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) Documentation of the Freedom K64 and K66 board and it's microcontroller can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) In our labs so far, we've been programming the processor directly using assembly language. In this lab, we'll explore combining assembly language with C programming language and how to use them interchangeablely in a program.","title":"Introduction"},{"location":"seh500/lab7/#freedom-board-tricolour-led","text":"The Tricolour LED connections on the Freedom K64 board can be found in the FRDM-K64F Freedom Module User\u2019s Guide Section 10. Red : Port B Pin 22 (PTB22) Green : Port E Pin 26 (PTE26) Blue : Port B Pin 21 (PTB21) Figure 7.1 Tricolour LED connection and schematics If you are using the Freedom K66F board , the pin configurations is difference. Refer to the FRDM-K66F Freedom Module User\u2019s Guide Section 11 for pin configuration. Red : Port C Pin 9 (PTC9) Green : Port E Pin 6 (PTE6) Blue : Port A Pin 11 (PTA11)","title":"Freedom Board Tricolour LED"},{"location":"seh500/lab7/#freedom-board-push-button-switches","text":"The Push Button Switches connections on the Freedom K64 board can be found in the FRDM-K64F Freedom Module User\u2019s Guide Section 13. SW2 : Port C Pin 6 (PTC6) SW3 : Port A Pin 4 (PTA4) Figure 7.2 Buttons connection If you are using the Freedom K66F board , the pin configurations is difference. Refer to the FRDM-K66F Freedom Module User\u2019s Guide Section 14 for pin configuration. SW2 : Port D Pin 11 (PTD11) SW3 : Port A Pin 10 (PTA10)","title":"Freedom Board Push Button Switches"},{"location":"seh500/lab7/#procedures","text":"Open MCUXpresso then start a new C/C++ project based on the Freedom board model that you have. In the new project configuration, similar to the previous lab, also select \"pit\" as one of the driver. Rename the project then leave all other settings as default. First, we'll setup the GPIO for the LED output using assembly code. Create a file called function.s in the source folder. Write the following code to it. In the code, create three functions, one for setting up the pins as GPIO output and the other for turning the LED on and off. If you are using the Freedom K66F board, the pin configurations is difference. Read the lab manual carefully and refer to the K66 documentation as necessary for pin configuration. .syntax unified @ unified syntax used .cpu cortex-m4 @ cpu is cortex-m4 .thumb @ use thumb encoding .text @ put code in the code section .global setup @ declare as a global variable .type setup, %function @ set to function type setup: ldr r1, =0x40048038 @ System Clock Gate Control Register 5 (SIM_SCGC5) ldr r0, [r1] @ read current register value orr r0, r0, #(1<<10) @ enable clock for port B (bit 10) @ orr r0, r0, #(1<<11) @ For K66, red LED is at port C (bit 11) str r0, [r1] @ apply the new settings ldr r1, =0x4004A058 @ PTB22 Pin Control Register (PORTB_PCR22) @ldr r1, =0x4004B024 @ For K66, PTC9 Pin Control Register (PORTC_PCR9) mov r0, #0x00000100 @ set pin to GPIO mode str r0, [r1] @ apply the new settings ldr r1, =0x400FF054 @ GPIOB Port Data Direction Register (GPIOB_PDDR) @ldr r1, =0x400FF094 @ For K66, GPIOC Port Data Direction Register (GPIOC_PDDR) mov r0, #(1<<22) @ set pin 22 to output mode @mov r0, #(1<<9) @ For K66, set pin 9 to output mode str r0, [r1] @ apply the new settings bx lr .global func_led_on @ declare as a global variable .type func_led_on, %function @ set to function type func_led_on: ldr r1, =0x400FF040 @ GPIOB Port Data Output Register (GPIOB_PDOR) @ldr r1, =0x400FF080 @ For K66, GPIOC Port Data Output Register (GPIOC_PDOR) mov r0, #0 @ set output to LOW, LED on str r0, [r1] @ apply settings bx lr .global func_led_off @ declare as a global variable .type func_led_off, %function @ set to function type func_led_off: ldr r1, =0x400FF040 @ GPIOB Port Data Output Register (GPIOB_PDOR) @ldr r1, =0x400FF080 @ For K66, GPIOC Port Data Output Register (GPIOC_PDOR) mov r0, #(1<<22) @ set pin 22 output to HIGH, LED off @mov r0, #(1<<9) @ For K66, set pin 9 output to HIGH, LED off str r0, [r1] @ apply settings bx lr If you are using the Freedom K66F board, the pin configurations is difference. Read the lab manual carefully and refer to the K66 documentation as necessary for pin configuration.","title":"Procedures"},{"location":"seh500/lab7/#code-explained","text":"The ARM Cortex M4 has been designed with gates to disable the clock to regions of the processor and therefore reduce the dynamic power that is consumed the logic local to the clock gate. By default, the clock gates to General Purpose Input/Output (GPIO) ports are disabled. In order to use the Red LED at Port B Pin 22, we need to enable the Port B clock gate. ldr r1, =0x40048038 @ System Clock Gate Control Register 5 (SIM_SCGC5) ldr r0, [r1] @ read current register value orr r0, r0, #(1<<10) @ enable clock for port B (bit 10) @ orr r0, r0, #(1<<11) @ For K66, red LED is at port C (bit 11) str r0, [r1] @ apply the new settings The System Clock Gate Control Register 5 (SIM_SCGC5) stores all the clock gate setting for the GPIO modules. Details of the register can be found in the Kinetis K64 Reference Manual Section 12.2.12. We'll first read the current control settings from SIM_SCGC5 at address 0x40048038. Once the current value is read, we'll change the value for bit 10 to enable clock for port B using the orr instruction. For K66, the red LED is at port C so bit 11 should be enabled instead. Refer to the Kinetis K66 Reference Manual Section 13.2.15. After the value is updated, store the new settings to the control register. ldr r1, =0x4004A058 @ PTB22 Pin Control Register (PORTB_PCR22) @ldr r1, =0x4004B024 @ For K66, PTC9 Pin Control Register (PORTC_PCR9) mov r0, #(0b001<<8) @ set pin to GPIO mode str r0, [r1] @ apply the new settings Next, we'll need to set the red LED pin to GPIO mode so the microcontroller will connect the pin to input/output circuitary. The Pin Control Register (PCR) (PORTB_PCR22) at address 0x4004A058 controls the settings for Port B Pin 22. Refer to the Kinetis K64 Reference Manual Section 11.5.1 for PCR details and Section 11.5 for PORT memory map. For K66, (PORTC_PCR9) is at address 0x4004B024 . Refer to the Kinetis K66 Reference Manual Section 12.5.1 for PCR details and Section 12.5 for PORT memory map. We need to set Pin MUX Control (bit 8-10) to GPIO 0b001 . Since PORTB_PCR22 will only affect Port B Pin 22, we can overwrite the entire setting to ensure the pin will only operate in GPIO mode by storing the new settings as 0x00000100 . ldr r1, =0x400FF054 @ GPIOB Port Data Direction Register (GPIOB_PDDR) @ldr r1, =0x400FF094 @ For K66, GPIOC Port Data Direction Register (GPIOC_PDDR) mov r0, #(1<<22) @ set pin 22 to output mode @mov r0, #(1<<9) @ For K66, set pin 9 to output mode str r0, [r1] @ apply the new settings Lastly, in order for the microcontroller to know how to handle the GPIO pin, we need to set the signal flow of the pin as either input or output. The GPIOB Port Data Direction Register (PDDR) (GPIOB_PDDR) at address 0x400FF054 control such settings and we need to set bit 22 for pin 22 to 1 so it's configured as an output pin. The circuitary for a pin in input mode and output mode is not the same so they must be configured properly. Refer to the Kinetis K64 Reference Manual Section 55.2.6 for GPIO PDDR details and Section 55.2 for GPIO memory map. For K66, (GPIOC_PDDR) is at address 0x400FF094 . Refer to the Kinetis K66 Reference Manual Section 63.3.6 for GPIO PDDR details and Section 63.3 for GPIO memory map. ldr r1, =0x400FF040 @ GPIOB Port Data Output Register (GPIOB_PDOR) @ldr r1, =0x400FF080 @ For K66, GPIOC Port Data Output Register (GPIOC_PDOR) mov r0, #(1<<22) @ set pin 22 output to HIGH, LED off @mov r0, #(1<<9) @ For K66, set pin 9 output to HIGH, LED off str r0, [r1] @ apply settings To control the power output of each pin, we need to set the output setting of the pin to HIGH. This can be set using the GPIOB Port Data Output Register (PDOR) (GPIOB_PDOR) at address 0x400FF040 . For the Freedom board, the LED circuit is connected so a logic level of LOW will turn the LED on and HIGH will turn the LED off. Therefore, we'll set bit 22 for pin 22 to 1 or 0 depending on how we want to control the LED. Refer to the Kinetis K64 Reference Manual Section 55.2.1 for GPIO PDOR details and Section 55.2 for GPIO memory map. For K66, (GPIOC_PDOR) is at address 0x400FF080 . Refer to the Kinetis K66 Reference Manual Section 63.3.1 for GPIO PDOR details and Section 63.3 for GPIO memory map. Next, place a setup() , func_led_on() and func_led_off() function prototype at the top of your C-code and function calls before the while loop in your main function. You can also comment out or remove the print statement. void setup(); void func_led_on(); void func_led_off(); Add the following before the while loop: setup(); func_led_on(); func_led_off(); Build and run your code in debug mode. Step Over (F6) the initial functions until you get to the setup function. Then Step Into (F5) the setup() , func_led_on() , and func_led_off() functions. You should see the debug cursor jump into the assembly code. Keep stepping through the code and the RED led should turn on and off. Next, we'll setup an interrupt with the onboard switch to control the LED. To do that, we'll use the ConfigTools to help setup the interrupt as setting it up using assembly require knowledge of the vector table and interrupt register (a more lengthy process). Right click on your project in the Project Explorer and Open the MCUXpresso Config Tools > Open Tools Overview windows. Under Pins > Functional groups, enable: BOARD_InitPins BOARD_InitBUTTONsPins BOARD_InitLEDsPins BOARD_InitDEBUG_UARTPins By clicking on the flag to ensure there's a check mark. Under Peripherals > Functional groups, enable: BOARD_InitPeripherals Close and Update Code. Figure 7.3 Next, open the ConfigTools > Peripherals Windows or right-click on the project from the Project Explorer Project > MCUXpresso Config Tools > Open Perripheral . On the left hand side, go to the \"Peripherals\" tab. Check GPIOC for SW2 at Port C Pin 6 (PTC6). While prompted to \"Add Configuration Component Instance\", select the GPIO component with General Purpose Input/Output (GPIO) in the component description. If you've previously added another component, right click on GPIOC and remover them. Check Enable interrupt request. Afterward, check \"Enable custom handler name\" and we'll name it: SW2_GPIOC_IRQHANDLER. Once done, click \"Update Code\" near the top. Figure 7.4 For Freedom K66, SW2 is at Port D Pin 11 (PTD11), ie. GPIOD and use SW2_GPIOD_IRQHANDLER as the function name. Repeat the last step for switch 3 at Port A Pin 4 (PTA4), ie. GPIOA. Name the handler as SW3_GPIOA_IRQHANDLER. Lastly, add the following two functions at the end of your C-code (outside of your main function) and comment out or remove the function call: setup() , func_led_on() , func_led_off() to the assembly code. We'll use he built in LED function from MCUXpresso to control the LED. void SW2_GPIOC_IRQHANDLER(void) //Interrupt Service Routine for SW2 { // clear interrupt flag set by button SW2 connected to pin PTC6 GPIO_PortClearInterruptFlags(GPIOC, 1U << 6U); LED_RED_ON(); // turn ON RED LED } void SW3_GPIOA_IRQHANDLER(void) //Interrupt Service Routine for SW3 { // clear interrupt flag set by button SW3 connected to pin PTA4 GPIO_PortClearInterruptFlags(GPIOA, 1U << 4U); LED_RED_OFF(); // turn OFF RED LED } For K66: void SW2_GPIOD_IRQHANDLER(void) //Interrupt Service Routine for SW2 { // clear interrupt flag set by button SW2 connected to pin PTD11 GPIO_PortClearInterruptFlags(GPIOD 1U << 11U); LED_RED_ON(); // turn ON RED LED } void SW3_GPIOA_IRQHANDLER(void) //Interrupt Service Routine for SW3 { // clear interrupt flag set by button SW3 connected to pin PTA10 GPIO_PortClearInterruptFlags(GPIOA, 1U << 10U); LED_RED_OFF(); // turn OFF RED LED } Run your code and the LED should turn on and off as you press the buttons.","title":"Code Explained"},{"location":"seh500/lab7/#post-lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. Using the Reference Manual of the processor on your Freedom board, find address of the Pin Control Register (PCR), Port Data Direction Register (PDDR), and Port Data Output Register (PDOR) for the Green LED and Blue LED. Modify the example assembly code so all three colours of the LED will turn on and off at the same time. Paste your code and a photo of the LED turned into blackboard. RGB turned on together should be a white light. Implement the same timer interrupt from Lab 6 and use it to turn the LED (any colour) on and off at regular interval. Paste your code into blackboard.","title":"Post-Lab Questions"},{"location":"seh500/lab7/#reference","text":"[1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Reference"},{"location":"seh500/lab8/","text":"Lab 8 : GPIO Input and Code Optimization Seneca Polytechnic SEH500 Microprocessors and Computer Architecture Introduction Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) Documentation of the Freedom K64 and K66 board and it's microcontroller can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) In this last lab of the course, we'll use program in assembly language and C programming language interchangeablely and explore the advantage and disadvantage of using a high-level language. Procedures Reading Input using Polling First, let's setup out project in a similar manner as Lab 7. Create a new project ensure the following driver is available in addition to the default settings. pit If there are missing driver and SDK components from your project, you may add them at any time by clicking Manage SDK Component at the top of the project explorer or Right click on the project > SDK Management > Manage SDK Component . Use the ConfigTools > Config Tools Overview or right click on your project in the Project Explorer and Open the MCUXpresso Config Tools > Open Tools Overview windows to enable he following: Under Pins > Functional groups, ensure the followings are enabled: BOARD_InitPins BOARD_InitBUTTONsPins BOARD_InitLEDsPins By enabling the above, you are updating the clock gate and pin settings so their respective port can be used. Remember to click Update Code once done. Leave all the BOARD_Init... function in your main.c as is then replace the remaining codes with the following: /* setup the switch pin config as output per fsl_gpio.h */ gpio_pin_config_t sw_config = { kGPIO_DigitalInput, 0, }; /* setup the led pin config as output per fsl_gpio.h */ gpio_pin_config_t led_config = { kGPIO_DigitalOutput, 0, }; /* setup the switch and led pins as per fsl_gpio.h */ /* the gpio and pin keyword can be found in board.h */ GPIO_PinInit(BOARD_SW3_GPIO, BOARD_SW3_GPIO_PIN, &sw_config); GPIO_PinInit(BOARD_LED_RED_GPIO, BOARD_LED_RED_GPIO_PIN, &led_config); LED_RED_OFF(); // ensure the red led is off PRINTF(\"\\r\\n --- Program Start --- \\r\\n\"); while(1) { /* we'll use polling instead of interrupt to listen for button press (LOW) */ if (GPIO_PinRead(BOARD_SW3_GPIO, BOARD_SW3_GPIO_PIN) == 0) { // button pressed LED_RED_ON(); delay(); // delay so we can see the LED turn on LED_RED_OFF(); } } return 0 ; Also add the following delay() function to your code: void delay(void) { volatile uint32_t i = 0; /* at 120MHz, 120,000,000 instructions = 1s */ /* for K66 at 180MHz, 180,000,000 instructions = 1s */ for (i = 0; i < 120000000; ++i) { __asm(\"NOP\"); /* delay */ } } Now that we know how to program the K64 (or K66) processor using assembly, we can use some of the built-in functions and keywords from the SDK to help us with programming the board. There are no compenhensive manual on all the helper functions and keywords aviable. The best place to look is their respecitve library file. This also allow us to write one set of code for multiple processors as long as the helper functions and keywords are available. Build and Debug, then Run he code using Resume (F8) . Press switch 2 and see the red LED turn on and off. What happens when you press the switch when the LED is ON? How is the approach of using polling to read input differ then using interrupt? Which one is better? Submit your answer on Blackboard. Code Optimization In class, we discussed various ways on code optimizing. One key thing to remember is shorter code does not means faster code. A Taylor Series expansion is a way of finding the approximiate value of a function. The Taylor Series expansion of a Sine function is given as follow: sin(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + ... Each term is generalized to: \\textrm{Term}_n = (-1)^n \\frac{x^{(2n + 1)}}{(2n + 1)!} Go to ConfigTools > Peripherals from the top menu. In the \"Components\" tab, Under \"Peripheral drivers (Device specific)\" add the \"PIT\" configuration components. Set up the PIT at 1us (one microsecond interval). Add a Global variable loop_timer and the PIT ISR at the end of your code. We'll use them to measure execution time. volatile static long timer_counter = 0; PIT ISR: void PIT_CHANNEL_0_IRQHANDLER(void) /*ISR to process PIT channel 0 interrupts*/ { PIT_ClearStatusFlags(PIT, PIT_CHANNEL_0, kPIT_TimerFlag); //clear PIT channel 0 interrupt status flag timer_counter++; } Next, we have a few helper functions to help calculate the Taylor Series expansion. /* factorial calculation */ int factorial(int num) { int result = 1; int i = 0; for (i = 1; i <= num; i++) { result *= i; } return result; } /* power calculation */ float pow(float base, int exp) { float result = 1.0; int i = 0; for (i = 0; i < exp; i++) { result *= base; } return result; } /* each taylor series term */ float taylor_term(float x, int n) { float result = 0.0; int degree = n * 2 + 1; result = pow(x, degree) / factorial(degree); result *= (n % 2 == 0 ? 1.0 : -1.0); return result; } /* taylor series approximation */ float sin_taylor(float x) { float result = 0.0; int degree = 11; int terms = (degree + 1) / 2; int i = 0; for (i = 0; i < terms; i++) { result += taylor_term(x, i); } return result; } Next, change all of the from the printf statement onward to: float x = 0.0; float sin_x = 0.0; const float pi = 3.1416; int xs[4000] = {0}; int sin_xs[4000] = {0}; int end = 0; int i = 0; long elasped_time = 0; PIT_StartTimer(PIT_PERIPHERAL, PIT_CHANNEL_0); while(1) { if (GPIO_PinRead(BOARD_SW3_GPIO, BOARD_SW3_GPIO_PIN) == 0) { LED_RED_ON(); PRINTF(\"\\r\\n --- SIN Calculation Start --- \\r\\n\"); x = 0.0; i = 0; timer_counter = 0; // reset timer counter and start while (x < pi) { sin_x = sin_taylor(x); // calculate sin(x) using Taylor Series /* save everything as integer of (x1000) to make it faster for print*/ xs[i] = (int)(x*1000.0); sin_xs[i] = (int)(sin_x*1000.0); i++; x += (pi / 1000.0); } elasped_time = timer_counter; // timer end end = i; for (i = 0; i < end; i++) { PRINTF(\"x = %d, sin_x = %d\\r\\n\", xs[i], sin_xs[i]); } PRINTF(\"\\r\\n --- SIN Calculation End --- \\r\\n\"); PRINTF(\"\\r\\n --- time = %ld --- \\r\\n\", elasped_time); LED_RED_OFF(); } } return 0; Build and Debug, then Run he code using Resume (F8) . Press switch 2 and see the red LED turn on and off. Everytime when you press switch 2, sin(x) calculation from 0 to \\pi are calculated at one-thousand intervals. If you open the Serial Monitor (Terminal) , it'll say the execution took about 100ms (or 70ms for K66). The output should be similar to this: ... x = 3122, sin_x = 18 x = 3125, sin_x = 15 x = 3129, sin_x = 12 x = 3132, sin_x = 8 x = 3135, sin_x = 5 x = 3138, sin_x = 2 --- SIN Calculation End --- --- time = 109995 --- The above value is obtained using the K64F processor. If you are using a K66F processor, it will be around 70,000 us. Post-Lab Questions Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. How is the approach of using polling to read input differ then using interrupt? Which one is better? Submit your answer on Blackboard. The Taylor Series expansion code is written in a manner that's modular and somewhat easy to understand but not in an optimized manner in terms of fast execution. Using techniques that you've learned in class and your knowledge of assembly instruction, modify the code between timer start and timer end, including the helper function and any related variables, so there's at least 20% improvement in speed to execute the code. For every change and optimization you made, provide a brief reason on how it improve execution time. Hints and limiations: You may modify the code in C or re-write the code in assembly or use inline assembly You may add or remove any variables or functions The degree of the approximation is fixed at 11 (ie. it does not need to be a variable) You may perform pre-calculation as you see fit sin(x) must be calculated inside the while loop using taylor series expansion, ie. Term1 + Term2 + ... You cannot use a SIN function lookup table Paste your code, explanation of every changes, and a screenshot of the terminal output before and after optimization on blackboard. The output value after optimization should be very similar to the value after optimization. Challenge: Achieve at least 50% improvement in speed. Reference [1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Lab 8 : GPIO Input and Code Optimization"},{"location":"seh500/lab8/#lab-8-gpio-input-and-code-optimization","text":"Seneca Polytechnic SEH500 Microprocessors and Computer Architecture","title":"Lab 8 : GPIO Input and Code Optimization"},{"location":"seh500/lab8/#introduction","text":"Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of processor instructions ARMv7-M Architecture Reference Manual ( PDF ) Documentation of the Freedom K64 and K66 board and it's microcontroller can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) In this last lab of the course, we'll use program in assembly language and C programming language interchangeablely and explore the advantage and disadvantage of using a high-level language.","title":"Introduction"},{"location":"seh500/lab8/#procedures","text":"","title":"Procedures"},{"location":"seh500/lab8/#reading-input-using-polling","text":"First, let's setup out project in a similar manner as Lab 7. Create a new project ensure the following driver is available in addition to the default settings. pit If there are missing driver and SDK components from your project, you may add them at any time by clicking Manage SDK Component at the top of the project explorer or Right click on the project > SDK Management > Manage SDK Component . Use the ConfigTools > Config Tools Overview or right click on your project in the Project Explorer and Open the MCUXpresso Config Tools > Open Tools Overview windows to enable he following: Under Pins > Functional groups, ensure the followings are enabled: BOARD_InitPins BOARD_InitBUTTONsPins BOARD_InitLEDsPins By enabling the above, you are updating the clock gate and pin settings so their respective port can be used. Remember to click Update Code once done. Leave all the BOARD_Init... function in your main.c as is then replace the remaining codes with the following: /* setup the switch pin config as output per fsl_gpio.h */ gpio_pin_config_t sw_config = { kGPIO_DigitalInput, 0, }; /* setup the led pin config as output per fsl_gpio.h */ gpio_pin_config_t led_config = { kGPIO_DigitalOutput, 0, }; /* setup the switch and led pins as per fsl_gpio.h */ /* the gpio and pin keyword can be found in board.h */ GPIO_PinInit(BOARD_SW3_GPIO, BOARD_SW3_GPIO_PIN, &sw_config); GPIO_PinInit(BOARD_LED_RED_GPIO, BOARD_LED_RED_GPIO_PIN, &led_config); LED_RED_OFF(); // ensure the red led is off PRINTF(\"\\r\\n --- Program Start --- \\r\\n\"); while(1) { /* we'll use polling instead of interrupt to listen for button press (LOW) */ if (GPIO_PinRead(BOARD_SW3_GPIO, BOARD_SW3_GPIO_PIN) == 0) { // button pressed LED_RED_ON(); delay(); // delay so we can see the LED turn on LED_RED_OFF(); } } return 0 ; Also add the following delay() function to your code: void delay(void) { volatile uint32_t i = 0; /* at 120MHz, 120,000,000 instructions = 1s */ /* for K66 at 180MHz, 180,000,000 instructions = 1s */ for (i = 0; i < 120000000; ++i) { __asm(\"NOP\"); /* delay */ } } Now that we know how to program the K64 (or K66) processor using assembly, we can use some of the built-in functions and keywords from the SDK to help us with programming the board. There are no compenhensive manual on all the helper functions and keywords aviable. The best place to look is their respecitve library file. This also allow us to write one set of code for multiple processors as long as the helper functions and keywords are available. Build and Debug, then Run he code using Resume (F8) . Press switch 2 and see the red LED turn on and off. What happens when you press the switch when the LED is ON? How is the approach of using polling to read input differ then using interrupt? Which one is better? Submit your answer on Blackboard.","title":"Reading Input using Polling"},{"location":"seh500/lab8/#code-optimization","text":"In class, we discussed various ways on code optimizing. One key thing to remember is shorter code does not means faster code. A Taylor Series expansion is a way of finding the approximiate value of a function. The Taylor Series expansion of a Sine function is given as follow: sin(x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\frac{x^7}{7!} + ... Each term is generalized to: \\textrm{Term}_n = (-1)^n \\frac{x^{(2n + 1)}}{(2n + 1)!} Go to ConfigTools > Peripherals from the top menu. In the \"Components\" tab, Under \"Peripheral drivers (Device specific)\" add the \"PIT\" configuration components. Set up the PIT at 1us (one microsecond interval). Add a Global variable loop_timer and the PIT ISR at the end of your code. We'll use them to measure execution time. volatile static long timer_counter = 0; PIT ISR: void PIT_CHANNEL_0_IRQHANDLER(void) /*ISR to process PIT channel 0 interrupts*/ { PIT_ClearStatusFlags(PIT, PIT_CHANNEL_0, kPIT_TimerFlag); //clear PIT channel 0 interrupt status flag timer_counter++; } Next, we have a few helper functions to help calculate the Taylor Series expansion. /* factorial calculation */ int factorial(int num) { int result = 1; int i = 0; for (i = 1; i <= num; i++) { result *= i; } return result; } /* power calculation */ float pow(float base, int exp) { float result = 1.0; int i = 0; for (i = 0; i < exp; i++) { result *= base; } return result; } /* each taylor series term */ float taylor_term(float x, int n) { float result = 0.0; int degree = n * 2 + 1; result = pow(x, degree) / factorial(degree); result *= (n % 2 == 0 ? 1.0 : -1.0); return result; } /* taylor series approximation */ float sin_taylor(float x) { float result = 0.0; int degree = 11; int terms = (degree + 1) / 2; int i = 0; for (i = 0; i < terms; i++) { result += taylor_term(x, i); } return result; } Next, change all of the from the printf statement onward to: float x = 0.0; float sin_x = 0.0; const float pi = 3.1416; int xs[4000] = {0}; int sin_xs[4000] = {0}; int end = 0; int i = 0; long elasped_time = 0; PIT_StartTimer(PIT_PERIPHERAL, PIT_CHANNEL_0); while(1) { if (GPIO_PinRead(BOARD_SW3_GPIO, BOARD_SW3_GPIO_PIN) == 0) { LED_RED_ON(); PRINTF(\"\\r\\n --- SIN Calculation Start --- \\r\\n\"); x = 0.0; i = 0; timer_counter = 0; // reset timer counter and start while (x < pi) { sin_x = sin_taylor(x); // calculate sin(x) using Taylor Series /* save everything as integer of (x1000) to make it faster for print*/ xs[i] = (int)(x*1000.0); sin_xs[i] = (int)(sin_x*1000.0); i++; x += (pi / 1000.0); } elasped_time = timer_counter; // timer end end = i; for (i = 0; i < end; i++) { PRINTF(\"x = %d, sin_x = %d\\r\\n\", xs[i], sin_xs[i]); } PRINTF(\"\\r\\n --- SIN Calculation End --- \\r\\n\"); PRINTF(\"\\r\\n --- time = %ld --- \\r\\n\", elasped_time); LED_RED_OFF(); } } return 0; Build and Debug, then Run he code using Resume (F8) . Press switch 2 and see the red LED turn on and off. Everytime when you press switch 2, sin(x) calculation from 0 to \\pi are calculated at one-thousand intervals. If you open the Serial Monitor (Terminal) , it'll say the execution took about 100ms (or 70ms for K66). The output should be similar to this: ... x = 3122, sin_x = 18 x = 3125, sin_x = 15 x = 3129, sin_x = 12 x = 3132, sin_x = 8 x = 3135, sin_x = 5 x = 3138, sin_x = 2 --- SIN Calculation End --- --- time = 109995 --- The above value is obtained using the K64F processor. If you are using a K66F processor, it will be around 70,000 us.","title":"Code Optimization"},{"location":"seh500/lab8/#post-lab-questions","text":"Using the skills and knowledge acquired from this lab, answer the following post-lab question(s) on Blackboard. Due one week after the lab. How is the approach of using polling to read input differ then using interrupt? Which one is better? Submit your answer on Blackboard. The Taylor Series expansion code is written in a manner that's modular and somewhat easy to understand but not in an optimized manner in terms of fast execution. Using techniques that you've learned in class and your knowledge of assembly instruction, modify the code between timer start and timer end, including the helper function and any related variables, so there's at least 20% improvement in speed to execute the code. For every change and optimization you made, provide a brief reason on how it improve execution time. Hints and limiations: You may modify the code in C or re-write the code in assembly or use inline assembly You may add or remove any variables or functions The degree of the approximation is fixed at 11 (ie. it does not need to be a variable) You may perform pre-calculation as you see fit sin(x) must be calculated inside the while loop using taylor series expansion, ie. Term1 + Term2 + ... You cannot use a SIN function lookup table Paste your code, explanation of every changes, and a screenshot of the terminal output before and after optimization on blackboard. The output value after optimization should be very similar to the value after optimization. Challenge: Achieve at least 50% improvement in speed.","title":"Post-Lab Questions"},{"location":"seh500/lab8/#reference","text":"[1] Yiu, J. (2013). The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors. (3rd ed.). Elsevier Science & Technology.","title":"Reference"},{"location":"sep600/","text":"SEP600 Lab Manual Documentation of the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) ARMv7-M Architecture Reference Manual ( PDF ) FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors by Joseph Yiu Labs: Lab Safety Lab Supplies Lab 1 : mbed OS and IDE Lab 2 : Comparator and Digital I/O Lab 3 : PWM and DAC Lab 4 : ADC and RTOS Lab 5 : Serial UART and I2C Lab 6 : LCD and Interrupt Lab 7 : Filtering","title":"SEP600 Embedded Systems"},{"location":"sep600/#sep600-lab-manual","text":"Documentation of the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) ARMv7-M Architecture Reference Manual ( PDF ) FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) The Definitive Guide to ARM\u00ae Cortex\u00ae-M3 and Cortex\u00ae-M4 Processors by Joseph Yiu Labs: Lab Safety Lab Supplies Lab 1 : mbed OS and IDE Lab 2 : Comparator and Digital I/O Lab 3 : PWM and DAC Lab 4 : ADC and RTOS Lab 5 : Serial UART and I2C Lab 6 : LCD and Interrupt Lab 7 : Filtering","title":"SEP600 Lab Manual"},{"location":"sep600/lab-safety/","text":"Lab Safety Seneca Polytechnic SEP600 Embedded Systems Objectives Review of Laboratory First Aid and Safety Procedures Emergency Contact In case of life threatening emergency: Call 911 for fire, medical, or police Then call campus security: 416-764-0911 for assistance Laboratory First Aid and Safety Procedures Lab Safety Presentation Slides","title":"Lab Safety"},{"location":"sep600/lab-safety/#lab-safety","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab Safety"},{"location":"sep600/lab-safety/#objectives","text":"Review of Laboratory First Aid and Safety Procedures","title":"Objectives"},{"location":"sep600/lab-safety/#emergency-contact","text":"In case of life threatening emergency: Call 911 for fire, medical, or police Then call campus security: 416-764-0911 for assistance","title":"Emergency Contact"},{"location":"sep600/lab-safety/#laboratory-first-aid-and-safety-procedures","text":"Lab Safety Presentation Slides","title":"Laboratory First Aid and Safety Procedures"},{"location":"sep600/lab-supplies/","text":"Lab Supplies Seneca Polytechnic SEP600 Embedded Systems You are not required to purchase the lab items from the store/supplier suggested here. You may purchase them from anywhere of your choice as long as they meet the lab requirement. Mandatory Items for SEP600 Labs Safety Glasses The safety glasses must have side shields and a top shield. ( CCOHS Reference ) Where to Buy: A similar version can be purchased from the Seneca Campus Store: Temp Lite Series Clear Safety Glasses . SEP600 Lab Components The following lab components are mandatory for you to brign to the lab for this course. Also included on the list are some of the places you can purchase the items. They can also be purchased from other major online retailers but links will not be provided as their product listing is very dynamic. Item Canada Robotix Creatron Sayal (1x) Full-size Breadboard Breadboard Breadboard Breadboard Kit (20x) Jumper Wires Wire Kit Wire Kit Breadboard Kit (5x) 100\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 330\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 1k\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 4.7k\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 10k\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (2x) 100nF 50V 20% Ceramic Capacitor 5 pcs 2 pcs (2x) 10\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 1 pc 2 pcs (2x) 100\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 1 pc 2 pcs (1x) Red 5mm LED 5pcs 10 pcs 5 pcs (1x) Potentiometer 10K with Knob 1 pc 1 pc (1x) Op-Amp LM358 or Similar 1 pc (2x) Momentary Push Button/Tactile Switch 1 pc (1x) I2C Character LCD Module or Similar 1 pc Other Optional Components Item Canada Robotix Creatron Sayal Alligator Leads 10 pcs 10 pcs 10 pcs (1x) Mini Photocell (Light Sensor) 1 pc","title":"Lab Supplies"},{"location":"sep600/lab-supplies/#lab-supplies","text":"Seneca Polytechnic SEP600 Embedded Systems You are not required to purchase the lab items from the store/supplier suggested here. You may purchase them from anywhere of your choice as long as they meet the lab requirement.","title":"Lab Supplies"},{"location":"sep600/lab-supplies/#mandatory-items-for-sep600-labs","text":"Safety Glasses The safety glasses must have side shields and a top shield. ( CCOHS Reference ) Where to Buy: A similar version can be purchased from the Seneca Campus Store: Temp Lite Series Clear Safety Glasses .","title":"Mandatory Items for SEP600 Labs"},{"location":"sep600/lab-supplies/#sep600-lab-components","text":"The following lab components are mandatory for you to brign to the lab for this course. Also included on the list are some of the places you can purchase the items. They can also be purchased from other major online retailers but links will not be provided as their product listing is very dynamic. Item Canada Robotix Creatron Sayal (1x) Full-size Breadboard Breadboard Breadboard Breadboard Kit (20x) Jumper Wires Wire Kit Wire Kit Breadboard Kit (5x) 100\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 330\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 1k\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 4.7k\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (5x) 10k\u03a9 1/4W 5% Resistor 5 pcs 10 pcs 10 pcs (2x) 100nF 50V 20% Ceramic Capacitor 5 pcs 2 pcs (2x) 10\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 1 pc 2 pcs (2x) 100\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 1 pc 2 pcs (1x) Red 5mm LED 5pcs 10 pcs 5 pcs (1x) Potentiometer 10K with Knob 1 pc 1 pc (1x) Op-Amp LM358 or Similar 1 pc (2x) Momentary Push Button/Tactile Switch 1 pc (1x) I2C Character LCD Module or Similar 1 pc","title":"SEP600 Lab Components"},{"location":"sep600/lab-supplies/#other-optional-components","text":"Item Canada Robotix Creatron Sayal Alligator Leads 10 pcs 10 pcs 10 pcs (1x) Mini Photocell (Light Sensor) 1 pc","title":"Other Optional Components"},{"location":"sep600/lab1/","text":"Lab 1: Mbed OS and IDE Seneca Polytechnic SEP600 Embedded Systems Introduction Documentation of the Cortex-M4 instruction set, board user\u2019s guide, and the microcontroller reference manual can be found here: Documentation of the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF ) Mbed OS and Library Mbed OS is an open-source, real-time operating system designed for embedded systems and Internet of Things (IoT) devices. Developed by Arm, it provides a robust platform for building applications that require low power, high performance, and real-time capabilities. Mbed OS offers a rich set of libraries and middleware that simplify the development process, including device drivers, networking stacks, security features, and cloud connectivity. It supports a wide range of microcontrollers and hardware platforms, making it easier for developers to create scalable and reliable solutions for connected devices. With its focus on ease of use and efficiency, Mbed OS helps streamline development for embedded systems in industries like automotive, healthcare, and industrial automation. The Mbed OS mbed.h includes helper functions, objects, and keywords to simplify the development process. Although using Mbed OS is not required for the Freedom K64F and K66F microcontroller boards, taking advantage of it will greatly speed up the development cycle. Preparation Read through the lab manual for this lab. Acquire a Freedom (K64F or K66F) microcontroller board and install the necessary IDE as described in the lab manual. Procedures Recently, ARM made the announcement regarding the retirement of the Mbed platform and OS. However, the Mbed codebase will still be usable for simplifying embedded system development. The retirement of Mbed OS also means limited support for Mbed Cloud and Mbed Studio IDE. However, ARM is still actively maintaining its Keil Studio Cloud and related IDE products, allowing continued use of Mbed OS in embedded system development. Keil Studio Cloud will be the preferred IDE we will use for this course. Mbed Studio can still be used but is no longer preferred. Using the Chrome Browser , log in to Keil Studio Cloud . Create a Mbed account as necessary using your school email, as using a personal email will require additional verification from ARM. Chrome is the most popular browser for use with Keil Studio Cloud. Figure 1.1: Keil Studio Cloud Login After logging in, you will see a familiar interface based on Visual Studio Code. Click \"+ New project\" and select \"mbed-os-example-blinky\" under \"Mbed OS 6\" from the Example project menu. Rename the project to \"lab1\" and then Add project . Figure 1.2: Add Project Open main.cpp from the project tree, and you should see a very simple LED blinking code in the IDE. At this point, the code will not compile because we have not defined the \"Build target.\" Select \"FRDM-K64F\" or \"FRDM-K66F\" depending on your hardware. All errors should go away now. Figure 1.3: Keil Studio Cloud IDE with Blinky project Keil Studio Cloud uses the web USB interface to connect with your microcontroller board. The interface will only work if the Chrome browser has full permission to use your computer's USB port. Plug your microcontroller board into your computer. Once plugged in, under \"Connected device,\" you should see your microcontroller board appear. If your board is not showing up, don\u2019t worry; you can still upload your code onto your microcontroller using an alternative method. Mbed OS is an embedded real-time operating system (RTOS) that we will discuss later in the term. An RTOS, compared to a non-RTOS (or bare metal), allows the operating system to manage priority and resources to ensure the timely execution of each task or thread. In the example code: int main() { // Initialise the digital pin LED1 as an output DigitalOut led(LED1); while (true) { led = !led; ThisThread::sleep_for(BLINKING_RATE); } } DigitalOut defines an object called led using the LED1 keyword. This is the pin connected to the red LED. The led object can then be used directly as a variable to toggle the ON/OFF state of the LED. ThisThread::sleep_for(); puts the current main thread to sleep for 500 ms as defined by BLINKING_RATE . In a later lab, you'll be able to define additional threads. Below are references to learn more about the code: Mbed API list FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names At this point, there are two ways to upload the code onto your microcontroller board. Method 1: (the lucky few) If your browser has full permission to the web USB interface, you'll be able to click the \"Run project\" (Play) button to build and upload the code in a single step. The \"Flashing\" status will go to 100%, and the code will be uploaded to your board. Method 2: (the majority) If you cannot upload directly from your browser (i.e., the Flashing status does not advance when you click \"Run\"), refresh the page and click the \"Build Project\" (Hammer) button to compile the code. After the code build is complete, you will be prompted to save the .bin file. Save and copy that file into the \"K64F\" or \"K66F\" directory (from your computer's file explorer) to flash your microcontroller board. This process may take a few seconds to a few minutes depending on your setup. Be patient and wait until the board restarts after the file is uploaded. Your board should start blinking at 1 Hz. If it's not blinking, you may need to reset your board. Next, we'll output something through a USB serial port so we can read it using our computer's serial port. Depending on your browser permissions, the Keil Studio Cloud online serial monitor interface may work. However, to increase robustness, use terminal software from your computer to read the serial port. Here are some options: Windows: PuTTY or TeraTerm Mac/Linux: screen or putty Add the following line to your code with logic so that every time the LED turns ON (and only when it turns ON), the message is printed to the serial port. You can be creative with your message. printf(\"SEP600 is Cool!\\n\"); Remember, print only when (immediately after) the LED turns ON . Open the serial port that your microcontroller is connected to (e.g., COM4 or /dev/tty.usb... or /dev/ttyACM0 , depending on your platform) at a baud rate of 9600 using PuTTY, screen, or any terminal program of your choice. You should see the following being printed: SEP600 is Cool! SEP600 is Cool! SEP600 is Cool! ... To find which port your microcontroller board is connected to: Windows: Open Device Manager and look under COM Ports. Unplug and re-plug your board to find the COM port. Mac/Linux: Use ls /dev/tty* then unplug and re-plug your board to find the device port. If you don't see the output, check your code and ensure you are opening the proper port. If the problem persists, be resourceful and troubleshoot the issue. Typical setting for PuTTY: Figure 1.4: Open COM Port with PuTTY Typical command for screen : screen /dev/ttyXXXXXXXXXXXX 9600 Replace the above command with the name of your port. To exit the screen interface, use Ctrl + A then \\ . See the screen documentation. Lastly, add an input logic using scanf , getchar , or any input function so that the blinking will only start after a serial input (such as pressing \"Enter\") from the user. Initial Output: Press Enter to Start! After the Enter key is pressed: Press Enter to Start! SEP600 is Cool! SEP600 is Cool! SEP600 is Cool! ... Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab. References Keil Studio Cloud Mbed API List FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names","title":"Lab 1: Mbed OS and IDE"},{"location":"sep600/lab1/#lab-1-mbed-os-and-ide","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab 1: Mbed OS and IDE"},{"location":"sep600/lab1/#introduction","text":"Documentation of the Cortex-M4 instruction set, board user\u2019s guide, and the microcontroller reference manual can be found here: Documentation of the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) Documentation of the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Introduction"},{"location":"sep600/lab1/#mbed-os-and-library","text":"Mbed OS is an open-source, real-time operating system designed for embedded systems and Internet of Things (IoT) devices. Developed by Arm, it provides a robust platform for building applications that require low power, high performance, and real-time capabilities. Mbed OS offers a rich set of libraries and middleware that simplify the development process, including device drivers, networking stacks, security features, and cloud connectivity. It supports a wide range of microcontrollers and hardware platforms, making it easier for developers to create scalable and reliable solutions for connected devices. With its focus on ease of use and efficiency, Mbed OS helps streamline development for embedded systems in industries like automotive, healthcare, and industrial automation. The Mbed OS mbed.h includes helper functions, objects, and keywords to simplify the development process. Although using Mbed OS is not required for the Freedom K64F and K66F microcontroller boards, taking advantage of it will greatly speed up the development cycle.","title":"Mbed OS and Library"},{"location":"sep600/lab1/#preparation","text":"Read through the lab manual for this lab. Acquire a Freedom (K64F or K66F) microcontroller board and install the necessary IDE as described in the lab manual.","title":"Preparation"},{"location":"sep600/lab1/#procedures","text":"Recently, ARM made the announcement regarding the retirement of the Mbed platform and OS. However, the Mbed codebase will still be usable for simplifying embedded system development. The retirement of Mbed OS also means limited support for Mbed Cloud and Mbed Studio IDE. However, ARM is still actively maintaining its Keil Studio Cloud and related IDE products, allowing continued use of Mbed OS in embedded system development. Keil Studio Cloud will be the preferred IDE we will use for this course. Mbed Studio can still be used but is no longer preferred. Using the Chrome Browser , log in to Keil Studio Cloud . Create a Mbed account as necessary using your school email, as using a personal email will require additional verification from ARM. Chrome is the most popular browser for use with Keil Studio Cloud. Figure 1.1: Keil Studio Cloud Login After logging in, you will see a familiar interface based on Visual Studio Code. Click \"+ New project\" and select \"mbed-os-example-blinky\" under \"Mbed OS 6\" from the Example project menu. Rename the project to \"lab1\" and then Add project . Figure 1.2: Add Project Open main.cpp from the project tree, and you should see a very simple LED blinking code in the IDE. At this point, the code will not compile because we have not defined the \"Build target.\" Select \"FRDM-K64F\" or \"FRDM-K66F\" depending on your hardware. All errors should go away now. Figure 1.3: Keil Studio Cloud IDE with Blinky project Keil Studio Cloud uses the web USB interface to connect with your microcontroller board. The interface will only work if the Chrome browser has full permission to use your computer's USB port. Plug your microcontroller board into your computer. Once plugged in, under \"Connected device,\" you should see your microcontroller board appear. If your board is not showing up, don\u2019t worry; you can still upload your code onto your microcontroller using an alternative method. Mbed OS is an embedded real-time operating system (RTOS) that we will discuss later in the term. An RTOS, compared to a non-RTOS (or bare metal), allows the operating system to manage priority and resources to ensure the timely execution of each task or thread. In the example code: int main() { // Initialise the digital pin LED1 as an output DigitalOut led(LED1); while (true) { led = !led; ThisThread::sleep_for(BLINKING_RATE); } } DigitalOut defines an object called led using the LED1 keyword. This is the pin connected to the red LED. The led object can then be used directly as a variable to toggle the ON/OFF state of the LED. ThisThread::sleep_for(); puts the current main thread to sleep for 500 ms as defined by BLINKING_RATE . In a later lab, you'll be able to define additional threads. Below are references to learn more about the code: Mbed API list FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names At this point, there are two ways to upload the code onto your microcontroller board. Method 1: (the lucky few) If your browser has full permission to the web USB interface, you'll be able to click the \"Run project\" (Play) button to build and upload the code in a single step. The \"Flashing\" status will go to 100%, and the code will be uploaded to your board. Method 2: (the majority) If you cannot upload directly from your browser (i.e., the Flashing status does not advance when you click \"Run\"), refresh the page and click the \"Build Project\" (Hammer) button to compile the code. After the code build is complete, you will be prompted to save the .bin file. Save and copy that file into the \"K64F\" or \"K66F\" directory (from your computer's file explorer) to flash your microcontroller board. This process may take a few seconds to a few minutes depending on your setup. Be patient and wait until the board restarts after the file is uploaded. Your board should start blinking at 1 Hz. If it's not blinking, you may need to reset your board. Next, we'll output something through a USB serial port so we can read it using our computer's serial port. Depending on your browser permissions, the Keil Studio Cloud online serial monitor interface may work. However, to increase robustness, use terminal software from your computer to read the serial port. Here are some options: Windows: PuTTY or TeraTerm Mac/Linux: screen or putty Add the following line to your code with logic so that every time the LED turns ON (and only when it turns ON), the message is printed to the serial port. You can be creative with your message. printf(\"SEP600 is Cool!\\n\"); Remember, print only when (immediately after) the LED turns ON . Open the serial port that your microcontroller is connected to (e.g., COM4 or /dev/tty.usb... or /dev/ttyACM0 , depending on your platform) at a baud rate of 9600 using PuTTY, screen, or any terminal program of your choice. You should see the following being printed: SEP600 is Cool! SEP600 is Cool! SEP600 is Cool! ... To find which port your microcontroller board is connected to: Windows: Open Device Manager and look under COM Ports. Unplug and re-plug your board to find the COM port. Mac/Linux: Use ls /dev/tty* then unplug and re-plug your board to find the device port. If you don't see the output, check your code and ensure you are opening the proper port. If the problem persists, be resourceful and troubleshoot the issue. Typical setting for PuTTY: Figure 1.4: Open COM Port with PuTTY Typical command for screen : screen /dev/ttyXXXXXXXXXXXX 9600 Replace the above command with the name of your port. To exit the screen interface, use Ctrl + A then \\ . See the screen documentation. Lastly, add an input logic using scanf , getchar , or any input function so that the blinking will only start after a serial input (such as pressing \"Enter\") from the user. Initial Output: Press Enter to Start! After the Enter key is pressed: Press Enter to Start! SEP600 is Cool! SEP600 is Cool! SEP600 is Cool! ... Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab.","title":"Procedures"},{"location":"sep600/lab1/#references","text":"Keil Studio Cloud Mbed API List FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names","title":"References"},{"location":"sep600/lab2/","text":"Lab 2: Comparator and Digital I/O Seneca Polytechnic SEP600 Embedded Systems Introduction Documentation for the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF ) Comparator An operational amplifier (op-amp) can be used as a comparator, a device that compares two input voltages and outputs a signal based on which input is higher. In this configuration, the op-amp operates in open-loop mode, meaning there is no feedback loop, allowing it to function as a high-gain amplifier. When the non-inverting input voltage exceeds the inverting input voltage, the output swings to one extreme (positive saturation). Conversely, when the inverting input voltage exceeds the non-inverting input, the output swings to the other extreme (negative saturation). This sharp transition between high and low states makes op-amp comparators ideal for digital signal processing, threshold detection, and square wave generation. They are widely used in applications such as zero-crossing detectors, overcurrent protection circuits, and pulse-width modulation. Figure 2.1 Materials Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper wires (1x) Op-Amp (LM358, LM324, or similar) Various 1k\u03a9-10k\u03a9 resistors (2x) Buttons or switches (1x) Potentiometer (Optional) Preparation Read over the lab manual for this lab and acquire the necessary materials. Procedures Part 1: Comparator and Digital Input Figure 2.2 Acquire a breadboard, an op-amp, jumper wires, and the necessary resistors to assemble the circuit shown above. Use your microcontroller board as the 3.3V power source for the comparator, and refer to your op-amp's datasheet for its pinout. Choose R1 and R2 so that the reference voltage (inverting input) for the comparator is 2V . Keep in mind that the maximum power for a typical through-hole resistor is 1/4W. Double-check the maximum power rating of the resistor you are using to select the appropriate resistance value. Connect the output of the variable power supply to the non-inverting input of the comparator. Alternatively, you may use the output of a potentiometer instead of a power supply. Recommendation: It is always a good idea to validate your circuit's output before connecting it to a microcontroller. Connect the output of the comparator to any PTXXX pin on the FRDM-K64F. All numbered pins (PTXXX) can be used as DigitalIn and DigitalOut interfaces. For the FRDM-K66F, refer to the FRDM-K66F Mbed Reference . Figure 2.3 : FRDM-K64F Header Pinout from FRDM-K64F Mbed Reference . Ensure that the negative connector of the power supply, your comparator, and your microcontroller all share a common ground reference voltage. Program the following code into your microcontroller: int main() { DigitalOut led(LED1); // Initialize the digital pin LED1 as an output DigitalIn comparator(PTXXX); // Initialize a digital input object // Replace PTXXX with your input pin while (true) { if (comparator) { led = 0; // LED ON } else { led = 1; // LED OFF } } } Replace PTXXX with the pin you connected the comparator output to. Once the code has been uploaded, set the power supply output to 1V and turn on the power supply. Did the red LED turn ON or OFF? Raise the power supply voltage to 3V. Did the red LED turn ON or OFF now? Do not raise the power supply voltage higher than 5V Ensure you fully understand how the power supply voltage is affecting the comparator's output and how the signal is being read by the microcontroller as a digital input. Part 2: Pull-Up and Pull-Down Figure 2.4 : (A) Pull-Up Input. (B) Pull-Down Input. Without disassembling the Part 1 circuit, acquire a 1k\u03a9 (or higher resistance value) resistor, a button (or use jumper wires as a switch), and jumper wires to assemble a Pull-Up circuit as shown above. Attach the output signal to one of the digital input pins of your microcontroller. Recommendation: It is always a good idea to validate your circuit's output before connecting it to a microcontroller. What is the current passing through the resistor when the switch is closed? Is this a safe current for the resistor? How can you modify the circuit to reduce its energy consumption? Modify the code from Part 1 to include an additional DigitalIn object for reading the button input. The new logic will be as follows: Only if the input to the comparator is above 2V, the red LED will turn ON only if the button is pressed. That is, the comparator input acts as the master switch. Remember, you'll need to set up a digital pin input object for the button input first. Use serial print statements for debugging or information as necessary. Run and test your program. Without taking apart your Pull-Up circuit, assemble another Pull-Down circuit as shown above and attach the signal to another digital input pin of your microcontroller. Modify your code so the second switch you assembled will trigger the second LED (LED2) to turn ON only if the button is pressed. As before, the LED will only turn on if the input to the comparator is above 2V. Keep in mind that you are now using a Pull-Down circuit as input. Run and test your program. Ensure you fully understand digital input and output, as well as Pull-Up and Pull-Down circuits. Experiment with the code or circuit as necessary to deepen your understanding. Part 3: PWM Output Without removing your comparator, Pull-Up, and Pull-Down circuits, connect a PWM-capable pin of your microcontroller (those with a purple PWM label in the pinout diagram) to CH1 of the DSO. Refer to the microcontroller board manual for details on pin assignments. Connect the DSO ground to the common ground of your circuit. NOTE: In order for microcontroller to reliablilty read from external signal (such as from a power supply), they must all share the same reference (common ground). Modify your code to set up a PWM pin: int main() { ... PwmOut pwm(PTXXX); // Replace PTXXX with your PWM pin ... } Add the following code to start the PWM output. Use a period that is at least twice your RC time constant: int main() { ... pwm.period(0.001f); // Set PWM period in seconds pwm.write(0.50f); // Set PWM duty cycle, 0.5f = 50% ... } Run and test your program. Turn on the DSO and adjust the settings to see CH1 as a stable square wave. What do you notice about the ratio between the ON time and OFF time of the square wave? What is the PWM frequency? Modify your code so that one of the buttons will also increment the PWM duty cycle by 10% (i.e., +0.10f), and the other button will decrement the duty cycle by 10% (i.e., -0.10f). All other comparator and LED logic should remain in the code. The increase and decrease should happen in real-time right after the button press. Use serial print statements for debugging or information as necessary. Hint: You only need to change the duty cycle. You do not have to redefine the PWM object or the PWM period. Ensure you fully understand the concept of PWM. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You might be asked to explain some of the concepts you've learned in this lab. References mbed I/O APIs DigitalIn DigitalOut PwmOut","title":"Lab 2: Comparator and Digital I/O"},{"location":"sep600/lab2/#lab-2-comparator-and-digital-io","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab 2: Comparator and Digital I/O"},{"location":"sep600/lab2/#introduction","text":"Documentation for the Cortex-M4 instruction set, board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Introduction"},{"location":"sep600/lab2/#comparator","text":"An operational amplifier (op-amp) can be used as a comparator, a device that compares two input voltages and outputs a signal based on which input is higher. In this configuration, the op-amp operates in open-loop mode, meaning there is no feedback loop, allowing it to function as a high-gain amplifier. When the non-inverting input voltage exceeds the inverting input voltage, the output swings to one extreme (positive saturation). Conversely, when the inverting input voltage exceeds the non-inverting input, the output swings to the other extreme (negative saturation). This sharp transition between high and low states makes op-amp comparators ideal for digital signal processing, threshold detection, and square wave generation. They are widely used in applications such as zero-crossing detectors, overcurrent protection circuits, and pulse-width modulation. Figure 2.1","title":"Comparator"},{"location":"sep600/lab2/#materials","text":"Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper wires (1x) Op-Amp (LM358, LM324, or similar) Various 1k\u03a9-10k\u03a9 resistors (2x) Buttons or switches (1x) Potentiometer (Optional)","title":"Materials"},{"location":"sep600/lab2/#preparation","text":"Read over the lab manual for this lab and acquire the necessary materials.","title":"Preparation"},{"location":"sep600/lab2/#procedures","text":"","title":"Procedures"},{"location":"sep600/lab2/#part-1-comparator-and-digital-input","text":"Figure 2.2 Acquire a breadboard, an op-amp, jumper wires, and the necessary resistors to assemble the circuit shown above. Use your microcontroller board as the 3.3V power source for the comparator, and refer to your op-amp's datasheet for its pinout. Choose R1 and R2 so that the reference voltage (inverting input) for the comparator is 2V . Keep in mind that the maximum power for a typical through-hole resistor is 1/4W. Double-check the maximum power rating of the resistor you are using to select the appropriate resistance value. Connect the output of the variable power supply to the non-inverting input of the comparator. Alternatively, you may use the output of a potentiometer instead of a power supply. Recommendation: It is always a good idea to validate your circuit's output before connecting it to a microcontroller. Connect the output of the comparator to any PTXXX pin on the FRDM-K64F. All numbered pins (PTXXX) can be used as DigitalIn and DigitalOut interfaces. For the FRDM-K66F, refer to the FRDM-K66F Mbed Reference . Figure 2.3 : FRDM-K64F Header Pinout from FRDM-K64F Mbed Reference . Ensure that the negative connector of the power supply, your comparator, and your microcontroller all share a common ground reference voltage. Program the following code into your microcontroller: int main() { DigitalOut led(LED1); // Initialize the digital pin LED1 as an output DigitalIn comparator(PTXXX); // Initialize a digital input object // Replace PTXXX with your input pin while (true) { if (comparator) { led = 0; // LED ON } else { led = 1; // LED OFF } } } Replace PTXXX with the pin you connected the comparator output to. Once the code has been uploaded, set the power supply output to 1V and turn on the power supply. Did the red LED turn ON or OFF? Raise the power supply voltage to 3V. Did the red LED turn ON or OFF now? Do not raise the power supply voltage higher than 5V Ensure you fully understand how the power supply voltage is affecting the comparator's output and how the signal is being read by the microcontroller as a digital input.","title":"Part 1: Comparator and Digital Input"},{"location":"sep600/lab2/#part-2-pull-up-and-pull-down","text":"Figure 2.4 : (A) Pull-Up Input. (B) Pull-Down Input. Without disassembling the Part 1 circuit, acquire a 1k\u03a9 (or higher resistance value) resistor, a button (or use jumper wires as a switch), and jumper wires to assemble a Pull-Up circuit as shown above. Attach the output signal to one of the digital input pins of your microcontroller. Recommendation: It is always a good idea to validate your circuit's output before connecting it to a microcontroller. What is the current passing through the resistor when the switch is closed? Is this a safe current for the resistor? How can you modify the circuit to reduce its energy consumption? Modify the code from Part 1 to include an additional DigitalIn object for reading the button input. The new logic will be as follows: Only if the input to the comparator is above 2V, the red LED will turn ON only if the button is pressed. That is, the comparator input acts as the master switch. Remember, you'll need to set up a digital pin input object for the button input first. Use serial print statements for debugging or information as necessary. Run and test your program. Without taking apart your Pull-Up circuit, assemble another Pull-Down circuit as shown above and attach the signal to another digital input pin of your microcontroller. Modify your code so the second switch you assembled will trigger the second LED (LED2) to turn ON only if the button is pressed. As before, the LED will only turn on if the input to the comparator is above 2V. Keep in mind that you are now using a Pull-Down circuit as input. Run and test your program. Ensure you fully understand digital input and output, as well as Pull-Up and Pull-Down circuits. Experiment with the code or circuit as necessary to deepen your understanding.","title":"Part 2: Pull-Up and Pull-Down"},{"location":"sep600/lab2/#part-3-pwm-output","text":"Without removing your comparator, Pull-Up, and Pull-Down circuits, connect a PWM-capable pin of your microcontroller (those with a purple PWM label in the pinout diagram) to CH1 of the DSO. Refer to the microcontroller board manual for details on pin assignments. Connect the DSO ground to the common ground of your circuit. NOTE: In order for microcontroller to reliablilty read from external signal (such as from a power supply), they must all share the same reference (common ground). Modify your code to set up a PWM pin: int main() { ... PwmOut pwm(PTXXX); // Replace PTXXX with your PWM pin ... } Add the following code to start the PWM output. Use a period that is at least twice your RC time constant: int main() { ... pwm.period(0.001f); // Set PWM period in seconds pwm.write(0.50f); // Set PWM duty cycle, 0.5f = 50% ... } Run and test your program. Turn on the DSO and adjust the settings to see CH1 as a stable square wave. What do you notice about the ratio between the ON time and OFF time of the square wave? What is the PWM frequency? Modify your code so that one of the buttons will also increment the PWM duty cycle by 10% (i.e., +0.10f), and the other button will decrement the duty cycle by 10% (i.e., -0.10f). All other comparator and LED logic should remain in the code. The increase and decrease should happen in real-time right after the button press. Use serial print statements for debugging or information as necessary. Hint: You only need to change the duty cycle. You do not have to redefine the PWM object or the PWM period. Ensure you fully understand the concept of PWM. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You might be asked to explain some of the concepts you've learned in this lab.","title":"Part 3: PWM Output"},{"location":"sep600/lab2/#references","text":"mbed I/O APIs DigitalIn DigitalOut PwmOut","title":"References"},{"location":"sep600/lab3/","text":"Lab 3: PWM and DAC Seneca Polytechnic SEP600 Embedded Systems Introduction Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF ) Pulse Width Modulation (PWM) As discussed in class and tested in Lab 2, Pulse Width Modulation (PWM) is a technique used to control the amount of power delivered to an electrical device by varying the width of the pulses in a signal. It involves turning a signal on and off at a high frequency, with the proportion of time the signal is \"on\" (the duty cycle) determining the average voltage or power delivered. A higher duty cycle means more power, while a lower duty cycle reduces power. PWM is widely used in applications such as motor control, light dimming, and power regulation because it allows for efficient energy use and precise control of the output. It is favored for its simplicity, cost-effectiveness, and ability to operate with minimal heat generation compared to traditional methods of voltage regulation. Figure 3.1 PWM Digital-to-Analog Converter (DAC) A Digital-to-Analog Converter (DAC) is an essential component in modern electronic systems that converts digital data, usually in binary form, into an analog signal. This process is crucial for applications like audio playback, where the digital data stored in devices like smartphones or computers must be transformed into analog signals to drive speakers or headphones. The quality of a DAC can significantly influence sound fidelity, as it directly impacts the smoothness and accuracy of the analog signal. DACs are used in a wide variety of devices, from audio equipment and televisions to medical devices and instrumentation, playing a key role in bridging the digital world with the analog one. Figure 3.2 DAC Output Materials Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper wires Various 1k\u03a9\u201310k\u03a9 resistors Various 0.1\u00b5F\u201310\u00b5F capacitors (2x) NPN Transistors (2N2222, 2N3904, or similar) (2x) LEDs Preparation Read over the lab manual for this lab and acquire the necessary materials. Procedures Part 1: PWM Output as Analog Output Figure 3.3 PWM Output with RC Smoothing Circuit. Acquire a breadboard, a resistor, a capacitor, and jumper wires to assemble the circuit shown above. Attach the PWM signal to a PWM-capable pin of your microcontroller (pins with a purple PWM label in the pinout diagram from Lab 2 ). Refer to the microcontroller board manual for details on pin assignment. If you are using a polarized capacitor, ensure the polarity of your connection is correct. Calculate the RC time constant for your circuit, as you will need this for your program. \\tau = RC Write code to set up the PWM output pin. int main() { ... PwmOut pwm(PTXXX); // Replace PTXXX with your PWM pin ... } Add the following code to start the PWM output. Use a period that is at least twice the value of your RC time constant. int main() { ... pwm.period(XXXf); // period in s pwm.write(0.50f); // duty cycle 0.5f = 50% ... } Turn on the DSO and connect CH1 to your PWM output pin and CH2 to the RC circuit output signal. The DSO ground should be common with your circuit ground. Run and test your program, then adjust the DSO so that both CH1 and CH2 are visible on the display. Your signal should look similar to the graph below. Figure 3.3 PWM Signal after RC Smoothing. What you have now is a poorly filtered analog output. Adjust your PWM settings (e.g., period) so that there is less than 10% fluctuation between the high and low voltages after the RC filter (CH2). (The peak-to-peak voltage of the output should be less than 0.33V.) Hint: Think about the discharging and transient response of the capacitor. Lab Question: What is the PWM period (and frequency) needed to achieve this? Lab Question: Can the same result be achieved by modifying the circuit instead of modifying the PWM settings? Do NOT disassemble this circuit. Be prepared to demonstrate its output at the end of the lab. Part 2: PWM vs DAC as Current Driver Next, we'll set up a PWM and a DAC to compare the difference between the outputs. Figure 3.4 DAC and PWM Output Set up two current driver circuits as shown above. Connect a PWM output pin to the input signal of the first current driver and a DAC output pin to the input signal of the second current driver. Connect CH1 and CH2 of the DSO to the points of the first and second current driver circuits, respectively. Refer to the microcontroller board manual for details on pin assignment. Use your microcontroller's 3.3V output and GND connection for the current driver circuit. Select R_B and R_L appropriately. R_L should allow only 20mA of current to pass through the LED. R_B should allow the NPN transistor to drive at least 20mA of current when it's fully ON at saturation. Refer to the NPN transistor's datasheet for the gain value. It is often refered to as h_{FE} by maunfacturer. The following formula from lecture slides might be useful for your calculation. I_C = \\beta I_B V_{IN} - V_{BE} = I_B R_B Modify your code to add a DAC output and a second PWM output. Since there's only one DAC available, the DAC pin name is fixed. int main() { ... AnalogOut aout(DAC0_OUT); // Set up DAC PwmOut pwm2(PTXXX); // Replace PTXXX with your PWM pin ... ... aout = 0.5f; // Use the same output setting as PWM pwm2.period(0.01f); // Period in s pwm2.write(0.50f); // Duty cycle 0.5f = 50% ... } Turn on the DSO and run the program. You should also see a PWM square wave on the channel connected to the PWM circuit and a 1.65V flat line on the channel connected to the DAC. Did both LEDs turn on? If not, try increasing the output value until the LED turn on. Modify your code so the two LEDs both start from 0% brightness and then gradually (at least 10 steps) increase to 100% brightness over a period of 1 second. Afterward, gradually (at least 10 steps) decrease to 0% brightness over a period of 1 second. At the end, you should see something similar to the figure below on your DSO. Figure 3.5 DAC and PWM Output Lab Question: What difference do you notice between the two LEDs? Which method is better? Lab Question: After the LED reaches full brightness, at what PWM duty cycle do you start noticing a decrease in LED brightness? Ensure you fully understand the concepts of PWM, the RC circuit, DAC, and the current driver. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab. References mbed I/O APIs PwmOut AnalogOut","title":"Lab 3: PWM and DAC"},{"location":"sep600/lab3/#lab-3-pwm-and-dac","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab 3: PWM and DAC"},{"location":"sep600/lab3/#introduction","text":"Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Introduction"},{"location":"sep600/lab3/#pulse-width-modulation-pwm","text":"As discussed in class and tested in Lab 2, Pulse Width Modulation (PWM) is a technique used to control the amount of power delivered to an electrical device by varying the width of the pulses in a signal. It involves turning a signal on and off at a high frequency, with the proportion of time the signal is \"on\" (the duty cycle) determining the average voltage or power delivered. A higher duty cycle means more power, while a lower duty cycle reduces power. PWM is widely used in applications such as motor control, light dimming, and power regulation because it allows for efficient energy use and precise control of the output. It is favored for its simplicity, cost-effectiveness, and ability to operate with minimal heat generation compared to traditional methods of voltage regulation. Figure 3.1 PWM","title":"Pulse Width Modulation (PWM)"},{"location":"sep600/lab3/#digital-to-analog-converter-dac","text":"A Digital-to-Analog Converter (DAC) is an essential component in modern electronic systems that converts digital data, usually in binary form, into an analog signal. This process is crucial for applications like audio playback, where the digital data stored in devices like smartphones or computers must be transformed into analog signals to drive speakers or headphones. The quality of a DAC can significantly influence sound fidelity, as it directly impacts the smoothness and accuracy of the analog signal. DACs are used in a wide variety of devices, from audio equipment and televisions to medical devices and instrumentation, playing a key role in bridging the digital world with the analog one. Figure 3.2 DAC Output","title":"Digital-to-Analog Converter (DAC)"},{"location":"sep600/lab3/#materials","text":"Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper wires Various 1k\u03a9\u201310k\u03a9 resistors Various 0.1\u00b5F\u201310\u00b5F capacitors (2x) NPN Transistors (2N2222, 2N3904, or similar) (2x) LEDs","title":"Materials"},{"location":"sep600/lab3/#preparation","text":"Read over the lab manual for this lab and acquire the necessary materials.","title":"Preparation"},{"location":"sep600/lab3/#procedures","text":"","title":"Procedures"},{"location":"sep600/lab3/#part-1-pwm-output-as-analog-output","text":"Figure 3.3 PWM Output with RC Smoothing Circuit. Acquire a breadboard, a resistor, a capacitor, and jumper wires to assemble the circuit shown above. Attach the PWM signal to a PWM-capable pin of your microcontroller (pins with a purple PWM label in the pinout diagram from Lab 2 ). Refer to the microcontroller board manual for details on pin assignment. If you are using a polarized capacitor, ensure the polarity of your connection is correct. Calculate the RC time constant for your circuit, as you will need this for your program. \\tau = RC Write code to set up the PWM output pin. int main() { ... PwmOut pwm(PTXXX); // Replace PTXXX with your PWM pin ... } Add the following code to start the PWM output. Use a period that is at least twice the value of your RC time constant. int main() { ... pwm.period(XXXf); // period in s pwm.write(0.50f); // duty cycle 0.5f = 50% ... } Turn on the DSO and connect CH1 to your PWM output pin and CH2 to the RC circuit output signal. The DSO ground should be common with your circuit ground. Run and test your program, then adjust the DSO so that both CH1 and CH2 are visible on the display. Your signal should look similar to the graph below. Figure 3.3 PWM Signal after RC Smoothing. What you have now is a poorly filtered analog output. Adjust your PWM settings (e.g., period) so that there is less than 10% fluctuation between the high and low voltages after the RC filter (CH2). (The peak-to-peak voltage of the output should be less than 0.33V.) Hint: Think about the discharging and transient response of the capacitor. Lab Question: What is the PWM period (and frequency) needed to achieve this? Lab Question: Can the same result be achieved by modifying the circuit instead of modifying the PWM settings? Do NOT disassemble this circuit. Be prepared to demonstrate its output at the end of the lab.","title":"Part 1: PWM Output as Analog Output"},{"location":"sep600/lab3/#part-2-pwm-vs-dac-as-current-driver","text":"Next, we'll set up a PWM and a DAC to compare the difference between the outputs. Figure 3.4 DAC and PWM Output Set up two current driver circuits as shown above. Connect a PWM output pin to the input signal of the first current driver and a DAC output pin to the input signal of the second current driver. Connect CH1 and CH2 of the DSO to the points of the first and second current driver circuits, respectively. Refer to the microcontroller board manual for details on pin assignment. Use your microcontroller's 3.3V output and GND connection for the current driver circuit. Select R_B and R_L appropriately. R_L should allow only 20mA of current to pass through the LED. R_B should allow the NPN transistor to drive at least 20mA of current when it's fully ON at saturation. Refer to the NPN transistor's datasheet for the gain value. It is often refered to as h_{FE} by maunfacturer. The following formula from lecture slides might be useful for your calculation. I_C = \\beta I_B V_{IN} - V_{BE} = I_B R_B Modify your code to add a DAC output and a second PWM output. Since there's only one DAC available, the DAC pin name is fixed. int main() { ... AnalogOut aout(DAC0_OUT); // Set up DAC PwmOut pwm2(PTXXX); // Replace PTXXX with your PWM pin ... ... aout = 0.5f; // Use the same output setting as PWM pwm2.period(0.01f); // Period in s pwm2.write(0.50f); // Duty cycle 0.5f = 50% ... } Turn on the DSO and run the program. You should also see a PWM square wave on the channel connected to the PWM circuit and a 1.65V flat line on the channel connected to the DAC. Did both LEDs turn on? If not, try increasing the output value until the LED turn on. Modify your code so the two LEDs both start from 0% brightness and then gradually (at least 10 steps) increase to 100% brightness over a period of 1 second. Afterward, gradually (at least 10 steps) decrease to 0% brightness over a period of 1 second. At the end, you should see something similar to the figure below on your DSO. Figure 3.5 DAC and PWM Output Lab Question: What difference do you notice between the two LEDs? Which method is better? Lab Question: After the LED reaches full brightness, at what PWM duty cycle do you start noticing a decrease in LED brightness? Ensure you fully understand the concepts of PWM, the RC circuit, DAC, and the current driver. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab.","title":"Part 2: PWM vs DAC as Current Driver"},{"location":"sep600/lab3/#references","text":"mbed I/O APIs PwmOut AnalogOut","title":"References"},{"location":"sep600/lab4/","text":"Lab 4: ADC and RTOS Seneca Polytechnic SEP600 Embedded Systems Introduction Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF ) Analog-to-Digital Converter (ADC) An ADC is a crucial component in modern electronics that converts continuous analog signals into discrete digital values. This conversion allows electronic systems to process real-world analog signals, such as sound, temperature, or light, which are inherently continuous, by transforming them into a format that digital devices like microcontrollers or computers can understand. ADCs are commonly used in applications like audio processing, signal sampling, sensor interfacing, and communications. The quality and accuracy of an ADC are determined by factors such as its resolution (the number of bits used in the conversion) and its sampling rate (how frequently it captures data). Figure 4.1 ADC Output Real-Time Operating System (RTOS) An RTOS in an embedded system is a specialized operating system designed to manage hardware resources and execute tasks within strict timing constraints. Unlike general-purpose operating systems, an RTOS prioritizes real-time performance, ensuring that critical tasks execute within a predictable time frame. It typically uses a scheduler (such as preemptive, cooperative, or hybrid) to manage multiple tasks efficiently, balancing system responsiveness and resource utilization. RTOSs like FreeRTOS, VxWorks, and QNX are widely used in applications such as automotive systems, medical devices, industrial automation, and IoT devices, where deterministic behavior is crucial for reliability and safety. By providing features like task prioritization, inter-task communication, and real-time scheduling, an RTOS enhances the performance and stability of embedded systems, making them suitable for time-sensitive applications. Figure 4.2 RTOS Program Flowchart Materials Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper wires (1\u00d7) 10k\u03a9 Resistor (1\u00d7) 1k\u03a9\u201310k\u03a9 Potentiometer (Optional) Preparation Read through the lab manual and acquire the necessary materials. Procedures Part 1: Analog Input Figure 4.3 ADC Input Circuit. Acquire a breadboard, a 10k\u03a9 resistor or a 10k\u03a9 potentiometer, and jumper wires to assemble the circuit shown above. You may use the workbench power supply as V_{IN} and assemble circuit (a) or use a potentiometer to generate the output signal and assemble circuit (b). Attach the output signal to an ADC-capable (Analog Input) pin on your microcontroller (pins with an orange Analog In label in the pinout diagram from Lab 2 ). Refer to the microcontroller board manual for details on pin assignment. Ensure all devices share a common ground. DO NOT set the power supply voltage above 3.3V. Ensure the power supply output is OFF and set it to less than 3.3V. Start a new program and insert the following code into the main function before the while loop to set up an analog input pin. Replace PTXX with the ADC pin you are using. int main() { ... AnalogIn ain(PTXX); // Replace with an ADC pin ... } Insert the following code in the main while loop to read the analog input every 500ms: while (true) { ... reading = ain; // Read ADC // Delay for 500ms ThisThread::sleep_for(500ms); ... } Modify your code to print the reading values as follows: while (true) { ... // Print the percentage, 16-bit normalized values, and human-readable format printf(\"Percentage: %-3d \", reading * 100); printf(\"Normalized: %-4dmV \", reading * 3.3 * 1000); printf(\"Raw HEX: 0x%04X\\n\", ain.read_u16()); ... } Since mbed OS 6 no longer enables floating-point printing by default, you can enable it by creating a file called mbed_app.json in the root project folder and adding: { \"target_overrides\": { \"*\": { \"target.printf_lib\": \"std\" } } } Set the power supply output to 1V, then turn it on and run the program. If using a potentiometer, set it to a middle position. Open a terminal to read the serial output from your microcontroller, which should display the voltage of the output signal. Modify the serial output to show the raw ADC output in binary instead of HEX. Lab Question: How many bits does the ADC on your microcontroller have, and what is its resolution? Part 2: RTOS Multi-Threading Instead of printing data directly in the while loop of main() , we'll utilize multi-threading in mbed OS by running the printing function in a separate thread. Move the two printf statements for reading into a new function called print_data() , using a pointer to pass variables. Add the following above main() : void print_data(float *reading) { while (true) { printf(\"Percentage: %-3d \", *reading * 100); printf(\"Normalized: %-4dmV \", *reading * 3.3 * 1000); // Delay for 1s ThisThread::sleep_for(1000ms); } } Define a new thread above print_data() : Thread print_data_thread; Start the thread in main() : print_data_thread.start(callback(print_data, &reading)); Run the updated code. Lab Question: Why is the RAW reading printed out twice? Modify your code so the output is the same as Part 1, then use Mutex or Semaphore to prevent race conditions and ensure thread safety. Refer to class notes for implementation. For example, the variable \"reading\" should be guaranteed as unchanged between the printf statements. Note: All analog readings must occur in the main thread. Lab Question: What shared resource(s) are you protecting, and what could happen if it's not protected? Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab. References mbed I/O APIs AnalogIn mbed RTOS APIs","title":"Lab 4: ADC and RTOS"},{"location":"sep600/lab4/#lab-4-adc-and-rtos","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab 4: ADC and RTOS"},{"location":"sep600/lab4/#introduction","text":"Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Introduction"},{"location":"sep600/lab4/#analog-to-digital-converter-adc","text":"An ADC is a crucial component in modern electronics that converts continuous analog signals into discrete digital values. This conversion allows electronic systems to process real-world analog signals, such as sound, temperature, or light, which are inherently continuous, by transforming them into a format that digital devices like microcontrollers or computers can understand. ADCs are commonly used in applications like audio processing, signal sampling, sensor interfacing, and communications. The quality and accuracy of an ADC are determined by factors such as its resolution (the number of bits used in the conversion) and its sampling rate (how frequently it captures data). Figure 4.1 ADC Output","title":"Analog-to-Digital Converter (ADC)"},{"location":"sep600/lab4/#real-time-operating-system-rtos","text":"An RTOS in an embedded system is a specialized operating system designed to manage hardware resources and execute tasks within strict timing constraints. Unlike general-purpose operating systems, an RTOS prioritizes real-time performance, ensuring that critical tasks execute within a predictable time frame. It typically uses a scheduler (such as preemptive, cooperative, or hybrid) to manage multiple tasks efficiently, balancing system responsiveness and resource utilization. RTOSs like FreeRTOS, VxWorks, and QNX are widely used in applications such as automotive systems, medical devices, industrial automation, and IoT devices, where deterministic behavior is crucial for reliability and safety. By providing features like task prioritization, inter-task communication, and real-time scheduling, an RTOS enhances the performance and stability of embedded systems, making them suitable for time-sensitive applications. Figure 4.2 RTOS Program Flowchart","title":"Real-Time Operating System (RTOS)"},{"location":"sep600/lab4/#materials","text":"Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper wires (1\u00d7) 10k\u03a9 Resistor (1\u00d7) 1k\u03a9\u201310k\u03a9 Potentiometer (Optional)","title":"Materials"},{"location":"sep600/lab4/#preparation","text":"Read through the lab manual and acquire the necessary materials.","title":"Preparation"},{"location":"sep600/lab4/#procedures","text":"","title":"Procedures"},{"location":"sep600/lab4/#part-1-analog-input","text":"Figure 4.3 ADC Input Circuit. Acquire a breadboard, a 10k\u03a9 resistor or a 10k\u03a9 potentiometer, and jumper wires to assemble the circuit shown above. You may use the workbench power supply as V_{IN} and assemble circuit (a) or use a potentiometer to generate the output signal and assemble circuit (b). Attach the output signal to an ADC-capable (Analog Input) pin on your microcontroller (pins with an orange Analog In label in the pinout diagram from Lab 2 ). Refer to the microcontroller board manual for details on pin assignment. Ensure all devices share a common ground. DO NOT set the power supply voltage above 3.3V. Ensure the power supply output is OFF and set it to less than 3.3V. Start a new program and insert the following code into the main function before the while loop to set up an analog input pin. Replace PTXX with the ADC pin you are using. int main() { ... AnalogIn ain(PTXX); // Replace with an ADC pin ... } Insert the following code in the main while loop to read the analog input every 500ms: while (true) { ... reading = ain; // Read ADC // Delay for 500ms ThisThread::sleep_for(500ms); ... } Modify your code to print the reading values as follows: while (true) { ... // Print the percentage, 16-bit normalized values, and human-readable format printf(\"Percentage: %-3d \", reading * 100); printf(\"Normalized: %-4dmV \", reading * 3.3 * 1000); printf(\"Raw HEX: 0x%04X\\n\", ain.read_u16()); ... } Since mbed OS 6 no longer enables floating-point printing by default, you can enable it by creating a file called mbed_app.json in the root project folder and adding: { \"target_overrides\": { \"*\": { \"target.printf_lib\": \"std\" } } } Set the power supply output to 1V, then turn it on and run the program. If using a potentiometer, set it to a middle position. Open a terminal to read the serial output from your microcontroller, which should display the voltage of the output signal. Modify the serial output to show the raw ADC output in binary instead of HEX. Lab Question: How many bits does the ADC on your microcontroller have, and what is its resolution?","title":"Part 1: Analog Input"},{"location":"sep600/lab4/#part-2-rtos-multi-threading","text":"Instead of printing data directly in the while loop of main() , we'll utilize multi-threading in mbed OS by running the printing function in a separate thread. Move the two printf statements for reading into a new function called print_data() , using a pointer to pass variables. Add the following above main() : void print_data(float *reading) { while (true) { printf(\"Percentage: %-3d \", *reading * 100); printf(\"Normalized: %-4dmV \", *reading * 3.3 * 1000); // Delay for 1s ThisThread::sleep_for(1000ms); } } Define a new thread above print_data() : Thread print_data_thread; Start the thread in main() : print_data_thread.start(callback(print_data, &reading)); Run the updated code. Lab Question: Why is the RAW reading printed out twice? Modify your code so the output is the same as Part 1, then use Mutex or Semaphore to prevent race conditions and ensure thread safety. Refer to class notes for implementation. For example, the variable \"reading\" should be guaranteed as unchanged between the printf statements. Note: All analog readings must occur in the main thread. Lab Question: What shared resource(s) are you protecting, and what could happen if it's not protected? Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab.","title":"Part 2: RTOS Multi-Threading"},{"location":"sep600/lab4/#references","text":"mbed I/O APIs AnalogIn mbed RTOS APIs","title":"References"},{"location":"sep600/lab5/","text":"Lab 5 : Serial UART and I2C Communication Seneca Polytechnic SEP600 Embedded Systems Introduction Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF ) Serial Universal Asynchronous Receiver/Transmitter (UART) Serial UART is a communication protocol commonly used for transmitting and receiving data between devices over a serial interface. It operates asynchronously, meaning that data is sent without needing a clock signal, using start bits, data bits, optional parity bits, and stop bits to structure each data frame. UART is widely used in embedded systems, microcontrollers, and computer communication for its simplicity, low cost, and reliability. Devices communicate by converting parallel data into a serial stream for transmission and converting it back on the receiving end. Typical use cases include connecting peripherals like sensors, GPS modules, and Bluetooth devices to a microcontroller or computer. It typically requires only two wires\u2014one for transmitting data (TX) and one for receiving data (RX)\u2014making it efficient for many small-scale applications. Inter-Integrated Circuit (I2C) I2C is a synchronous, multi-master, multi-slave communication protocol commonly used to connect low-speed peripheral devices like sensors, displays, and memory chips to microcontrollers. It uses only two wires for communication: a serial data line (SDA) and a serial clock line (SCL), allowing multiple devices to share the same bus. I2C operates in a master-slave configuration, where the master device controls the clock and initiates communication with the slave devices. Each device on the bus is assigned a unique address, and data is transferred in packets, which include the address and the data to be sent. I2C is favored for its simplicity, ease of use, and ability to connect multiple devices with minimal wiring, making it ideal for embedded systems and applications where space and resources are limited. Materials Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper Wires (2\u00d7) 1k\u03a9 Resistors LCD Display (Parallel or I2C) (Optional) Preparation Lab Preparation Question Read over the lab and understand the procedures. Procedures Part 1: Onboard I2C Accelerometer and Magnetometer (Or any I2C Sensor or I2C LCD) In Part 1, we'll take a look at how to get reading from the onboard accelerometer and magnetometer (or any I2C sensor or send message to a I2C LCD). Check to see if the accelerometer is assembled on your board. NXP had a production change in 2023 and no longer assembles the FXOS8700CQ onto the Freedom board. If your board is missing the accelerometer chip (as shown in Figure 4.1 below), this part of the Lab will not work. The location U8 on the Freedom Board should be assembled with the FXOS8700CQ accelerometer chip. Figure 5.1 Freedom Board with missing FXOS8700CQ accelerometer chip To use the FXOS8700CQ, you'll need to add the FXOS8700CQ library to your project. Start Kiel Studio then go to File > Add Mbed Library to Active Program. When prompted, provide the following link https://os.mbed.com/teams/NXP/code/FXOS8700Q/ . If you are using another sensor, find the library for your sensor in the mbed library repository. If you are using an I2C LCD, use this library: https://os.mbed.com/users/sstaub/code/mbedLCDi2c/ The following code depend on the I2C device that you are using. The pins used for connection to the accelerometer on the Freedom board are as follows: K64F K66F SDA PTE25 PTD9 SCL PTE24 PTD8 The Freedom have multiple I2Cs. For the K66F, the I2C pins you see on the pinout map are not on the same I2C network as the onboard sensor. Start your program with the following code to include the proper library and set up I2C. #include \"mbed.h\" #include \"FXOS8700Q.h\" I2C i2c(I2C_SDA, I2C_SCL); // replace with I2C pins Next, we'll create the accelerometer and magnetometer objects using the I2C object we created and the accelerometer's address. You can find the address in the header file. FXOS8700QAccelerometer acc(i2c, FXOS8700CQ_SLAVE_ADDR1); FXOS8700QMagnetometer mag(i2c, FXOS8700CQ_SLAVE_ADDR1); Lab Question: Look into the header file for the FXOS8700Q (or the one for your I2C device) to find the slave address in HEX? Declare the variables for the sensor data within the main function then enable the sensor. This varies depending on your I2C devices. motion_data_units_t acc_data, mag_data; float faX, faY, faZ, fmX, fmY, fmZ, tmp_float; acc.enable(); mag.enable(); Add a while loop to get accelerometer readings and print it out. You may change the print statement to just integer if you don't want to setup float. while (true) { acc.getAxis(acc_data); mag.getAxis(mag_data); printf(\"%3.3f %3.3f\\r\\n\", acc_data.x, mag_data.x); ThisThread::sleep_for(500ms); } (Optional) Per Minimal printf and snprintf , as of mbed OS 6, printf no longer prints floating point by default to save memory. To enable printing of floating point value, enable it by creating a file called mbed_app.json in the root project folder and adding the following code to it. { \"target_overrides\": { \"*\": { \"target.printf_lib\": \"std\" } } } If you are using an I2C LCD, you may use the following code to output some message on the display. #include \"mbed.h\" #include \"LCD.h\" LCD lcd(D9, D8, D4, D5, D6, D7, LCD16x2); // RS, EN, D4-D7, Type int main() { lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"START\\n\"); // display text ThisThread::sleep_for(2s); lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"Hello World!\\n\"); // display text } Run your program and you should now see accelerometer and magnetometer readings (or the LCD displaying a message). Refer to the FXOS8700Q libraries for other library functions and reading you can get. Lab Question: Try getting readings from different axes to figure out which direction is X, Y, and Z? When there is acceleration in an axis, you'll get acceleration reading on that axis (including gravity). Part 2: Visualize I2C Signal Power off the Freedom board and connect the SDA pin to CH1 and the SCL pin to CH2 of the oscilloscope. If you are using the K66F board, use I2C1 at PTC11 and PTC10 for this part of the lab. Power the board back on With the I2C code running, adjust the oscilloscope to see the full I2C data frame. Use the \"Serial\" option under Measure on the right of the face plate to align the I2C signal. If Serial measurement is not available or cannot lock into the I2C signal, you might need to do this manually. If you cannot see the I2C signal, decrease the delay in each loop so data are sent more often and use \"Single\" reading instead of continuous readings. Lab Question: Using the figure below as a reference, identify the start condition, the address, ACK, data, and stop condition of your I2C signal. You should be able to identify the HEX address you are sending from Part 1. Figure 5.2 I2C data frame [1] Part 3: UART Communication In this part of the lab, you'll be working with the group beside you to communicate between processor board. Add the following code to your program to create an unbuffered serial object for UART. K64F K66F UART TX PTC17 PTC4 UART RX PTC16 PTC3 static BufferedSerial serial_port(UART_TX, UART_RX, 9600); // replace with UART pins Create a new thread then add a loop with the following to send some data. static char c = 'a'; static int x = 1; serial_port.write(&c, 1); c += x; if (c >= 'z' || c <= 'a') x *= -1; ThisThread::sleep_for(1s); Create a new thread or add the following code in the main while loop to read incoming UART data and print it to terminal. if (serial_port.read(&c, 1)) { // Echo the input back to the terminal. ThisThread::sleep_for(100ms); // allow reading to finish printf(\"%c\\n\", c); } Connect the UART TX pin from one Freedom board to the UART RX pin on another board with an inline 1k\u03a9 Resistor as well as a common ground. Once you run the program, the TX board will start sending a char per loop to the RX board and the received data will be displayed on the serial console. Do the same in reverse so you have two-ways communication between the boards. Lab Question: Change your code to send multiple characters at a time (ie. \"ABC123\\n\") through UART. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab. Reference AnalogIn [1] https://learn.sparkfun.com/tutorials/i2c/all UnbufferedSerial","title":"Lab 5 : Serial UART and I2C Communication"},{"location":"sep600/lab5/#lab-5-serial-uart-and-i2c-communication","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab 5 : Serial UART and I2C Communication"},{"location":"sep600/lab5/#introduction","text":"Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Introduction"},{"location":"sep600/lab5/#serial-universal-asynchronous-receivertransmitter-uart","text":"Serial UART is a communication protocol commonly used for transmitting and receiving data between devices over a serial interface. It operates asynchronously, meaning that data is sent without needing a clock signal, using start bits, data bits, optional parity bits, and stop bits to structure each data frame. UART is widely used in embedded systems, microcontrollers, and computer communication for its simplicity, low cost, and reliability. Devices communicate by converting parallel data into a serial stream for transmission and converting it back on the receiving end. Typical use cases include connecting peripherals like sensors, GPS modules, and Bluetooth devices to a microcontroller or computer. It typically requires only two wires\u2014one for transmitting data (TX) and one for receiving data (RX)\u2014making it efficient for many small-scale applications.","title":"Serial Universal Asynchronous Receiver/Transmitter (UART)"},{"location":"sep600/lab5/#inter-integrated-circuit-i2c","text":"I2C is a synchronous, multi-master, multi-slave communication protocol commonly used to connect low-speed peripheral devices like sensors, displays, and memory chips to microcontrollers. It uses only two wires for communication: a serial data line (SDA) and a serial clock line (SCL), allowing multiple devices to share the same bus. I2C operates in a master-slave configuration, where the master device controls the clock and initiates communication with the slave devices. Each device on the bus is assigned a unique address, and data is transferred in packets, which include the address and the data to be sent. I2C is favored for its simplicity, ease of use, and ability to connect multiple devices with minimal wiring, making it ideal for embedded systems and applications where space and resources are limited.","title":"Inter-Integrated Circuit (I2C)"},{"location":"sep600/lab5/#materials","text":"Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper Wires (2\u00d7) 1k\u03a9 Resistors LCD Display (Parallel or I2C) (Optional)","title":"Materials"},{"location":"sep600/lab5/#preparation","text":"","title":"Preparation"},{"location":"sep600/lab5/#lab-preparation-question","text":"Read over the lab and understand the procedures.","title":"Lab Preparation Question"},{"location":"sep600/lab5/#procedures","text":"","title":"Procedures"},{"location":"sep600/lab5/#part-1-onboard-i2c-accelerometer-and-magnetometer-or-any-i2c-sensor-or-i2c-lcd","text":"In Part 1, we'll take a look at how to get reading from the onboard accelerometer and magnetometer (or any I2C sensor or send message to a I2C LCD). Check to see if the accelerometer is assembled on your board. NXP had a production change in 2023 and no longer assembles the FXOS8700CQ onto the Freedom board. If your board is missing the accelerometer chip (as shown in Figure 4.1 below), this part of the Lab will not work. The location U8 on the Freedom Board should be assembled with the FXOS8700CQ accelerometer chip. Figure 5.1 Freedom Board with missing FXOS8700CQ accelerometer chip To use the FXOS8700CQ, you'll need to add the FXOS8700CQ library to your project. Start Kiel Studio then go to File > Add Mbed Library to Active Program. When prompted, provide the following link https://os.mbed.com/teams/NXP/code/FXOS8700Q/ . If you are using another sensor, find the library for your sensor in the mbed library repository. If you are using an I2C LCD, use this library: https://os.mbed.com/users/sstaub/code/mbedLCDi2c/ The following code depend on the I2C device that you are using. The pins used for connection to the accelerometer on the Freedom board are as follows: K64F K66F SDA PTE25 PTD9 SCL PTE24 PTD8 The Freedom have multiple I2Cs. For the K66F, the I2C pins you see on the pinout map are not on the same I2C network as the onboard sensor. Start your program with the following code to include the proper library and set up I2C. #include \"mbed.h\" #include \"FXOS8700Q.h\" I2C i2c(I2C_SDA, I2C_SCL); // replace with I2C pins Next, we'll create the accelerometer and magnetometer objects using the I2C object we created and the accelerometer's address. You can find the address in the header file. FXOS8700QAccelerometer acc(i2c, FXOS8700CQ_SLAVE_ADDR1); FXOS8700QMagnetometer mag(i2c, FXOS8700CQ_SLAVE_ADDR1); Lab Question: Look into the header file for the FXOS8700Q (or the one for your I2C device) to find the slave address in HEX? Declare the variables for the sensor data within the main function then enable the sensor. This varies depending on your I2C devices. motion_data_units_t acc_data, mag_data; float faX, faY, faZ, fmX, fmY, fmZ, tmp_float; acc.enable(); mag.enable(); Add a while loop to get accelerometer readings and print it out. You may change the print statement to just integer if you don't want to setup float. while (true) { acc.getAxis(acc_data); mag.getAxis(mag_data); printf(\"%3.3f %3.3f\\r\\n\", acc_data.x, mag_data.x); ThisThread::sleep_for(500ms); } (Optional) Per Minimal printf and snprintf , as of mbed OS 6, printf no longer prints floating point by default to save memory. To enable printing of floating point value, enable it by creating a file called mbed_app.json in the root project folder and adding the following code to it. { \"target_overrides\": { \"*\": { \"target.printf_lib\": \"std\" } } } If you are using an I2C LCD, you may use the following code to output some message on the display. #include \"mbed.h\" #include \"LCD.h\" LCD lcd(D9, D8, D4, D5, D6, D7, LCD16x2); // RS, EN, D4-D7, Type int main() { lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"START\\n\"); // display text ThisThread::sleep_for(2s); lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"Hello World!\\n\"); // display text } Run your program and you should now see accelerometer and magnetometer readings (or the LCD displaying a message). Refer to the FXOS8700Q libraries for other library functions and reading you can get. Lab Question: Try getting readings from different axes to figure out which direction is X, Y, and Z? When there is acceleration in an axis, you'll get acceleration reading on that axis (including gravity).","title":"Part 1: Onboard I2C Accelerometer and Magnetometer (Or any I2C Sensor or I2C LCD)"},{"location":"sep600/lab5/#part-2-visualize-i2c-signal","text":"Power off the Freedom board and connect the SDA pin to CH1 and the SCL pin to CH2 of the oscilloscope. If you are using the K66F board, use I2C1 at PTC11 and PTC10 for this part of the lab. Power the board back on With the I2C code running, adjust the oscilloscope to see the full I2C data frame. Use the \"Serial\" option under Measure on the right of the face plate to align the I2C signal. If Serial measurement is not available or cannot lock into the I2C signal, you might need to do this manually. If you cannot see the I2C signal, decrease the delay in each loop so data are sent more often and use \"Single\" reading instead of continuous readings. Lab Question: Using the figure below as a reference, identify the start condition, the address, ACK, data, and stop condition of your I2C signal. You should be able to identify the HEX address you are sending from Part 1. Figure 5.2 I2C data frame [1]","title":"Part 2: Visualize I2C Signal"},{"location":"sep600/lab5/#part-3-uart-communication","text":"In this part of the lab, you'll be working with the group beside you to communicate between processor board. Add the following code to your program to create an unbuffered serial object for UART. K64F K66F UART TX PTC17 PTC4 UART RX PTC16 PTC3 static BufferedSerial serial_port(UART_TX, UART_RX, 9600); // replace with UART pins Create a new thread then add a loop with the following to send some data. static char c = 'a'; static int x = 1; serial_port.write(&c, 1); c += x; if (c >= 'z' || c <= 'a') x *= -1; ThisThread::sleep_for(1s); Create a new thread or add the following code in the main while loop to read incoming UART data and print it to terminal. if (serial_port.read(&c, 1)) { // Echo the input back to the terminal. ThisThread::sleep_for(100ms); // allow reading to finish printf(\"%c\\n\", c); } Connect the UART TX pin from one Freedom board to the UART RX pin on another board with an inline 1k\u03a9 Resistor as well as a common ground. Once you run the program, the TX board will start sending a char per loop to the RX board and the received data will be displayed on the serial console. Do the same in reverse so you have two-ways communication between the boards. Lab Question: Change your code to send multiple characters at a time (ie. \"ABC123\\n\") through UART. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab.","title":"Part 3: UART Communication"},{"location":"sep600/lab5/#reference","text":"AnalogIn [1] https://learn.sparkfun.com/tutorials/i2c/all UnbufferedSerial","title":"Reference"},{"location":"sep600/lab6/","text":"Lab 6 : LCD and Interrupt Seneca Polytechnic SEP600 Embedded Systems Introduction Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF ) 16\u00d72 (or other size) LCD Module A 16\u00d72 Liquid Crystal Display module has 16 columns and 2 rows of characters. Most 16\u00d72 (as well as 8\u00d71, 20\u00d72, and 20\u00d74) LCD modules use a Hitachi HD44780 (or compatible) LCD controller. Each character space can display a single alphanumeric character, symbol, or custom character. The display operates by selectively controlling the liquid crystal pixels, making them opaque or transparent to create characters or graphics. The LCD controller works in 2 main modes: 4-bit Mode: Data is sent to the LCD module in two consecutive nibbles. The higher nibble, consisting of data lines D4 to D7, is sent first, followed by the lower nibble with data lines D0 to D3. This configuration allows us to send 8-bit data using only four data lines, conserving valuable I/O pins on the microcontroller. 8-bit Mode: The LCD can directly receive 8-bit data in a single transmission, using all eight data lines (D0 to D7). As a result, this mode offers faster and more efficient data transfer compared to the 4-bit mode. However, it requires more I/O pins on the microcontroller, potentially limiting its application in projects with limited resources. When using the LCD module in 4-bit mode, only 4 wires are required for parallel data transfer, plus 2 wires for enable. However, with the help of an I2C parallel port expander (I2C backpack), only 2 wires through I2C are required to work with the LCD module. Figure 6.1 16x2 LCD Some common commands are: Command Name HEX Value Description Clear Display 0x01 This command clears the entire display, resetting the cursor position to the home position (0, 0). Return Home 0x02 Sending this command moves the cursor to the home position (0, 0) without clearing the display. Entry Mode Set 0x04 This command determines the cursor movement direction and whether the display should shift. Display On/Off Control 0x08 This command controls the display, cursor, and cursor blinking options. Cursor or Display Shift 0x10 Used to shift the cursor or the entire display left or right without changing the display data. Function Set 0x20 This command sets the LCD data length (4-bit or 8-bit), number of display lines, and font size. Set CGRAM Address 0x40 This command sets the address of the Character Generator RAM (CGRAM) for custom character creation. Set DDRAM Address 0x80 This command sets the address of the Display Data RAM (DDRAM), allowing data to be written to a specific location on the LCD. Reference: HD44780 LCD Controller Materials Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper Wires LCD Display (Parallel or I2C) Various 1k\u03a9\u201310k\u03a9 resistors Button If you are using an I2C LCD, connect the LCD to the I2C pins and use the I2C library instead of the parallel LCD library. Preparation Lab Preparation Question Read over the lab and understand the procedures. Procedures Part 1: LCD Module Acquire an LCD and a resistor, then connect them to the Freedom K64F/K66F board as per the connection table and the diagram below. If you are using an I2C LCD, connect the LCD to the I2C pins. Figure 6.2 LCD connection with Freedom board The typical pinout and connection for a parallel 16x2 LCD are given below. Please keep in mind that depending on the manufacturer, some labels and configurations may vary. LCD Pin # LCD Label K64F/K66F Pin 1 GND / VSS GND / 0V 2 VDD / VCC 5V 3 VO 1k\u03a9 to GND / 0V 4 RS D9 5 R/W GND / 0V 6 E D8 7 DB0 N/C 8 DB1 N/C 9 DB2 N/C 10 DB3 N/C 11 DB4 D4 12 DB5 D5 13 DB6 D6 14 DB7 D7 15 LED+ 1k\u03a9 to 5V 16 LED- N/C Some models work with 3.3V instead of 5V. VO pin configuration varies depending on the manufacturer. A potentiometer can be used instead of a 1k\u03a9 resistor for adjustable contrast. You may change the pins used on the K64F/K66F board depending on your application and pin availability. Open Keil Studio and install the following library to your project depending on whether you are using the Parallel or I2C version of the LCD. Parallel LCD: https://os.mbed.com/users/sstaub/code/mbedLCD/ I2C LCD: https://os.mbed.com/users/sstaub/code/mbedLCDi2c/ Use the following code to output a message on the display. Uncomment the necessary lines for the LCD screen you are using: #include \"mbed.h\" // #include \"LCD.h\" // for parallel LCD // #include \"LCDi2c.h\" // for I2C LCD // LCD lcd(D9, D8, D4, D5, D6, D7, LCD16x2); // for parallel LCD: RS, EN, D4-D7, Type // LCDi2c lcd(I2C_SDA, I2C_SCL, LCD16x2); // for I2C LCD: SDA, SCL int main() { lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"SEP600\\n\"); // display text ThisThread::sleep_for(2s); lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"Hello World!\\n\"); // display text } When the LCD is operating in 4-bit mode, command and data are sent to the LCD 4-bit at a time throught D4-D7. When the RS pin on the LCD is low (0), the LCD treat the parallel input as command. When the RS pin on the LCD is high (1), the LCD treat the parallel input as data to be displayed. Here's the sequence for printing \"SEP\": Command/Data RS Pin Description 0x80 LOW Display the next charater at Row 0, Col 0 0x53 HIGH ASCII of captial \"S\" in HEX 0x81 LOW Display the next charater at Row 0, Col 0 0x45 HIGH ASCII of captial \"E\" in HEX 0x82 LOW Display the next charater at Row 0, Col 0 0x50 HIGH ASCII of captial \"P\" in HEX After uploading your code, the LCD should show \"SEP600\" for 2 seconds, then \"Hello World!\". If you are using a parallel LCD, you may skip this steps as tools for sniffing the four data line will be required to read the signals. If you are using an I2C LCD module, use the oscilloscope to take a look at the I2C data frame. You should be able to see the command and data that you are sending to the module. The I2C I/O expander is attached to the LCD as follow: Bit-7 (MSB) Bit-6 Bit-5 Bit-4 Bit-3 Bit-2 Bit-1 Bit-0 (LSB) DB7 DB6 DB5 DB4 BL E RW RS BL (Backlight) is LED+. Set this to high to turn on the backlight. E is Enable. Transistion of this pin from HIGH to LOW trigger reading of the command/data. RW is Read/Write. Set this to LOW when writing to the LCD. RS is Register Select. Set this to LOW when writing command, set this to HIGH when writing data. Since only 4-bit will be sent at a time, each command and data is divided into high and low nibbles for data transmission in bits 4-7 along with settings in bits 0-3. As a result, the I2C transmission you'll see is: Data Description 0x27 << 1 7-bit address + Write 0x8X High nibble of first command \"0x80\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x0X Low nibble of first command \"0x80\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x5X High nibble of first data \"S\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x3X High nibble of first data \"S\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x8X High nibble of second command \"0x81\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x1X Low nibble of second command \"0x81\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x4X High nibble of second data \"E\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x5X High nibble of second data \"E\" + X settings depending on your code Same pattern for the remaining command and data Lab Question: Based on your message, compare the I2C signal and see if you can find the \"Hel\" from \"Hello World!\". (Optional) If you want to take a screenshot of your oscilloscope for analysis, an easy way to do this is to connect to its web interface using the computer at your workstation. Press Utility > I/O > LAN on the oscilloscope to find it's IP address then navigate to this IP address using a browser on the workstation computer. Let's display some longer message. Lab Question: Modify your code to display your name and student number on row 1, and your lab partner's name and student number on row 2 (or be creative, like \"SEP600 Embedded Systems is Awesome\"). Since the message will be too wide for the LCD, display the text as a horizontal scrolling message at a reasonable rate. Hint: There are many ways to do this. Refer to the library documentation on how to move the print cursor. Part 2: Interrupt An interrupt is a way for the microcontroller to listen for events without continuously polling the input. Most of the GPIO pins on the Freedom K64F or K66F board can be attached to an interrupt. Connect a pull-up or pull-down button to any digital pin of your choosing. Add the following code before main() to create an interrupt object. InterruptIn button(PTXX); Add the following interrupt routine before main() and include the appropriate code for displaying a message on the LCD when the interrupt is triggered. Display the message for a few seconds, then return to displaying the previous message. void button_isr(){ // Display an interrupt message on the LCD // Use wait_us for delay // Do NOT use ThisThread::sleep_for } Hint: You can try triggering a flag in the interrupt and then display the message in the main() loop or in a separate thread. Within main() , attach the interrupt routine to the button and adjust for the rising or falling edge, depending on your circuit configuration. button.rise(&button_isr); Upload and test your interrupt. Lab Question: What will happen if you put a wait() function in the interrupt? Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab. Reference InterruptIn","title":"Lab 6 : LCD and Interrupt"},{"location":"sep600/lab6/#lab-6-lcd-and-interrupt","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab 6 : LCD and Interrupt"},{"location":"sep600/lab6/#introduction","text":"Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Introduction"},{"location":"sep600/lab6/#162-or-other-size-lcd-module","text":"A 16\u00d72 Liquid Crystal Display module has 16 columns and 2 rows of characters. Most 16\u00d72 (as well as 8\u00d71, 20\u00d72, and 20\u00d74) LCD modules use a Hitachi HD44780 (or compatible) LCD controller. Each character space can display a single alphanumeric character, symbol, or custom character. The display operates by selectively controlling the liquid crystal pixels, making them opaque or transparent to create characters or graphics. The LCD controller works in 2 main modes: 4-bit Mode: Data is sent to the LCD module in two consecutive nibbles. The higher nibble, consisting of data lines D4 to D7, is sent first, followed by the lower nibble with data lines D0 to D3. This configuration allows us to send 8-bit data using only four data lines, conserving valuable I/O pins on the microcontroller. 8-bit Mode: The LCD can directly receive 8-bit data in a single transmission, using all eight data lines (D0 to D7). As a result, this mode offers faster and more efficient data transfer compared to the 4-bit mode. However, it requires more I/O pins on the microcontroller, potentially limiting its application in projects with limited resources. When using the LCD module in 4-bit mode, only 4 wires are required for parallel data transfer, plus 2 wires for enable. However, with the help of an I2C parallel port expander (I2C backpack), only 2 wires through I2C are required to work with the LCD module. Figure 6.1 16x2 LCD Some common commands are: Command Name HEX Value Description Clear Display 0x01 This command clears the entire display, resetting the cursor position to the home position (0, 0). Return Home 0x02 Sending this command moves the cursor to the home position (0, 0) without clearing the display. Entry Mode Set 0x04 This command determines the cursor movement direction and whether the display should shift. Display On/Off Control 0x08 This command controls the display, cursor, and cursor blinking options. Cursor or Display Shift 0x10 Used to shift the cursor or the entire display left or right without changing the display data. Function Set 0x20 This command sets the LCD data length (4-bit or 8-bit), number of display lines, and font size. Set CGRAM Address 0x40 This command sets the address of the Character Generator RAM (CGRAM) for custom character creation. Set DDRAM Address 0x80 This command sets the address of the Display Data RAM (DDRAM), allowing data to be written to a specific location on the LCD. Reference: HD44780 LCD Controller","title":"16\u00d72 (or other size) LCD Module"},{"location":"sep600/lab6/#materials","text":"Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper Wires LCD Display (Parallel or I2C) Various 1k\u03a9\u201310k\u03a9 resistors Button If you are using an I2C LCD, connect the LCD to the I2C pins and use the I2C library instead of the parallel LCD library.","title":"Materials"},{"location":"sep600/lab6/#preparation","text":"","title":"Preparation"},{"location":"sep600/lab6/#lab-preparation-question","text":"Read over the lab and understand the procedures.","title":"Lab Preparation Question"},{"location":"sep600/lab6/#procedures","text":"","title":"Procedures"},{"location":"sep600/lab6/#part-1-lcd-module","text":"Acquire an LCD and a resistor, then connect them to the Freedom K64F/K66F board as per the connection table and the diagram below. If you are using an I2C LCD, connect the LCD to the I2C pins. Figure 6.2 LCD connection with Freedom board The typical pinout and connection for a parallel 16x2 LCD are given below. Please keep in mind that depending on the manufacturer, some labels and configurations may vary. LCD Pin # LCD Label K64F/K66F Pin 1 GND / VSS GND / 0V 2 VDD / VCC 5V 3 VO 1k\u03a9 to GND / 0V 4 RS D9 5 R/W GND / 0V 6 E D8 7 DB0 N/C 8 DB1 N/C 9 DB2 N/C 10 DB3 N/C 11 DB4 D4 12 DB5 D5 13 DB6 D6 14 DB7 D7 15 LED+ 1k\u03a9 to 5V 16 LED- N/C Some models work with 3.3V instead of 5V. VO pin configuration varies depending on the manufacturer. A potentiometer can be used instead of a 1k\u03a9 resistor for adjustable contrast. You may change the pins used on the K64F/K66F board depending on your application and pin availability. Open Keil Studio and install the following library to your project depending on whether you are using the Parallel or I2C version of the LCD. Parallel LCD: https://os.mbed.com/users/sstaub/code/mbedLCD/ I2C LCD: https://os.mbed.com/users/sstaub/code/mbedLCDi2c/ Use the following code to output a message on the display. Uncomment the necessary lines for the LCD screen you are using: #include \"mbed.h\" // #include \"LCD.h\" // for parallel LCD // #include \"LCDi2c.h\" // for I2C LCD // LCD lcd(D9, D8, D4, D5, D6, D7, LCD16x2); // for parallel LCD: RS, EN, D4-D7, Type // LCDi2c lcd(I2C_SDA, I2C_SCL, LCD16x2); // for I2C LCD: SDA, SCL int main() { lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"SEP600\\n\"); // display text ThisThread::sleep_for(2s); lcd.cls(); // clear display lcd.locate(0, 0); // set cursor location lcd.printf(\"Hello World!\\n\"); // display text } When the LCD is operating in 4-bit mode, command and data are sent to the LCD 4-bit at a time throught D4-D7. When the RS pin on the LCD is low (0), the LCD treat the parallel input as command. When the RS pin on the LCD is high (1), the LCD treat the parallel input as data to be displayed. Here's the sequence for printing \"SEP\": Command/Data RS Pin Description 0x80 LOW Display the next charater at Row 0, Col 0 0x53 HIGH ASCII of captial \"S\" in HEX 0x81 LOW Display the next charater at Row 0, Col 0 0x45 HIGH ASCII of captial \"E\" in HEX 0x82 LOW Display the next charater at Row 0, Col 0 0x50 HIGH ASCII of captial \"P\" in HEX After uploading your code, the LCD should show \"SEP600\" for 2 seconds, then \"Hello World!\". If you are using a parallel LCD, you may skip this steps as tools for sniffing the four data line will be required to read the signals. If you are using an I2C LCD module, use the oscilloscope to take a look at the I2C data frame. You should be able to see the command and data that you are sending to the module. The I2C I/O expander is attached to the LCD as follow: Bit-7 (MSB) Bit-6 Bit-5 Bit-4 Bit-3 Bit-2 Bit-1 Bit-0 (LSB) DB7 DB6 DB5 DB4 BL E RW RS BL (Backlight) is LED+. Set this to high to turn on the backlight. E is Enable. Transistion of this pin from HIGH to LOW trigger reading of the command/data. RW is Read/Write. Set this to LOW when writing to the LCD. RS is Register Select. Set this to LOW when writing command, set this to HIGH when writing data. Since only 4-bit will be sent at a time, each command and data is divided into high and low nibbles for data transmission in bits 4-7 along with settings in bits 0-3. As a result, the I2C transmission you'll see is: Data Description 0x27 << 1 7-bit address + Write 0x8X High nibble of first command \"0x80\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x0X Low nibble of first command \"0x80\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x5X High nibble of first data \"S\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x3X High nibble of first data \"S\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x8X High nibble of second command \"0x81\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x1X Low nibble of second command \"0x81\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x4X High nibble of second data \"E\" + X settings depending on your code 0x27 << 1 7-bit address + Write 0x5X High nibble of second data \"E\" + X settings depending on your code Same pattern for the remaining command and data Lab Question: Based on your message, compare the I2C signal and see if you can find the \"Hel\" from \"Hello World!\". (Optional) If you want to take a screenshot of your oscilloscope for analysis, an easy way to do this is to connect to its web interface using the computer at your workstation. Press Utility > I/O > LAN on the oscilloscope to find it's IP address then navigate to this IP address using a browser on the workstation computer. Let's display some longer message. Lab Question: Modify your code to display your name and student number on row 1, and your lab partner's name and student number on row 2 (or be creative, like \"SEP600 Embedded Systems is Awesome\"). Since the message will be too wide for the LCD, display the text as a horizontal scrolling message at a reasonable rate. Hint: There are many ways to do this. Refer to the library documentation on how to move the print cursor.","title":"Part 1: LCD Module"},{"location":"sep600/lab6/#part-2-interrupt","text":"An interrupt is a way for the microcontroller to listen for events without continuously polling the input. Most of the GPIO pins on the Freedom K64F or K66F board can be attached to an interrupt. Connect a pull-up or pull-down button to any digital pin of your choosing. Add the following code before main() to create an interrupt object. InterruptIn button(PTXX); Add the following interrupt routine before main() and include the appropriate code for displaying a message on the LCD when the interrupt is triggered. Display the message for a few seconds, then return to displaying the previous message. void button_isr(){ // Display an interrupt message on the LCD // Use wait_us for delay // Do NOT use ThisThread::sleep_for } Hint: You can try triggering a flag in the interrupt and then display the message in the main() loop or in a separate thread. Within main() , attach the interrupt routine to the button and adjust for the rising or falling edge, depending on your circuit configuration. button.rise(&button_isr); Upload and test your interrupt. Lab Question: What will happen if you put a wait() function in the interrupt? Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab.","title":"Part 2: Interrupt"},{"location":"sep600/lab6/#reference","text":"InterruptIn","title":"Reference"},{"location":"sep600/lab7/","text":"Lab 7 Seneca Polytechnic SEP600 Embedded Systems Introduction Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF ) Low-Pass Filter A low-pass filter is an electronic circuit or signal processing technique that allows signals with frequencies below a certain cutoff frequency to pass through, while attenuating or blocking higher-frequency signals. This makes low-pass filters ideal for filtering out high-frequency noise from signals, which is particularly useful in applications like audio processing, communications, and sensor data acquisition. Noise, often caused by electrical interference or other environmental factors, typically manifests as high-frequency components. By using a low-pass filter, these unwanted high-frequency noise signals are reduced, leaving behind the cleaner, more relevant low-frequency signals. The effectiveness of a low-pass filter in noise reduction depends on the cutoff frequency, which must be carefully selected to ensure that the desired signal remains intact while unwanted noise is removed. Figure 7.1 Sample Low-Pass Filter Figure 7.2 Signal Filtering Materials Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper Wires (1\u00d7) 1k\u03a9\u201310k\u03a9 Potentiometer (Optional) Preparation Lab Preparation Question Read over the lab and understand the procedures. Procedures In this lab, we'll explore the use of software filtering techniques to remove noise from a digital signal and then plot the data on a computer. We'll also explore the concept of multi-threading to handle the two tasks. Start the function generator to output a 1Vpp 1kHz Triangular (Ramp, 50% symmetry) wave with a 2V DC offset. Remember to set the output to high Z mode. Alternatively, you can read data from a sensor that you are using in your project. Connect the output of the function generator to an ADC (Analog input) pin on the K64F or K66F board. Use the following code to read the signal from the ADC channel. Replace PTXX with the pin that you are using. #include \"mbed.h\" int main() { AnalogIn ain(PTXX); // Replace with your ADC pin float reading = 0; // for saving readings while (true) { reading = ain; // read ADC printf(\"Reading: %d\\n\", (int) (reading * 100)); // print as int // delay for 1ms for each reading ThisThread::sleep_for(1ms); } } Your serial output should now be flooded with data output between 0 to 100. Next, move the printing of the data into a thread so it won't interfere with the ADC reading and let the processor decide how to optimize the process. Next, let's read the data from the computer using Python and plot it. Install pyserial using pip install pyserial and matplotlib using pip install matplotlib as required. Run the following Python script on your computer. import serial import matplotlib.pyplot as plt import numpy as np plt.ion() fig=plt.figure() x = list() y = list() i = 0 ser = serial.Serial('XXXX', 9600) # Replace XXXX with your serial port ser.close() ser.open() while True: data = ser.readline() x.append(i) y.append(data.decode()) plt.scatter(i, float(data.decode())) i += 1 plt.show() plt.pause(0.000001) Run the Python code and it should open the specified serial and start plotting the data. As you can tell, it is not the most optimized plotting code. Figure 6.1 Change the Python code so the plot becomes a line graph that's displaying the reading similar to an oscilloscope, i.e., replacing old readings with new ones instead of just adding readings to the graph. You should see a triangular wave (simulating noisy data) on your Python oscilloscope. Your task is to add the simple IIR filter discussed in class to smooth out the data on the controller. This means adding a new variable called alpha and old_reading to save the reading for the next iteration. filtered_reading = old_reading + alpha * (adc_reading \u2013 old_reading); Plot both the unfiltered and filtered signal on the same plot. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab. Reference Infinite Impulse Response","title":"Lab 7"},{"location":"sep600/lab7/#lab-7","text":"Seneca Polytechnic SEP600 Embedded Systems","title":"Lab 7"},{"location":"sep600/lab7/#introduction","text":"Documentation for the Cortex-M4 instruction set, the board user's guide, and the microcontroller reference manual can be found here: Documentation for the Freedom K64 and K66 boards and their microcontrollers can be found here: FRDM-K64F Freedom Module User\u2019s Guide ( PDF ) Kinetis K64 Reference Manual ( PDF ) FRDM-K64F Mbed Reference FRDM-K64F Mbed Pin Names FRDM-K66F Freedom Module User\u2019s Guide ( PDF ) Kinetis K66 Reference Manual ( PDF ) FRDM-K66F Mbed Reference FRDM-K66F Mbed Pin Names Documentation for the Cortex-M4 instruction set can be found here: Arm Cortex-M4 Processor Technical Reference Manual Revision ( PDF ) Table of Processor Instructions ARMv7-M Architecture Reference Manual ( PDF )","title":"Introduction"},{"location":"sep600/lab7/#low-pass-filter","text":"A low-pass filter is an electronic circuit or signal processing technique that allows signals with frequencies below a certain cutoff frequency to pass through, while attenuating or blocking higher-frequency signals. This makes low-pass filters ideal for filtering out high-frequency noise from signals, which is particularly useful in applications like audio processing, communications, and sensor data acquisition. Noise, often caused by electrical interference or other environmental factors, typically manifests as high-frequency components. By using a low-pass filter, these unwanted high-frequency noise signals are reduced, leaving behind the cleaner, more relevant low-frequency signals. The effectiveness of a low-pass filter in noise reduction depends on the cutoff frequency, which must be carefully selected to ensure that the desired signal remains intact while unwanted noise is removed. Figure 7.1 Sample Low-Pass Filter Figure 7.2 Signal Filtering","title":"Low-Pass Filter"},{"location":"sep600/lab7/#materials","text":"Safety glasses (PPE) Freedom K64F or K66F Board Breadboard Jumper Wires (1\u00d7) 1k\u03a9\u201310k\u03a9 Potentiometer (Optional)","title":"Materials"},{"location":"sep600/lab7/#preparation","text":"","title":"Preparation"},{"location":"sep600/lab7/#lab-preparation-question","text":"Read over the lab and understand the procedures.","title":"Lab Preparation Question"},{"location":"sep600/lab7/#procedures","text":"In this lab, we'll explore the use of software filtering techniques to remove noise from a digital signal and then plot the data on a computer. We'll also explore the concept of multi-threading to handle the two tasks. Start the function generator to output a 1Vpp 1kHz Triangular (Ramp, 50% symmetry) wave with a 2V DC offset. Remember to set the output to high Z mode. Alternatively, you can read data from a sensor that you are using in your project. Connect the output of the function generator to an ADC (Analog input) pin on the K64F or K66F board. Use the following code to read the signal from the ADC channel. Replace PTXX with the pin that you are using. #include \"mbed.h\" int main() { AnalogIn ain(PTXX); // Replace with your ADC pin float reading = 0; // for saving readings while (true) { reading = ain; // read ADC printf(\"Reading: %d\\n\", (int) (reading * 100)); // print as int // delay for 1ms for each reading ThisThread::sleep_for(1ms); } } Your serial output should now be flooded with data output between 0 to 100. Next, move the printing of the data into a thread so it won't interfere with the ADC reading and let the processor decide how to optimize the process. Next, let's read the data from the computer using Python and plot it. Install pyserial using pip install pyserial and matplotlib using pip install matplotlib as required. Run the following Python script on your computer. import serial import matplotlib.pyplot as plt import numpy as np plt.ion() fig=plt.figure() x = list() y = list() i = 0 ser = serial.Serial('XXXX', 9600) # Replace XXXX with your serial port ser.close() ser.open() while True: data = ser.readline() x.append(i) y.append(data.decode()) plt.scatter(i, float(data.decode())) i += 1 plt.show() plt.pause(0.000001) Run the Python code and it should open the specified serial and start plotting the data. As you can tell, it is not the most optimized plotting code. Figure 6.1 Change the Python code so the plot becomes a line graph that's displaying the reading similar to an oscilloscope, i.e., replacing old readings with new ones instead of just adding readings to the graph. You should see a triangular wave (simulating noisy data) on your Python oscilloscope. Your task is to add the simple IIR filter discussed in class to smooth out the data on the controller. This means adding a new variable called alpha and old_reading to save the reading for the next iteration. filtered_reading = old_reading + alpha * (adc_reading \u2013 old_reading); Plot both the unfiltered and filtered signal on the same plot. Once you've completed all the steps above (and ONLY when you are ready, as you'll only have one opportunity to demo), ask the lab professor or instructor to come over and demonstrate that you've completed the lab. You may be asked to explain some of the concepts you've learned in this lab.","title":"Procedures"},{"location":"sep600/lab7/#reference","text":"Infinite Impulse Response","title":"Reference"},{"location":"ses250/","text":"SES250 Lab Manual Labs Lab Instruction Lab Safety Lab Supplies Lab 1 : Electrostatics and Triboelectric Series Lab 2 : Digital Multimeter, Power Supply, and Ohm's Law Lab 3 : Series and Parallel Resistive Circuit Lab 4 : Kirchhoff's Laws Lab 5 : Th\u00e9venin Theorem Lab 6 : Digital Storage Oscilloscope (DSO) Lab 7 : Capacitor and RC Circuit Lab 8 : RL Circuit and Filters Lab 9 : RC and RL Circuit in AC Lab 10 : RLC Circuit Resonance Lab Project Lab Project","title":"SES250 Electromagnatics"},{"location":"ses250/#ses250-lab-manual","text":"","title":"SES250 Lab Manual"},{"location":"ses250/#labs","text":"Lab Instruction Lab Safety Lab Supplies Lab 1 : Electrostatics and Triboelectric Series Lab 2 : Digital Multimeter, Power Supply, and Ohm's Law Lab 3 : Series and Parallel Resistive Circuit Lab 4 : Kirchhoff's Laws Lab 5 : Th\u00e9venin Theorem Lab 6 : Digital Storage Oscilloscope (DSO) Lab 7 : Capacitor and RC Circuit Lab 8 : RL Circuit and Filters Lab 9 : RC and RL Circuit in AC Lab 10 : RLC Circuit Resonance","title":"Labs"},{"location":"ses250/#lab-project","text":"Lab Project","title":"Lab Project"},{"location":"ses250/instruction/","text":"Lab Instructions Seneca Polytechnic SES250 Electromagnatics Objectives Master the use of fundamental laboratory equipment Master the basic techniques of conducting experiments and taking measurement Experimentally verify the theory and concept studied in lectures Materials/Equipment required by each student Safety Glasses Bound Notebook Lab Electronics Kit (Details TBA) More details on where you can purchase them can be found in the Lab Supplies page. Each student is expected to Maintain a bound (ie. No loose sheets) laboratory/engineering notebook. The notebook shall include all preparations work and documentation of all work done during the laboratory. You are not required to have a new notebook. You can continue using one you already have or share it with another course. Always write in pen, never in pencil, and never use white-out in the notebook. If a mistake needs to be corrected, it shall be neatly crossed out with a single line and corrections shall be added. Always prepare for the laboratory experiment by writing a brief description of the experimental procedures in your own words and copying any graphs and tables to be used for documentation during the experiment into the notebook. Update the notebook continually during each experiment and include all measured data, tables, graphs, and details of relevant measurement techniques, computations, and conclusions. Bound Notebook Ring Notebook Arrive on time and be well-prepared for each laboratory session. A complete preparation includes, aside from a description of the procedures, the completion of the preparatory assignment for the experiment. Finish all parts of the experiment on time. Thorough preparatory work is critical. Laboratory Code of Behavior Students are expected to conduct themselves in a professional and safe manner at all times. Know where is the nearest fire extinguisher and the location of the safety station. No food or drink at any time inside the laboratory Safety glasses are mandatory when the power is ON Other precautionary safety equipment will be used or worn when necessary. No open-toed shoes or sandals. Long hair must be tied back. All laboratory equipment brought into the laboratory must be CSA approved and in good working order Vandalism of any kind will not be tolerated. Please note that security cameras are in place for the protection of college property and occupant safety. Offenders will be subject to the terms of the College\u2019s Student Rights and Responsibilities Policy. Wash hands after soldering. Failure to comply with the Electronics Laboratory Code of Behavior will result in a lab grade of zero (0) and you\u2019ll be asked to leave the laboratory. Other guidelines AGAIN: No food or drink inside the laboratory Keep the laboratory neat and clean, and return items to their original locations at the completion of each lab session.","title":"Lab Instructions"},{"location":"ses250/instruction/#lab-instructions","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab Instructions"},{"location":"ses250/instruction/#objectives","text":"Master the use of fundamental laboratory equipment Master the basic techniques of conducting experiments and taking measurement Experimentally verify the theory and concept studied in lectures","title":"Objectives"},{"location":"ses250/instruction/#materialsequipment-required-by-each-student","text":"Safety Glasses Bound Notebook Lab Electronics Kit (Details TBA) More details on where you can purchase them can be found in the Lab Supplies page.","title":"Materials/Equipment required by each student"},{"location":"ses250/instruction/#each-student-is-expected-to","text":"Maintain a bound (ie. No loose sheets) laboratory/engineering notebook. The notebook shall include all preparations work and documentation of all work done during the laboratory. You are not required to have a new notebook. You can continue using one you already have or share it with another course. Always write in pen, never in pencil, and never use white-out in the notebook. If a mistake needs to be corrected, it shall be neatly crossed out with a single line and corrections shall be added. Always prepare for the laboratory experiment by writing a brief description of the experimental procedures in your own words and copying any graphs and tables to be used for documentation during the experiment into the notebook. Update the notebook continually during each experiment and include all measured data, tables, graphs, and details of relevant measurement techniques, computations, and conclusions. Bound Notebook Ring Notebook Arrive on time and be well-prepared for each laboratory session. A complete preparation includes, aside from a description of the procedures, the completion of the preparatory assignment for the experiment. Finish all parts of the experiment on time. Thorough preparatory work is critical.","title":"Each student is expected to"},{"location":"ses250/instruction/#laboratory-code-of-behavior","text":"Students are expected to conduct themselves in a professional and safe manner at all times. Know where is the nearest fire extinguisher and the location of the safety station. No food or drink at any time inside the laboratory Safety glasses are mandatory when the power is ON Other precautionary safety equipment will be used or worn when necessary. No open-toed shoes or sandals. Long hair must be tied back. All laboratory equipment brought into the laboratory must be CSA approved and in good working order Vandalism of any kind will not be tolerated. Please note that security cameras are in place for the protection of college property and occupant safety. Offenders will be subject to the terms of the College\u2019s Student Rights and Responsibilities Policy. Wash hands after soldering. Failure to comply with the Electronics Laboratory Code of Behavior will result in a lab grade of zero (0) and you\u2019ll be asked to leave the laboratory.","title":"Laboratory Code of Behavior"},{"location":"ses250/instruction/#other-guidelines","text":"AGAIN: No food or drink inside the laboratory Keep the laboratory neat and clean, and return items to their original locations at the completion of each lab session.","title":"Other guidelines"},{"location":"ses250/lab-project/","text":"Lab Project : RC Lowpass Filters Seneca Polytechnic SES250 Electromagnatics Due Date: Friday, Apr 11, 2025, 11:59 PM Purposes To understand simple capacitive low-pass filter circuit To understand how to write a lab report Objectives Assemble electronic components onto a breadboard Measure the filtering of signals using a Digital Storage Oscilloscope (DSO) Document your processes and results in a lab report Description Using what you've learned from Lab 7 and Lab 8 about capacitive and low-pass filters, your task is to create a capacitive low-pass circuit (series RC circuit) to filter out a noisy signal. Task You may work in groups of up to 2 members. Design a series RC circuit that will filter out noise above (\\f_c) but not signal below (\\f_c) (ie. the cutoff frequency should be within 10% of (\\f_c)). You can use any of the resistors and capacitors you have in your lab kit. (\\f_c) is the last four digits of one of the group member's student number (Hz). Apply a signal with a 3V DC offset with at (\\f_c) 1Vpp triangular (saw) wave to simulate noise to your circuit. Remember the function generator should be set to High-Z mode. Using the DSO, demostrate that the 1Vpp noise is reduced to less then 70.7% of the original level after passing through your circuit (ie. show the raw signal with noise and the filtered signal). Document your procedure and result in a lab report. Deliverables Plagiarism is using another individual\u2019s (INCLUDING AI) work (e.g., words, images, ideas, logic, phrases, signatures or computations) and presenting it as one\u2019s own, without properly citing the source. Refer to: Academic Integrity Policy A lab report of no more than 5 pages and less than 1000 words consisting of the following sections: Introduction of the problem being studied and any relevant background information regarding to low-pass filter. (max. 300 words) Methods and Materials describing your circuit, and the materials and steps you used to test your circuit. This section must consist of figures and photos of: list of materials/components used list of steps you've taken (ie. someone must be able to repeat what you've done) circuit diagram breadboard diagram photos of your component setup on a breadboard photos of your test using a function generator and DSO Results from testing of your circuit by showing photos or a descriptive sketch of what you see from the DSO and measurement of any relevant voltage or current readings Discussion of your finding and explain what you see from the result. How can you prove that the 1kHz noise is filtered to 70.7%? Also discussed the following if applicable: Are there any unexpected results or errors? If you suspect any errors, analyze them. Explain your result with relevant theories. Conclusion of what you've done, what challenges you faced, and what you've learned. Reference to cite any resource you've used in your introduction, methods, or discussion section. (Not included in pages and word count) The report must be in PDF format with the name and student number of all members. Deadline and Late Submission Submit the lab report on Blackboard by the submission deadline. Only one submission is required per group. Any late submission will receive a 50% mark deduction within 24 hours after the deadline, no mark will be rewarded afterwards. Marking Rubrics Introduction (10 marks) Did this section clearly explain all necessary concepts and theories to understand the problem? Yes Somewhat Minimal No Marks 10 7 5 0 Methods and Materials (5 marks) Did this section list all materials/components used? Yes Somewhat No Marks 5 3 0 (25 marks) Did this section list all steps that were taken with photos and figures (ie. someone must be able to repeat what you've done) Yes Somewhat Minimal No Marks 25 15 10 0 (5 marks) Did this section contain a diagram of the circuit? Yes Somewhat No Marks 5 3 0 (5 marks) Did this section contain a diagram of the breadboard configuration? Yes Somewhat No Marks 5 3 0 Results (10 marks) Did this section display results from the testing by showing photos or descriptive sketches of what you see from the DSO and measurement of any relevant voltage or current readings without any bias discussion? Yes Somewhat Minimal No Marks 10 7 5 0 Discussion (20 marks) Did this section clearly explain the result and finding by providing a good discussion of the test and prove? Yes Somewhat Minimal No Marks 20 14 10 0 Conclusion (10 marks) Did this section provide a clear summary of what you've done, what challenges you faced, and what you've learned? Yes Somewhat Minimal No Marks 10 7 5 0 Reference (10 marks) Was a proper citation given in a recognizable reference format such as IEEE or MLA? Yes Somewhat Minimal No Marks 10 7 5 0","title":"Lab Project : RC Lowpass Filters"},{"location":"ses250/lab-project/#lab-project-rc-lowpass-filters","text":"Seneca Polytechnic SES250 Electromagnatics Due Date: Friday, Apr 11, 2025, 11:59 PM","title":"Lab Project : RC Lowpass Filters"},{"location":"ses250/lab-project/#purposes","text":"To understand simple capacitive low-pass filter circuit To understand how to write a lab report","title":"Purposes"},{"location":"ses250/lab-project/#objectives","text":"Assemble electronic components onto a breadboard Measure the filtering of signals using a Digital Storage Oscilloscope (DSO) Document your processes and results in a lab report","title":"Objectives"},{"location":"ses250/lab-project/#description","text":"Using what you've learned from Lab 7 and Lab 8 about capacitive and low-pass filters, your task is to create a capacitive low-pass circuit (series RC circuit) to filter out a noisy signal.","title":"Description"},{"location":"ses250/lab-project/#task","text":"You may work in groups of up to 2 members. Design a series RC circuit that will filter out noise above (\\f_c) but not signal below (\\f_c) (ie. the cutoff frequency should be within 10% of (\\f_c)). You can use any of the resistors and capacitors you have in your lab kit. (\\f_c) is the last four digits of one of the group member's student number (Hz). Apply a signal with a 3V DC offset with at (\\f_c) 1Vpp triangular (saw) wave to simulate noise to your circuit. Remember the function generator should be set to High-Z mode. Using the DSO, demostrate that the 1Vpp noise is reduced to less then 70.7% of the original level after passing through your circuit (ie. show the raw signal with noise and the filtered signal). Document your procedure and result in a lab report.","title":"Task"},{"location":"ses250/lab-project/#deliverables","text":"Plagiarism is using another individual\u2019s (INCLUDING AI) work (e.g., words, images, ideas, logic, phrases, signatures or computations) and presenting it as one\u2019s own, without properly citing the source. Refer to: Academic Integrity Policy A lab report of no more than 5 pages and less than 1000 words consisting of the following sections: Introduction of the problem being studied and any relevant background information regarding to low-pass filter. (max. 300 words) Methods and Materials describing your circuit, and the materials and steps you used to test your circuit. This section must consist of figures and photos of: list of materials/components used list of steps you've taken (ie. someone must be able to repeat what you've done) circuit diagram breadboard diagram photos of your component setup on a breadboard photos of your test using a function generator and DSO Results from testing of your circuit by showing photos or a descriptive sketch of what you see from the DSO and measurement of any relevant voltage or current readings Discussion of your finding and explain what you see from the result. How can you prove that the 1kHz noise is filtered to 70.7%? Also discussed the following if applicable: Are there any unexpected results or errors? If you suspect any errors, analyze them. Explain your result with relevant theories. Conclusion of what you've done, what challenges you faced, and what you've learned. Reference to cite any resource you've used in your introduction, methods, or discussion section. (Not included in pages and word count) The report must be in PDF format with the name and student number of all members.","title":"Deliverables"},{"location":"ses250/lab-project/#deadline-and-late-submission","text":"Submit the lab report on Blackboard by the submission deadline. Only one submission is required per group. Any late submission will receive a 50% mark deduction within 24 hours after the deadline, no mark will be rewarded afterwards.","title":"Deadline and Late Submission"},{"location":"ses250/lab-project/#marking-rubrics","text":"","title":"Marking Rubrics"},{"location":"ses250/lab-project/#introduction","text":"(10 marks) Did this section clearly explain all necessary concepts and theories to understand the problem? Yes Somewhat Minimal No Marks 10 7 5 0","title":"Introduction"},{"location":"ses250/lab-project/#methods-and-materials","text":"(5 marks) Did this section list all materials/components used? Yes Somewhat No Marks 5 3 0 (25 marks) Did this section list all steps that were taken with photos and figures (ie. someone must be able to repeat what you've done) Yes Somewhat Minimal No Marks 25 15 10 0 (5 marks) Did this section contain a diagram of the circuit? Yes Somewhat No Marks 5 3 0 (5 marks) Did this section contain a diagram of the breadboard configuration? Yes Somewhat No Marks 5 3 0","title":"Methods and Materials"},{"location":"ses250/lab-project/#results","text":"(10 marks) Did this section display results from the testing by showing photos or descriptive sketches of what you see from the DSO and measurement of any relevant voltage or current readings without any bias discussion? Yes Somewhat Minimal No Marks 10 7 5 0","title":"Results"},{"location":"ses250/lab-project/#discussion","text":"(20 marks) Did this section clearly explain the result and finding by providing a good discussion of the test and prove? Yes Somewhat Minimal No Marks 20 14 10 0","title":"Discussion"},{"location":"ses250/lab-project/#conclusion","text":"(10 marks) Did this section provide a clear summary of what you've done, what challenges you faced, and what you've learned? Yes Somewhat Minimal No Marks 10 7 5 0","title":"Conclusion"},{"location":"ses250/lab-project/#reference","text":"(10 marks) Was a proper citation given in a recognizable reference format such as IEEE or MLA? Yes Somewhat Minimal No Marks 10 7 5 0","title":"Reference"},{"location":"ses250/lab1/","text":"Lab 1: Electrostatics and Triboelectric Series Seneca Polytechnic SES250 Electromagnetics Purposes To demonstrate that there are two types of electric charges in nature To become familiar with scientific experimental techniques To use experimental observation and apply logical reasoning to build a triboelectric series Objectives Perform qualitative observations of the following: The separation of electric charges by friction The existence of two types of charges The existence of electrostatic forces between charged objects Description Objects are usually electrically neutral. The number of positive and negative charges is typically equal. Neutral objects neither attract nor repel each other electrically. This balance of charge can be disrupted by rubbing an object against another, as further explained in Chapter 5.1 of University Physics Vol 2 , or by the presence of another nearby charged object, as further explained in Chapter 5.2 . In this lab, the attractive and/or repulsive electrostatic force between charged objects will be observed using a setup shown in Figure 1.1. You will confirm the presence of electric charges and the forces exerted by these charges. Figure 1.1 Lab 1 Setup Triboelectric Series \"The triboelectric series ranks various materials according to their tendency to gain or lose electrons, which reflects the natural physical property of materials. Static electricity occurs when there is an excess of positive or negative charges on an object\u2019s surface by rubbing certain materials together. The position of the material in the triboelectric series determines how effectively the charges will be exchanged. Normally, the build-up of static electricity would be undesirable because it can result in product failure or a serious safety hazard caused by electrostatic discharge and/or electrostatic attraction. This series can be used to select materials that will minimize static charging to prevent electrostatic discharge or electrostatic attraction.\" Source: Quantifying the triboelectric series by Zou et al. Materials A stand String or fishing line Paper clip Plastic straw (Polypropylene) Plastic wrap Wool cloth Glass rod Steel rod Wooden rod / dowel Silk cloth or cotton cloth Plastic rod (Acrylic) Preparation Answer all the lab preparation questions at the end of this document in your lab notebook BEFORE your lab session. Students who do not complete the lab preparation will be asked not to join the lab and will receive a grade of ZERO (0) for the lab. Lab preparation must be done individually in the lab notebook. Lab Preparation Questions Summarize the steps for this lab in your notebook as the computer in the lab room will NOT be available for this lab. Describe how you can neutralize your hand from electric charges in the lab room using the technique mentioned in the lab manual. Copy and fill in the following observation table in your notebook (except for the observation column): Step Object 1 Rubbed with Object 2 Rubbed with Observation (Attract/Repel) 6 Plastic Straw Wool Plastic Straw Wool 8 Plastic Straw Wool 9 Plastic Straw 12 13 Procedures If not enough stands are available, work in groups of 2. All questions in the lab must be answered individually, and every member must individually demonstrate completion of the lab. Place and secure the stand on the table. Attach a paper clip to a string, then hang the paper clip about 5 cm below the end hook of the stand. The paper clip is used to hold the plastic straw. Carefully secure a plastic straw onto the paper clip so it evenly sits on the paper clip and is free to rotate on the stand. NOTE: In some instances, it might be beneficial to hang the stand off the side of the table to allow full rotation of the straw once it is attached to the paper clip. Technique and attention to detail are key to this lab and in any of your future labs. Remove the plastic straw from the paper clip, then rub both ends of a plastic straw with the wool cloth. ONLY handle the middle of the straw as handling the ends you\u2019ve charged will alter its charge. Once charged, carefully suspend the plastic straw from the stand using the paper clip. ONLY handle the middle of the straw. What you\u2019ve done is charge the plastic straw NEGATIVELY (free electrons from the wool cloth are transferred onto the surface of the plastic straw). Note: If your hand touches the charged portion of the straw, your hand will discharge the straw, causing the charged portion to return to neutral. Next, rub one end of a second plastic straw in the same way, then hold it close to the first plastic straw (without touching) . Remember, do not hold the straw on the side that you\u2019ve charged. Observe the (attractive or repulsive) force exerted on the first plastic straw suspended from the stand. Lab Question 1: What interaction between the straws do you observe? Write it down into the observation table you created in the pre-lab. Lab Question 2: Which electrostatic law have you confirmed? Explain your answer by specifying the charge in each plastic straw. Ensure your hand is not charged by placing your palm on the metal surface or the rubber mat on the workbench. Then discharge the second plastic straw by slowly touching it (not rubbing) with your hand, then neutralize your hand. Repeat this a few times until the second straw no longer exerts any force on the first straw. Note: Technique is critical. You should often discharge yourself by placing your palm on the metal surface or the rubber mat of the workbench. We can assume they are connected to the ground (earth) and are electrically neutral. Recharge the second (now neutral) plastic straw by rubbing it with the plastic wrap. Hold it close to the first wool-charged plastic straw and observe the nature of the force. Lab Question 3: What interaction between the straws do you observe? Write it down into the observation table you created in the pre-lab. Lab Question 4: Use your observation to predict what type of charge is on the plastic wrap-rubbed straw (positive or negative). i.e., Did the plastic wrap-rubbed straw gain/lose electrons? Remember: It was previously stated that the wool-rubbed straw is charged negatively. Discharge the second plastic straw. Take a glass rod and charge it using the wool cloth. Hold it close to the first wool-charged plastic straw. WARNING! The glass rod is fragile! Handle with care! Lab Question 5: What interaction between the straw and the rod do you observe? Write it down into the observation table you created in the pre-lab. Use your observation to predict what type of charge is on the wool-rubbed glass rod (positive or negative). i.e., Did the wool-rubbed glass rod gain/lose electrons? Discharge the glass rod. WARNING! The glass rod is fragile! Handle with care! Lab Question 6: From the results in your observation table, which materials (plastic straw, wool, plastic wrap, glass rod) do you think will most likely gain electrons and which will most likely lose electrons? For example: We defined the straw as negatively charged when rubbed with wool. Therefore, the straw is more likely to gain electrons than the wool. The steps above demonstrate the triboelectric effects and electrostatic force between two charged objects. In the next steps, you will observe the force between a charged object and a neutral object. Touch a metal surface on the workbench to ensure your hand is not charged. Discharge the plastic straw on the stand and the glass rod with your hand until there is no electrostatic force between them when holding them near one another. Leaving the plastic straw neutral, charge the glass rod with the wool cloth. Hold the glass rod close to the plastic straw. Lab Question 7: What interaction between the rod and the straw do you observe? Write it down into the observation table you created in the pre-lab. Why is the neutral plastic straw attracted to the glass rod? Explain the phenomenon and discuss how this can draw you to the wrong conclusion regarding the charge on each object. Refer to Chapter 5.2 in the University Physics Volume 2 textbook if required. The steps above demonstrate transferring charges on the surface of insulators. In the next step, you will observe what will happen when charging a conducting object. Leaving the neutral plastic straw suspended, rub one end of a steel rod with the wool cloth, then hold it near the neutral plastic straw. Lab Question 8: What interaction between the rod and the straw do you observe? Write it down into the observation table you created in the pre-lab. Explain the phenomenon. Refer to Chapter 5.2 in the University Physics Volume 2 textbook if required. Once you've completed all the above steps, ask the lab professor or instructor to come over and demonstrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab. Bonus Using the concept you've acquired from the steps above, extend your observation table and determine where the Plastic Rod, Silk or Cotton Cloth, or Wooden Rod / Dowel is on the triboelectric series in Question 6. (5% of Lab Work mark for each material). You must show your experimental steps and observations. Read the following cases to understand the logic: Case 1: Plastic Wrap If Material-A is rubbed with Plastic Wrap, Material-A is positively charged (loses electrons) because the Plastic Wrap is more negative (gains electrons). Case 2: If Material-A rubbed with Material-B is attracted to Material-C rubbed with Material-B, then we know the charge on Material-A is opposite to the charge on Material-C. However, to determine which one is positively charged and which one is negatively charged, we must know the properties of Material-B relative to Material-A and Material-C. As a result, always start your experiment with the known material (Plastic Wrap). Once you've completed all the above steps, ask the lab professor or instructor to come over and demonstrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 1: Electrostatics and Triboelectric Series"},{"location":"ses250/lab1/#lab-1-electrostatics-and-triboelectric-series","text":"Seneca Polytechnic SES250 Electromagnetics","title":"Lab 1: Electrostatics and Triboelectric Series"},{"location":"ses250/lab1/#purposes","text":"To demonstrate that there are two types of electric charges in nature To become familiar with scientific experimental techniques To use experimental observation and apply logical reasoning to build a triboelectric series","title":"Purposes"},{"location":"ses250/lab1/#objectives","text":"Perform qualitative observations of the following: The separation of electric charges by friction The existence of two types of charges The existence of electrostatic forces between charged objects","title":"Objectives"},{"location":"ses250/lab1/#description","text":"Objects are usually electrically neutral. The number of positive and negative charges is typically equal. Neutral objects neither attract nor repel each other electrically. This balance of charge can be disrupted by rubbing an object against another, as further explained in Chapter 5.1 of University Physics Vol 2 , or by the presence of another nearby charged object, as further explained in Chapter 5.2 . In this lab, the attractive and/or repulsive electrostatic force between charged objects will be observed using a setup shown in Figure 1.1. You will confirm the presence of electric charges and the forces exerted by these charges. Figure 1.1 Lab 1 Setup","title":"Description"},{"location":"ses250/lab1/#triboelectric-series","text":"\"The triboelectric series ranks various materials according to their tendency to gain or lose electrons, which reflects the natural physical property of materials. Static electricity occurs when there is an excess of positive or negative charges on an object\u2019s surface by rubbing certain materials together. The position of the material in the triboelectric series determines how effectively the charges will be exchanged. Normally, the build-up of static electricity would be undesirable because it can result in product failure or a serious safety hazard caused by electrostatic discharge and/or electrostatic attraction. This series can be used to select materials that will minimize static charging to prevent electrostatic discharge or electrostatic attraction.\" Source: Quantifying the triboelectric series by Zou et al.","title":"Triboelectric Series"},{"location":"ses250/lab1/#materials","text":"A stand String or fishing line Paper clip Plastic straw (Polypropylene) Plastic wrap Wool cloth Glass rod Steel rod Wooden rod / dowel Silk cloth or cotton cloth Plastic rod (Acrylic)","title":"Materials"},{"location":"ses250/lab1/#preparation","text":"Answer all the lab preparation questions at the end of this document in your lab notebook BEFORE your lab session. Students who do not complete the lab preparation will be asked not to join the lab and will receive a grade of ZERO (0) for the lab. Lab preparation must be done individually in the lab notebook.","title":"Preparation"},{"location":"ses250/lab1/#lab-preparation-questions","text":"Summarize the steps for this lab in your notebook as the computer in the lab room will NOT be available for this lab. Describe how you can neutralize your hand from electric charges in the lab room using the technique mentioned in the lab manual. Copy and fill in the following observation table in your notebook (except for the observation column): Step Object 1 Rubbed with Object 2 Rubbed with Observation (Attract/Repel) 6 Plastic Straw Wool Plastic Straw Wool 8 Plastic Straw Wool 9 Plastic Straw 12 13","title":"Lab Preparation Questions"},{"location":"ses250/lab1/#procedures","text":"If not enough stands are available, work in groups of 2. All questions in the lab must be answered individually, and every member must individually demonstrate completion of the lab. Place and secure the stand on the table. Attach a paper clip to a string, then hang the paper clip about 5 cm below the end hook of the stand. The paper clip is used to hold the plastic straw. Carefully secure a plastic straw onto the paper clip so it evenly sits on the paper clip and is free to rotate on the stand. NOTE: In some instances, it might be beneficial to hang the stand off the side of the table to allow full rotation of the straw once it is attached to the paper clip. Technique and attention to detail are key to this lab and in any of your future labs. Remove the plastic straw from the paper clip, then rub both ends of a plastic straw with the wool cloth. ONLY handle the middle of the straw as handling the ends you\u2019ve charged will alter its charge. Once charged, carefully suspend the plastic straw from the stand using the paper clip. ONLY handle the middle of the straw. What you\u2019ve done is charge the plastic straw NEGATIVELY (free electrons from the wool cloth are transferred onto the surface of the plastic straw). Note: If your hand touches the charged portion of the straw, your hand will discharge the straw, causing the charged portion to return to neutral. Next, rub one end of a second plastic straw in the same way, then hold it close to the first plastic straw (without touching) . Remember, do not hold the straw on the side that you\u2019ve charged. Observe the (attractive or repulsive) force exerted on the first plastic straw suspended from the stand. Lab Question 1: What interaction between the straws do you observe? Write it down into the observation table you created in the pre-lab. Lab Question 2: Which electrostatic law have you confirmed? Explain your answer by specifying the charge in each plastic straw. Ensure your hand is not charged by placing your palm on the metal surface or the rubber mat on the workbench. Then discharge the second plastic straw by slowly touching it (not rubbing) with your hand, then neutralize your hand. Repeat this a few times until the second straw no longer exerts any force on the first straw. Note: Technique is critical. You should often discharge yourself by placing your palm on the metal surface or the rubber mat of the workbench. We can assume they are connected to the ground (earth) and are electrically neutral. Recharge the second (now neutral) plastic straw by rubbing it with the plastic wrap. Hold it close to the first wool-charged plastic straw and observe the nature of the force. Lab Question 3: What interaction between the straws do you observe? Write it down into the observation table you created in the pre-lab. Lab Question 4: Use your observation to predict what type of charge is on the plastic wrap-rubbed straw (positive or negative). i.e., Did the plastic wrap-rubbed straw gain/lose electrons? Remember: It was previously stated that the wool-rubbed straw is charged negatively. Discharge the second plastic straw. Take a glass rod and charge it using the wool cloth. Hold it close to the first wool-charged plastic straw. WARNING! The glass rod is fragile! Handle with care! Lab Question 5: What interaction between the straw and the rod do you observe? Write it down into the observation table you created in the pre-lab. Use your observation to predict what type of charge is on the wool-rubbed glass rod (positive or negative). i.e., Did the wool-rubbed glass rod gain/lose electrons? Discharge the glass rod. WARNING! The glass rod is fragile! Handle with care! Lab Question 6: From the results in your observation table, which materials (plastic straw, wool, plastic wrap, glass rod) do you think will most likely gain electrons and which will most likely lose electrons? For example: We defined the straw as negatively charged when rubbed with wool. Therefore, the straw is more likely to gain electrons than the wool. The steps above demonstrate the triboelectric effects and electrostatic force between two charged objects. In the next steps, you will observe the force between a charged object and a neutral object. Touch a metal surface on the workbench to ensure your hand is not charged. Discharge the plastic straw on the stand and the glass rod with your hand until there is no electrostatic force between them when holding them near one another. Leaving the plastic straw neutral, charge the glass rod with the wool cloth. Hold the glass rod close to the plastic straw. Lab Question 7: What interaction between the rod and the straw do you observe? Write it down into the observation table you created in the pre-lab. Why is the neutral plastic straw attracted to the glass rod? Explain the phenomenon and discuss how this can draw you to the wrong conclusion regarding the charge on each object. Refer to Chapter 5.2 in the University Physics Volume 2 textbook if required. The steps above demonstrate transferring charges on the surface of insulators. In the next step, you will observe what will happen when charging a conducting object. Leaving the neutral plastic straw suspended, rub one end of a steel rod with the wool cloth, then hold it near the neutral plastic straw. Lab Question 8: What interaction between the rod and the straw do you observe? Write it down into the observation table you created in the pre-lab. Explain the phenomenon. Refer to Chapter 5.2 in the University Physics Volume 2 textbook if required. Once you've completed all the above steps, ask the lab professor or instructor to come over and demonstrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Procedures"},{"location":"ses250/lab1/#bonus","text":"Using the concept you've acquired from the steps above, extend your observation table and determine where the Plastic Rod, Silk or Cotton Cloth, or Wooden Rod / Dowel is on the triboelectric series in Question 6. (5% of Lab Work mark for each material). You must show your experimental steps and observations. Read the following cases to understand the logic: Case 1: Plastic Wrap If Material-A is rubbed with Plastic Wrap, Material-A is positively charged (loses electrons) because the Plastic Wrap is more negative (gains electrons). Case 2: If Material-A rubbed with Material-B is attracted to Material-C rubbed with Material-B, then we know the charge on Material-A is opposite to the charge on Material-C. However, to determine which one is positively charged and which one is negatively charged, we must know the properties of Material-B relative to Material-A and Material-C. As a result, always start your experiment with the known material (Plastic Wrap). Once you've completed all the above steps, ask the lab professor or instructor to come over and demonstrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Bonus"},{"location":"ses250/lab10/","text":"Lab 10: RLC Circuit Resonance Seneca Polytechnic SES250 Electromagnetics Purposes To examine the AC response of an RLC circuit and find the resonance frequency. Objectives Assemble electronic components onto a breadboard. Set up a function generator to output an AC sine wave. Build an RLC circuit for resonant frequency measurement. Description An RLC circuit is an electrical circuit consisting of a resistor (R), an inductor (L), and a capacitor (C), connected in series or parallel. The circuit forms a harmonic oscillator for current and resonates in a manner similar to an LC circuit. Introducing the resistor increases the decay of these oscillations, which is also known as damping. The resistor also reduces the peak resonant frequency. In such circuit, the current amplitude is: I_{0} = { V_{0} \\over \\sqrt { R^2 + ( \\omega L \u2212 1 / \\omega C )^2 } } An important property of this circuit is its ability to resonate at a specific frequency, known as the resonance frequency, f_{0} . Its angular frequency alternative, \\omega_{0} , is given as: \\omega_{0} = 2 \\pi f_0 The resonant frequency is defined as the frequency at which the impedance of the circuit is at a minimum. Equivalently, it can be defined as the frequency at which the impedance is purely real (i.e., purely resistive). This occurs because the impedances of the inductor and capacitor at resonance are equal but of opposite sign and cancel each other out. The resonant frequency for an RLC circuit is: \\omega_{0} = \\frac{1}{\\sqrt{LC}} If we can vary the frequency of the AC source while keeping the amplitude of its output voltage constant, then the current changes accordingly. A plot of I_{0} versus \\omega is shown in Figure 10.1. Figure 10.1 At an RLC circuit\u2019s resonant frequency, \\omega_{0}=\\sqrt{1/LC} , the current amplitude is at its maximum value. Source: University Physic Vol 2: 15.5 Resonance in an AC Circuit Wikipedia: RLC circuit Reference Series RLC Circuit Impedance Calculator Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper wires (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100nF ceramic capacitor (1x) 100\u03bcH drum inductor Preparation Lab Preparation Questions: Read and summarize the lab as necessary. Sketch a breadboard diagram of Figure 10.2 in your notebook. Copy observation Table 1 from this lab into your notebook. Calculate the theoretical phase shift for each of the frequency in Table 1 for a series RLC circuit in AC with a 10k\u03a9 resistor, 100nF capacitor, and 100\u03bcH inductor. Show the calculation for at least one value. Fill in the theoretical phase shift column in Table 1. Calculate the theoretical resonant frequency for a series RLC circuit in AC with a 10k\u03a9 resistor, 100nF capacitor, and 100\u03bcH inductor. Show all calculations. Procedures In this lab, we'll observe the AC response of an RLC circuit and the relationship between the voltage V(t) and the current I(t) using an oscilloscope. Since we cannot measure I(t) directly with an oscilloscope, we'll measure the voltage across the resistor V_R(t) , as the current and voltage are always in phase at the resistor. Figure 10.2 Set up the circuit in Figure 10.2 using a 10k\u03a9 resistor, a 100nF ceramic capacitor, and a 100\u03bcH. DO NOT USE A POLARIZED CAPACITOR! Ensure that the function generator\u2019s output is off, then set the output of the function generator to High-Z. Set the output waveform to a sine wave, then set the output amplitude to 6 Vpp and the frequency to 10.0 Hz. Leave offset voltage and phase at 0. Turn on the oscilloscope, then connect CH1 and CH2 to the circuit per the circuit diagram. NOTE: The ground (black cable) for both CH1 and CH2 is connected to the negative (black) node of the function generator. Turn on the function generator output and observe the relationship between CH1 and CH2. Adjust the voltage and time division to display about two periods on the screen. From the two signals, find time difference \\Delta t using a zero crossing (or peak) from CH1 (measuring V(t) ) and the closest zero crossing (or peak) from CH2 (measuring V_R(t) \\propto I(t) ). You may use the horizontal position knob to move one of the signals to the center for easier measurement. Also write down the V_R peak-to-peak into Table 1. Lab Question 1: Convert this time difference to the phase angle difference using the formula below. Does it agree with the phase angle difference you calculated in your pre-lab? Write your result in Table 1. \\phi = 2 \\pi {\\Delta t \\over T} \\phi = 360\u00b0 {\\Delta t \\over T} NOTE: If I(t) is leading, the time difference will be negative. Also, the time difference might be in [ms] and the phase angle difference might be in [RAD] depending on your setting. Table 1: Frequency Theoretical \\phi \\Delta t \\phi V_{R_{pp}} \\|I\\| \\|Z_T\\| 10 Hz 500 Hz 1 kHz 5 kHz 10 kHz 50 kHz 100 kHz 200 kHz 500 kHz 1 MHz ... Leave extra lines for additional data points. Using the measured peak-to-peak V_R , calculate the magnitude of the current \\|I\\| and the magnitude of the total impedance \\|Z_T\\| . Lab Question 2: Calculate the magnitude of the current and the magnitude of the total impedance and record your answers in Table 1. \\|I\\| = \\frac{V_R}{R} \\|Z_T\\| = \\frac{V_S}{\\|I\\|} Open a spreadsheet software and plot the data. Lab Question 3: Using the data from Table 1, open a spreadsheet software (Excel, Sheet, or similar) and plot the following against frequency (x-axis): Series 1: Phase Shift \\phi Series 2: Magnitude of the Current \\|I\\| Series 3: Magnitude of the Total Impedance \\|Z_T\\| Repeat the measurements at more frequencies until a minimum phase shift is found. Lab Question 4: Using the additional data you recorded in Table 1 and your plots, what do you observe regarding to \\|I\\| and \\|Z_T\\| when the phase shift is at it's minimum, \\phi \\approx 0 ? Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 10: RLC Circuit Resonance"},{"location":"ses250/lab10/#lab-10-rlc-circuit-resonance","text":"Seneca Polytechnic SES250 Electromagnetics","title":"Lab 10: RLC Circuit Resonance"},{"location":"ses250/lab10/#purposes","text":"To examine the AC response of an RLC circuit and find the resonance frequency.","title":"Purposes"},{"location":"ses250/lab10/#objectives","text":"Assemble electronic components onto a breadboard. Set up a function generator to output an AC sine wave. Build an RLC circuit for resonant frequency measurement.","title":"Objectives"},{"location":"ses250/lab10/#description","text":"An RLC circuit is an electrical circuit consisting of a resistor (R), an inductor (L), and a capacitor (C), connected in series or parallel. The circuit forms a harmonic oscillator for current and resonates in a manner similar to an LC circuit. Introducing the resistor increases the decay of these oscillations, which is also known as damping. The resistor also reduces the peak resonant frequency. In such circuit, the current amplitude is: I_{0} = { V_{0} \\over \\sqrt { R^2 + ( \\omega L \u2212 1 / \\omega C )^2 } } An important property of this circuit is its ability to resonate at a specific frequency, known as the resonance frequency, f_{0} . Its angular frequency alternative, \\omega_{0} , is given as: \\omega_{0} = 2 \\pi f_0 The resonant frequency is defined as the frequency at which the impedance of the circuit is at a minimum. Equivalently, it can be defined as the frequency at which the impedance is purely real (i.e., purely resistive). This occurs because the impedances of the inductor and capacitor at resonance are equal but of opposite sign and cancel each other out. The resonant frequency for an RLC circuit is: \\omega_{0} = \\frac{1}{\\sqrt{LC}} If we can vary the frequency of the AC source while keeping the amplitude of its output voltage constant, then the current changes accordingly. A plot of I_{0} versus \\omega is shown in Figure 10.1. Figure 10.1 At an RLC circuit\u2019s resonant frequency, \\omega_{0}=\\sqrt{1/LC} , the current amplitude is at its maximum value. Source: University Physic Vol 2: 15.5 Resonance in an AC Circuit Wikipedia: RLC circuit","title":"Description"},{"location":"ses250/lab10/#reference","text":"Series RLC Circuit Impedance Calculator","title":"Reference"},{"location":"ses250/lab10/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper wires (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100nF ceramic capacitor (1x) 100\u03bcH drum inductor","title":"Materials"},{"location":"ses250/lab10/#preparation","text":"Lab Preparation Questions: Read and summarize the lab as necessary. Sketch a breadboard diagram of Figure 10.2 in your notebook. Copy observation Table 1 from this lab into your notebook. Calculate the theoretical phase shift for each of the frequency in Table 1 for a series RLC circuit in AC with a 10k\u03a9 resistor, 100nF capacitor, and 100\u03bcH inductor. Show the calculation for at least one value. Fill in the theoretical phase shift column in Table 1. Calculate the theoretical resonant frequency for a series RLC circuit in AC with a 10k\u03a9 resistor, 100nF capacitor, and 100\u03bcH inductor. Show all calculations.","title":"Preparation"},{"location":"ses250/lab10/#procedures","text":"In this lab, we'll observe the AC response of an RLC circuit and the relationship between the voltage V(t) and the current I(t) using an oscilloscope. Since we cannot measure I(t) directly with an oscilloscope, we'll measure the voltage across the resistor V_R(t) , as the current and voltage are always in phase at the resistor. Figure 10.2 Set up the circuit in Figure 10.2 using a 10k\u03a9 resistor, a 100nF ceramic capacitor, and a 100\u03bcH. DO NOT USE A POLARIZED CAPACITOR! Ensure that the function generator\u2019s output is off, then set the output of the function generator to High-Z. Set the output waveform to a sine wave, then set the output amplitude to 6 Vpp and the frequency to 10.0 Hz. Leave offset voltage and phase at 0. Turn on the oscilloscope, then connect CH1 and CH2 to the circuit per the circuit diagram. NOTE: The ground (black cable) for both CH1 and CH2 is connected to the negative (black) node of the function generator. Turn on the function generator output and observe the relationship between CH1 and CH2. Adjust the voltage and time division to display about two periods on the screen. From the two signals, find time difference \\Delta t using a zero crossing (or peak) from CH1 (measuring V(t) ) and the closest zero crossing (or peak) from CH2 (measuring V_R(t) \\propto I(t) ). You may use the horizontal position knob to move one of the signals to the center for easier measurement. Also write down the V_R peak-to-peak into Table 1. Lab Question 1: Convert this time difference to the phase angle difference using the formula below. Does it agree with the phase angle difference you calculated in your pre-lab? Write your result in Table 1. \\phi = 2 \\pi {\\Delta t \\over T} \\phi = 360\u00b0 {\\Delta t \\over T} NOTE: If I(t) is leading, the time difference will be negative. Also, the time difference might be in [ms] and the phase angle difference might be in [RAD] depending on your setting. Table 1: Frequency Theoretical \\phi \\Delta t \\phi V_{R_{pp}} \\|I\\| \\|Z_T\\| 10 Hz 500 Hz 1 kHz 5 kHz 10 kHz 50 kHz 100 kHz 200 kHz 500 kHz 1 MHz ... Leave extra lines for additional data points. Using the measured peak-to-peak V_R , calculate the magnitude of the current \\|I\\| and the magnitude of the total impedance \\|Z_T\\| . Lab Question 2: Calculate the magnitude of the current and the magnitude of the total impedance and record your answers in Table 1. \\|I\\| = \\frac{V_R}{R} \\|Z_T\\| = \\frac{V_S}{\\|I\\|} Open a spreadsheet software and plot the data. Lab Question 3: Using the data from Table 1, open a spreadsheet software (Excel, Sheet, or similar) and plot the following against frequency (x-axis): Series 1: Phase Shift \\phi Series 2: Magnitude of the Current \\|I\\| Series 3: Magnitude of the Total Impedance \\|Z_T\\| Repeat the measurements at more frequencies until a minimum phase shift is found. Lab Question 4: Using the additional data you recorded in Table 1 and your plots, what do you observe regarding to \\|I\\| and \\|Z_T\\| when the phase shift is at it's minimum, \\phi \\approx 0 ? Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Procedures"},{"location":"ses250/lab2/","text":"Lab 2 : Digital Multimeter, Power Supply, and Ohm's Law Seneca Polytechnic SES250 Electromagnatics Purposes To learn how to operate the power supply and digital multimeter (DMM) To become familiar with measurement techniques of direct current (DC) To study the relationship between voltage, resistance, and current To verify Ohm's Law Objectives Operate a DC power supply Setup and read measurements from a digital multimeter (DMM) Assemble electronic components onto a breadboard Measure voltage from a breadboard using a digital multimeter (DMM) Important Rules for this Lab Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit. Description Direct Current (DC) Direct current (DC) is the one-directional flow of electric charge. An electrochemical cell is a prime example of DC power. Direct current may flow through a conductor such as a wire, but can also flow through semiconductors, insulators, or even through a vacuum as in electron or ion beams. The electric current flows in a constant direction, distinguishing it from alternating current (AC). Source: Wikipedia: Direct Current Digital Multimeter (DMM) A multimeter is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current. However, some multimeters, such as the one in the electronics lab, can also measure capacitance. Digital multimeters (DMM) have numeric displays and have made analog multimeters obsolete as they are cheaper, more precise, and more physically robust than analog multimeters. Source: Wikipedia: Multimeter Figure 2.1 Keysight 34461A Digital Multimeter In the electronics lab, you will be using a Keysight 34461A (or similar) Digital Multimeter. Its manual can be found here: DMM Manual Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Voltage Direct Current (DC) Power Supply An adjustable DC power supply converts electricity from the power grid to a specified voltage and current and then provides them at its output connector. Figure 2.2 Agilent E3632A DC Power Supply In the electronics lab, you will be using an Agilent E3632A (or E3631A or similar) DC Power Supply. Its manual can be found here: DC Power Supply Manual Reference Video: How to Use A KEYSIGHT E3631A Bench Power Supply Resistor A resistor is a passive two-terminal electrical component that implements electrical resistance as a circuit element. In electronic circuits, resistors are used to reduce current flow, adjust signal levels, divide voltages, bias active elements, and terminate transmission lines, among other uses. A resistor\u2019s resistance is specified by a colour code on the resistor as per Figure 2.3. Source: Wikipedia: Resistor Figure 2.3 Resistor Band Colour Breadboard An electronics breadboard is a solderless circuit prototyping board. They are great for making temporary circuits and prototyping, and they require no soldering. Source: SparkFun: How to User a Breadboard The internal conductive strip of the breadboard is assembly such a way that: all tie points of the top power rail (labelled red) are inter-connected all tie points of the top ground rail (labelled blue) are inter-connected all tie points of the bottom power rail (labelled red) are inter-connected all tie points of the bottom ground rail (labelled blue) are inter-connected each row (1-63) from column \u201ca\u201d to \u201ce\u201d are inter-connected each row (1-63) from column \u201cf\u201d to \u201cj\u201d are inter-connected Figures 2.4 and 2.5 are photos of a full-size breadboard and a half-size breadboard. Note how the tie points are connected by the metal strips. Only one component connection should connect to each tie-point. Figure 2.6 shows an electrical connection sketch of a half-size breadboard. Figure 2.4 Full-Size 830 Tie Points Breadboard Figure 2.5 Half-Size 400 Tie Points Breadboard and Showing of Internal Conductive Strips Figure 2.6 Half-Size 400 Tie Points Breadboard Electrical Sketch Circuit Symbols When expressing an electronic circuit in a diagram, circuit symbols are used. Below are some of the circuit symbols that you'll see in the lab. Figure 2.7 Circuit Symbols Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires 1k\u03a9 Resistor (brown-black-red) Preparation Answer all the lab preparation questions at the end of this document in your lab notebook BEFORE your lab session. Students who did not complete the lab preparation will be asked not to join the lab and receive a grade of ZERO (0) for the lab. Lab preparation must be done individually in the lab notebook. Lab Preparation Question: READ OVER ALL THE LAB BACKGROUND AND LAB STEPS. Copy the following observation table in your notebook for this lab: Table 1: Output: +1V Output: +2V Output: +5V Output: +10V Range: 100mV Range: 1V Range: 10V Range: 100V Range: 1000V Copy Figure 2.13 (with the power supply and resistor symbol) into your notebook then add a voltmeter (symobl) and its connection into the diagram according to the circuit in Figure 2.14. Research: Besides voltage, resistance, and current, list two other electronics-related properties a modem DMM can measure. In your words, explain the difference between the two ON/OFF settings (Power ON/OFF and Output ON/OFF) of the DC power supply we use in this lab. Using Ohm's Law: V = IR , calculate the current through a 1k\u03a9 resistor if 5V of potential difference is applied across the resistor. Procedures Part 1: Safety Ensure that you are wearing your safety glasses, not wearing open-toe shoes, and any long hair must be tied up. At the top of your workbench, you\u2019ll see a red \u201cEmergency Stop\u201d button (shown in Figure 2.8). At any time when the button is in the pressed position, your workbench will be disconnected from the power source. Press this button if there are any issues with your equipment or circuit (such as unusual heat, unusual smell, smoke, spark, or fire). To release the button, twist it as per the symbol on the button and the button will no longer be pressed. Figure 2.8 Emergency Stop Button Ensure the Emergency Stop button is in the released position. Part 2: Digital Multimeter (DMM) and DC Voltage Measurement Assemble the 1k\u03a9 resistor (brown-black-red) from the lab materials onto the breadboard as shown in Figure 2.9. Ensure the two leads of the resistor are on different rows on the breadboard so they are not electrically connected (shorted). The exact tie-point to use within the column doesn't matter are they are electrically connected. Figure 2.9 Identify the digital multimeter (DMM) at your workbench. If there are two DMMs, use the one on the left-hand side. Disconnect any cables that are plugged into it so the DMM is as shown in Figure 2.10 below. Figure 2.10 Set the DMM to DC voltage measurement mode as follows: If the DMM is not already powered on, push the power button (1). Once the DMM is ON, push the DC voltage (DCV) measurement mode button (4). If the \u201cRange\u201d indicator (3) is not showing \u201cAuto\u201d, press the menu button under \u201cRange\u201d (2) and change it to \u201cAuto\u201d. Identify the two cables that are next to the DMM with a banana connector on one end and an alligator clip on the other end. Connect the banana connector from the red cable to the red terminal labelled with \u201cHI\u201d under \u201cInput V\u03a9\u25ba|\u201d (5). Connect the banana connector from the black cable to the black terminal labelled with \u201cLO\u201d under \u201cInput V\u03a9\u25ba|\u201d (6) Figure 2.11 Verify the cables are connected as shown in Figure 2.5 above. At this point, your DMM is set up to measure direct current (DC) voltage. We\u2019ll be discussing direct current voltage during class. Remember this configuration for future labs and careers as measuring DC voltage is a very important skill for working with electronics. Identify the DC power supply at your workbench. If there are two DC power supplies, use the one that's most similar to the one shown. Disconnect any cables that are plugged in so it is as shown in Figure 2.11 below. Figure 2.12 Turn on the DC power supply (1) and then press the \u201cDisplay Limit\u201d button (2). Select the appropriate output voltage range (10) and use the lowest possible setting for a 5V output. In Figure 2.6 above, the lowest setting is \"15V, 7A\", however, the lowest output range varies between different models of power supply. Adjust the voltage output to +5.000V (9) using the digit selector (6) and the adjustment knob (7). Depending on the model of the power supply, the number of significant figures of the voltage output might be different. Identify the black cable with two leads that are next to the DC power supply with a banana connector on one end and an alligator clip on the other end. Connect the red banana connector from the cable to the red \u201cOutput\u201d terminal labelled with \u201c+\u201d (9) NOTE: In some models of power supply, there might be multiple output terminals. connect to the appropriate output terminal depending on the output range you selected earlier. Connect the black banana connector from the cable to the black \u201cOutput\u201d terminal labelled with \u201c-\u201c (10) You\u2019ve now set up the power supply for DC output. Attach a jumper cable to each of the alligator clips as shown in Figure 2.12. It can be jumper wire of any type and colour. Figure 2.12 SHORT CIRCUIT WARNING: Ensure the exposed portion of the red alligator clip or wire is NOT touching the exposed portion of the black alligator clip or wire. Connect the jumper wire from the red cable of the power supply to the same row as the first resistor lead. Then connect the jumper wire from the black cable of the power supply to the same row as the second resistor lead to assemble the circuit below. Figure 2.13 Connect the jumper wire from the red cable of the DMM to the same row as the first resistor lead. Then connect the jumper wire from the black cable of the DMM to the same row as the second resistor lead. Figure 2.14 Figure 2.15 Press the \"Display Limit\" button (2) on the power supply again and verify the voltage is adjusted to +5.000V and the banana cables are connected. Also, verify that the exposed portion of the red alligator clip is NOT touching the exposed portion of the black alligator clip. Turn on the power supply output by pressing the Output On/Off button (8). NOTE: There is a difference between the power supply being ON/OF and the power supply OUTPUT being ON/OFF. The power supply can be ON with its power output OFF. Notice that the DMM should now read about +5V, similar to as shown in Figure 2.15. Make a note of the range value beside the \u201cAuto\u201d on the DMM display. Figure 2.16 With the power supply output ON, adjust the output voltage to +13V. Note: If the output range does not allow you to go to 13V, switch the output range (10) and terminals as necessary. Lab Question 1: What happened to the Range setting on the DMM? If you don't notice the change, decrease the output voltage back to 5V and try again. Afterward, decrease the voltage of the DC power supply slowly to 5V. Lab Question 2: At what power supply voltage did the DMM change back to \u201cAuto 10V\u201d? How are the number of digits and decimal places the same or different when the voltage range changes? What does that mean for the accuracy of the readings? Using the DMM reading only, adjust the output voltage of the DC power supply so the reading on the DMM will display +1.000V. Note: Switch the output range and terminal as necessary. Lab Question 3: What is the output voltage of the DC power supply? Do they agree exactly with each other? If not, which one is higher and what is the percentage difference? /( % diff = diff / expected value /) Adjust the DC power supply output voltage to +1.000V then change the voltage Range on the DMM from \"Auto\" to \"100mV\" using the Range selection button. The DMM should display \"OVERLOAD\" because the 1V output from the power supply is higher than the maximum 100mV range that can be measured. Manually change the DMM \"Range\" setting and power supply voltage output according to the table below. Then record the voltage reading on the DMM in the and do this for DC output voltage of +1V, +2V, +5V, and +10V. NOTE: The reading might fluctuate but record at least 4 significant digits to the best of your ability in estimating AND record all LEADING ZEROS . Table 2: Output: +1V Output: +2V Output: +5V Output: +10V Range: 100mV OVERLOAD Range: 1V Range: 10V Range: 100V Range: 1000V Lab Question 4: If we want the most precise reading, what is the best setting for each DC output voltage in the table? Circle the most precise reading for each voltage output in the table above. Change the DMM \"Range\" setting back to Auto then set the power supply output back to 5V. Take a look at the current output value (Figure 2.11 (8)) from the power supply. Lab Question 5: Does this value agree with the Ohm's law calculation you made earlier in the pre-lab? DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BEEN MARKED BY THE INSTRUCTOR. Turn off the DC power supply and disconnect the alligator clips. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 2 : Digital Multimeter, Power Supply, and Ohm's Law"},{"location":"ses250/lab2/#lab-2-digital-multimeter-power-supply-and-ohms-law","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab 2 : Digital Multimeter, Power Supply, and Ohm's Law"},{"location":"ses250/lab2/#purposes","text":"To learn how to operate the power supply and digital multimeter (DMM) To become familiar with measurement techniques of direct current (DC) To study the relationship between voltage, resistance, and current To verify Ohm's Law","title":"Purposes"},{"location":"ses250/lab2/#objectives","text":"Operate a DC power supply Setup and read measurements from a digital multimeter (DMM) Assemble electronic components onto a breadboard Measure voltage from a breadboard using a digital multimeter (DMM)","title":"Objectives"},{"location":"ses250/lab2/#important-rules-for-this-lab","text":"Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit.","title":"Important Rules for this Lab"},{"location":"ses250/lab2/#description","text":"","title":"Description"},{"location":"ses250/lab2/#direct-current-dc","text":"Direct current (DC) is the one-directional flow of electric charge. An electrochemical cell is a prime example of DC power. Direct current may flow through a conductor such as a wire, but can also flow through semiconductors, insulators, or even through a vacuum as in electron or ion beams. The electric current flows in a constant direction, distinguishing it from alternating current (AC). Source: Wikipedia: Direct Current","title":"Direct Current (DC)"},{"location":"ses250/lab2/#digital-multimeter-dmm","text":"A multimeter is a measuring instrument that can measure multiple electrical properties. A typical multimeter can measure voltage, resistance, and current. However, some multimeters, such as the one in the electronics lab, can also measure capacitance. Digital multimeters (DMM) have numeric displays and have made analog multimeters obsolete as they are cheaper, more precise, and more physically robust than analog multimeters. Source: Wikipedia: Multimeter Figure 2.1 Keysight 34461A Digital Multimeter In the electronics lab, you will be using a Keysight 34461A (or similar) Digital Multimeter. Its manual can be found here: DMM Manual Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Voltage","title":"Digital Multimeter (DMM)"},{"location":"ses250/lab2/#direct-current-dc-power-supply","text":"An adjustable DC power supply converts electricity from the power grid to a specified voltage and current and then provides them at its output connector. Figure 2.2 Agilent E3632A DC Power Supply In the electronics lab, you will be using an Agilent E3632A (or E3631A or similar) DC Power Supply. Its manual can be found here: DC Power Supply Manual Reference Video: How to Use A KEYSIGHT E3631A Bench Power Supply","title":"Direct Current (DC) Power Supply"},{"location":"ses250/lab2/#resistor","text":"A resistor is a passive two-terminal electrical component that implements electrical resistance as a circuit element. In electronic circuits, resistors are used to reduce current flow, adjust signal levels, divide voltages, bias active elements, and terminate transmission lines, among other uses. A resistor\u2019s resistance is specified by a colour code on the resistor as per Figure 2.3. Source: Wikipedia: Resistor Figure 2.3 Resistor Band Colour","title":"Resistor"},{"location":"ses250/lab2/#breadboard","text":"An electronics breadboard is a solderless circuit prototyping board. They are great for making temporary circuits and prototyping, and they require no soldering. Source: SparkFun: How to User a Breadboard The internal conductive strip of the breadboard is assembly such a way that: all tie points of the top power rail (labelled red) are inter-connected all tie points of the top ground rail (labelled blue) are inter-connected all tie points of the bottom power rail (labelled red) are inter-connected all tie points of the bottom ground rail (labelled blue) are inter-connected each row (1-63) from column \u201ca\u201d to \u201ce\u201d are inter-connected each row (1-63) from column \u201cf\u201d to \u201cj\u201d are inter-connected Figures 2.4 and 2.5 are photos of a full-size breadboard and a half-size breadboard. Note how the tie points are connected by the metal strips. Only one component connection should connect to each tie-point. Figure 2.6 shows an electrical connection sketch of a half-size breadboard. Figure 2.4 Full-Size 830 Tie Points Breadboard Figure 2.5 Half-Size 400 Tie Points Breadboard and Showing of Internal Conductive Strips Figure 2.6 Half-Size 400 Tie Points Breadboard Electrical Sketch","title":"Breadboard"},{"location":"ses250/lab2/#circuit-symbols","text":"When expressing an electronic circuit in a diagram, circuit symbols are used. Below are some of the circuit symbols that you'll see in the lab. Figure 2.7 Circuit Symbols","title":"Circuit Symbols"},{"location":"ses250/lab2/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires 1k\u03a9 Resistor (brown-black-red)","title":"Materials"},{"location":"ses250/lab2/#preparation","text":"Answer all the lab preparation questions at the end of this document in your lab notebook BEFORE your lab session. Students who did not complete the lab preparation will be asked not to join the lab and receive a grade of ZERO (0) for the lab. Lab preparation must be done individually in the lab notebook. Lab Preparation Question: READ OVER ALL THE LAB BACKGROUND AND LAB STEPS. Copy the following observation table in your notebook for this lab: Table 1: Output: +1V Output: +2V Output: +5V Output: +10V Range: 100mV Range: 1V Range: 10V Range: 100V Range: 1000V Copy Figure 2.13 (with the power supply and resistor symbol) into your notebook then add a voltmeter (symobl) and its connection into the diagram according to the circuit in Figure 2.14. Research: Besides voltage, resistance, and current, list two other electronics-related properties a modem DMM can measure. In your words, explain the difference between the two ON/OFF settings (Power ON/OFF and Output ON/OFF) of the DC power supply we use in this lab. Using Ohm's Law: V = IR , calculate the current through a 1k\u03a9 resistor if 5V of potential difference is applied across the resistor.","title":"Preparation"},{"location":"ses250/lab2/#procedures","text":"","title":"Procedures"},{"location":"ses250/lab2/#part-1-safety","text":"Ensure that you are wearing your safety glasses, not wearing open-toe shoes, and any long hair must be tied up. At the top of your workbench, you\u2019ll see a red \u201cEmergency Stop\u201d button (shown in Figure 2.8). At any time when the button is in the pressed position, your workbench will be disconnected from the power source. Press this button if there are any issues with your equipment or circuit (such as unusual heat, unusual smell, smoke, spark, or fire). To release the button, twist it as per the symbol on the button and the button will no longer be pressed. Figure 2.8 Emergency Stop Button Ensure the Emergency Stop button is in the released position.","title":"Part 1: Safety"},{"location":"ses250/lab2/#part-2-digital-multimeter-dmm-and-dc-voltage-measurement","text":"Assemble the 1k\u03a9 resistor (brown-black-red) from the lab materials onto the breadboard as shown in Figure 2.9. Ensure the two leads of the resistor are on different rows on the breadboard so they are not electrically connected (shorted). The exact tie-point to use within the column doesn't matter are they are electrically connected. Figure 2.9 Identify the digital multimeter (DMM) at your workbench. If there are two DMMs, use the one on the left-hand side. Disconnect any cables that are plugged into it so the DMM is as shown in Figure 2.10 below. Figure 2.10 Set the DMM to DC voltage measurement mode as follows: If the DMM is not already powered on, push the power button (1). Once the DMM is ON, push the DC voltage (DCV) measurement mode button (4). If the \u201cRange\u201d indicator (3) is not showing \u201cAuto\u201d, press the menu button under \u201cRange\u201d (2) and change it to \u201cAuto\u201d. Identify the two cables that are next to the DMM with a banana connector on one end and an alligator clip on the other end. Connect the banana connector from the red cable to the red terminal labelled with \u201cHI\u201d under \u201cInput V\u03a9\u25ba|\u201d (5). Connect the banana connector from the black cable to the black terminal labelled with \u201cLO\u201d under \u201cInput V\u03a9\u25ba|\u201d (6) Figure 2.11 Verify the cables are connected as shown in Figure 2.5 above. At this point, your DMM is set up to measure direct current (DC) voltage. We\u2019ll be discussing direct current voltage during class. Remember this configuration for future labs and careers as measuring DC voltage is a very important skill for working with electronics. Identify the DC power supply at your workbench. If there are two DC power supplies, use the one that's most similar to the one shown. Disconnect any cables that are plugged in so it is as shown in Figure 2.11 below. Figure 2.12 Turn on the DC power supply (1) and then press the \u201cDisplay Limit\u201d button (2). Select the appropriate output voltage range (10) and use the lowest possible setting for a 5V output. In Figure 2.6 above, the lowest setting is \"15V, 7A\", however, the lowest output range varies between different models of power supply. Adjust the voltage output to +5.000V (9) using the digit selector (6) and the adjustment knob (7). Depending on the model of the power supply, the number of significant figures of the voltage output might be different. Identify the black cable with two leads that are next to the DC power supply with a banana connector on one end and an alligator clip on the other end. Connect the red banana connector from the cable to the red \u201cOutput\u201d terminal labelled with \u201c+\u201d (9) NOTE: In some models of power supply, there might be multiple output terminals. connect to the appropriate output terminal depending on the output range you selected earlier. Connect the black banana connector from the cable to the black \u201cOutput\u201d terminal labelled with \u201c-\u201c (10) You\u2019ve now set up the power supply for DC output. Attach a jumper cable to each of the alligator clips as shown in Figure 2.12. It can be jumper wire of any type and colour. Figure 2.12 SHORT CIRCUIT WARNING: Ensure the exposed portion of the red alligator clip or wire is NOT touching the exposed portion of the black alligator clip or wire. Connect the jumper wire from the red cable of the power supply to the same row as the first resistor lead. Then connect the jumper wire from the black cable of the power supply to the same row as the second resistor lead to assemble the circuit below. Figure 2.13 Connect the jumper wire from the red cable of the DMM to the same row as the first resistor lead. Then connect the jumper wire from the black cable of the DMM to the same row as the second resistor lead. Figure 2.14 Figure 2.15 Press the \"Display Limit\" button (2) on the power supply again and verify the voltage is adjusted to +5.000V and the banana cables are connected. Also, verify that the exposed portion of the red alligator clip is NOT touching the exposed portion of the black alligator clip. Turn on the power supply output by pressing the Output On/Off button (8). NOTE: There is a difference between the power supply being ON/OF and the power supply OUTPUT being ON/OFF. The power supply can be ON with its power output OFF. Notice that the DMM should now read about +5V, similar to as shown in Figure 2.15. Make a note of the range value beside the \u201cAuto\u201d on the DMM display. Figure 2.16 With the power supply output ON, adjust the output voltage to +13V. Note: If the output range does not allow you to go to 13V, switch the output range (10) and terminals as necessary. Lab Question 1: What happened to the Range setting on the DMM? If you don't notice the change, decrease the output voltage back to 5V and try again. Afterward, decrease the voltage of the DC power supply slowly to 5V. Lab Question 2: At what power supply voltage did the DMM change back to \u201cAuto 10V\u201d? How are the number of digits and decimal places the same or different when the voltage range changes? What does that mean for the accuracy of the readings? Using the DMM reading only, adjust the output voltage of the DC power supply so the reading on the DMM will display +1.000V. Note: Switch the output range and terminal as necessary. Lab Question 3: What is the output voltage of the DC power supply? Do they agree exactly with each other? If not, which one is higher and what is the percentage difference? /( % diff = diff / expected value /) Adjust the DC power supply output voltage to +1.000V then change the voltage Range on the DMM from \"Auto\" to \"100mV\" using the Range selection button. The DMM should display \"OVERLOAD\" because the 1V output from the power supply is higher than the maximum 100mV range that can be measured. Manually change the DMM \"Range\" setting and power supply voltage output according to the table below. Then record the voltage reading on the DMM in the and do this for DC output voltage of +1V, +2V, +5V, and +10V. NOTE: The reading might fluctuate but record at least 4 significant digits to the best of your ability in estimating AND record all LEADING ZEROS . Table 2: Output: +1V Output: +2V Output: +5V Output: +10V Range: 100mV OVERLOAD Range: 1V Range: 10V Range: 100V Range: 1000V Lab Question 4: If we want the most precise reading, what is the best setting for each DC output voltage in the table? Circle the most precise reading for each voltage output in the table above. Change the DMM \"Range\" setting back to Auto then set the power supply output back to 5V. Take a look at the current output value (Figure 2.11 (8)) from the power supply. Lab Question 5: Does this value agree with the Ohm's law calculation you made earlier in the pre-lab? DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BEEN MARKED BY THE INSTRUCTOR. Turn off the DC power supply and disconnect the alligator clips. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Part 2: Digital Multimeter (DMM) and DC Voltage Measurement"},{"location":"ses250/lab3/","text":"Lab 3: Series and Parallel Resistive Circuit Seneca Polytechnic SES250 Electromagnetics Purposes To become familiar with measurement techniques for direct current (DC) To study the relationship between voltage, resistance, and current To verify Ohm's Law Objectives Assemble electronic components onto a breadboard Measure voltage and current from a breadboard using a digital multimeter (DMM) Important Rules for this Lab Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit. Description If you don't remember how to operate the DMM and read the resistor color band, refer to the description section of Lab 2 . Voltage Measurement In Lab 2, we used the DMM as a voltmeter to measure voltage (or the potential difference) across two nodes in a circuit. When measuring voltage, the DMM is connected in parallel with the circuit, as shown in Figure 2.14a from Lab 2 . An ideal voltmeter has infinite resistance, so energy will not be dissipated by the test equipment. In practice, the internal resistance of a voltmeter is in the M\u03a9 range. Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Voltage Current Measurement Most modern DMMs are capable of being used as an ammeter for measuring current through a circuit. Differing from voltage measurement, current measurement is made by connecting the DMM in series with the circuit, as shown in Figure 3.1. An ideal ammeter has zero resistance, so energy will not be dissipated by the test equipment. In practice, the internal resistance of a voltmeter is in the \u03a9 range. Figure 3.1 Current Measuring Circuit Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Current Resistance Measurement Most modern DMMs are also capable of measuring the resistance through a circuit. This feature, however, is most often used to measure the resistance of a single resistor. To measure resistance, put the DMM in resistance measuring mode, then connect the DMM in parallel with the circuit. Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Resistance TinkerCAD Breadboard Simulator There are many breadboard simulators available online. In particular, TinkerCAD Circuit is a nice tool that you can use to practice assembling a circuit with a virtual breadboard. See the diagram below as an example. Use this tool to help you prepare for this and future labs. Figure 3.2 TinkerCAD Circuit Simulation Tool Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires 1k\u03a9 Resistor (brown-black-red) 10k\u03a9 Resistor (brown-black-orange) Preparation Lab Preparation Question: Read and summarize the lab as necessary. Copy two (2x) of the following Table 1 into your notebook for this lab: Table 1: Resistor # First Band Second Band Multiplier Nominal \u03a9 Measured \u03a9 Colour Total Value x 10 ^ Sketch the breadboard layout below in your notebook and then draw how the components (voltage source, resistor, voltmeter, and ammeter) will be connected on the breadboard according to the circuit in Figures 3.5, 3.6, and 3.7 (Three breadboard diagram in total). Clearly show which tie points the wire, resistor, DMM, and power supply should be attached to. Use TinkerCAD Circuit to help with your understanding of breadboard and component wiring. You may also simulate all the steps as preparation for the lab. Refer to Lab 2 Figure 2.13 for a breadboard diagram example. Copy the table in Lab Questions 3, 4, and 5 into your notebook. Calculate the theoretical reading of the voltmeter and ammeter for the circuit in Figures 3.6 and 3.7 at supply voltages of 1V, 2V, 5V, and 10V. Procedures Part 1: Resistance Measurement Take out a 1k\u03a9 resistor and a 10k\u03a9 resistor from your lab kit. Lab Question 1: Write down the color code of each resistor then determine their resistance value using the resistor color chart in Lab 2 . Use the table below to help you determine the resistance value of each resistor. Leave the \"Measured \u03a9\" blank. Example: 1st Band 2nd Band Multiplier Nominal \u03a9 Measured \u03a9 % Error Colour Brown Black Red Total - - Value 1 0 x 10 ^ 2 1 k\u03a9 1.013 k\u03a9 1.3% Turn on one of the DMMs at your workbench and set it to the \u201c\u03a9 2W\u201d (1) resistance measurement mode. Ensure the banana plugs are connected to the resistance input terminals as shown in Figure 3.3 (2)(3). Figure 3.3 DMM Resistance Mode Connect the red alligator clip of the DMM to one lead of a resistor and the black alligator clip to the other lead of the resistor. Lab Question 2: Write down the measured resistance (at least 3 significant figures) in the \"Measured \u03a9\" column of the table you created in the pre-lab. Does this value agree with the nominal resistor value according to the color band? What is the % error? Is the error within the tolerance of the resistor (indicated by the tolerance band)? Repeat step 3 for the second resistor, then disconnect the DMM from the resistor. Part 2: Voltage and Current Measurement Ensure the DC power supply is OFF. Locate its red and black cables, then attach jumper wires to the alligator clips as shown in Figure 2.12 from Lab 2 . Set up one of the DMMs to voltage mode (refer to Lab 2 if you don't remember the procedure) and ensure the banana cables are connected properly to the DMM for voltage measurement. Connect jumper wires to each of the alligator clips. Set up the other DMM at your workbench to the current mode (DCI) by holding the \"SHIFT\" button (1) and the \"DCV\" button (2). Afterward, ensure the banana cable is connected properly to the DMM for voltage measurement by connecting the black banana cable to the \"LO\" input (3) and the red banana cable to the \"3A\" input (4) as shown in Figure 3.4. Then connect jumper wires to each of the alligator clips. Figure 3.4 Next, insert one of the resistors onto a breadboard the same way as shown in Figure 2.9 from Lab 2 , then connect the jumper wires from the DMMs and the power supply to form the following circuit. Notice the voltmeter (DMM in DC voltage mode (DCV)) is connected in parallel with the resistor and the ammeter (DMM in DC current mode (DCI)) is connected in series with the circuit. A small example of some of the connections is shown. Figure 3.5 Double-check that the circuit is assembled properly and that there is no short circuit. Tips: Follow the flow of the current in your physical circuit from the positive (+) terminal of the power supply to the resistor, then to the ammeter, then to the negative terminal of the power supply to verify proper connections. Turn on the DC power supply and set the output to 5V, then turn on the output. Verify the voltage reading on the DMM agrees with the output of the DC power supply, then turn it off . If you are not seeing 5VDC at the DMM, verify your wiring and that you are using the correct output channel of the power supply. Lab Question 3: Adjust the power supply output to 1V, 2V, 5V, and 10V to complete the table below. Do the measurements agree with Ohm's Law? Power Supply Voltage [V] 1V 2V 5V 10V Current Using 1k\u03a9 Resistor [A] Current Using 10k\u03a9 Resistor [A] Turn off the DC power supply output. Part 3: Series and Parallel Resistive Circuit Next, we\u2019ll assemble the following series resistive circuit using the 1k\u03a9 and 10k\u03a9 resistors on a breadboard. The power supply will act as the DC voltage source. Figure 3.6 Set the DC power supply to 1V output, then turn on the output. Verify the voltage reading on the DMM agrees with the output of the DC power supply, then turn it off . If you are not seeing 0.09VDC at the DMM, verify your wiring and that you are using the correct output channel of the power supply. Lab Question 4: Adjust the power supply output to 1V, 2V, 5V, and 10V to complete the table below. Do the measurements agree with the estimate you made in the pre-lab? Power Supply Voltage [V] 1V 2V 5V 10V Voltmeter Reading [V] Ammeter Reading [A] Lastly, we\u2019ll assemble the following parallel resistive circuit using the 1k\u03a9 and 10k\u03a9 resistors on a breadboard. The power supply will act as the DC voltage source. Figure 3.7 Set the DC power supply to 1V output, then turn on the output. Verify the voltage reading on the DMM agrees with the output of the DC power supply, then turn it off . If you are not seeing 1VDC at the DMM, verify your wiring and that you are using the correct output channel of the power supply. Lab Question 5: Adjust the power supply output to 1V, 2V, 5V, and 10V to complete the table below. Do the measurements agree with the estimate you made in the pre-lab? Power Supply Voltage [V] 1V 2V 5V 10V Voltmeter Reading [V] Ammeter Reading [A] DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BEEN MARKED BY THE INSTRUCTOR. Turn off the DC power supply output. Once you've completed all the above steps, ask the lab professor or instructor to demonstrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 3: Series and Parallel Resistive Circuit"},{"location":"ses250/lab3/#lab-3-series-and-parallel-resistive-circuit","text":"Seneca Polytechnic SES250 Electromagnetics","title":"Lab 3: Series and Parallel Resistive Circuit"},{"location":"ses250/lab3/#purposes","text":"To become familiar with measurement techniques for direct current (DC) To study the relationship between voltage, resistance, and current To verify Ohm's Law","title":"Purposes"},{"location":"ses250/lab3/#objectives","text":"Assemble electronic components onto a breadboard Measure voltage and current from a breadboard using a digital multimeter (DMM)","title":"Objectives"},{"location":"ses250/lab3/#important-rules-for-this-lab","text":"Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit.","title":"Important Rules for this Lab"},{"location":"ses250/lab3/#description","text":"If you don't remember how to operate the DMM and read the resistor color band, refer to the description section of Lab 2 .","title":"Description"},{"location":"ses250/lab3/#voltage-measurement","text":"In Lab 2, we used the DMM as a voltmeter to measure voltage (or the potential difference) across two nodes in a circuit. When measuring voltage, the DMM is connected in parallel with the circuit, as shown in Figure 2.14a from Lab 2 . An ideal voltmeter has infinite resistance, so energy will not be dissipated by the test equipment. In practice, the internal resistance of a voltmeter is in the M\u03a9 range. Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Voltage","title":"Voltage Measurement"},{"location":"ses250/lab3/#current-measurement","text":"Most modern DMMs are capable of being used as an ammeter for measuring current through a circuit. Differing from voltage measurement, current measurement is made by connecting the DMM in series with the circuit, as shown in Figure 3.1. An ideal ammeter has zero resistance, so energy will not be dissipated by the test equipment. In practice, the internal resistance of a voltmeter is in the \u03a9 range. Figure 3.1 Current Measuring Circuit Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Current","title":"Current Measurement"},{"location":"ses250/lab3/#resistance-measurement","text":"Most modern DMMs are also capable of measuring the resistance through a circuit. This feature, however, is most often used to measure the resistance of a single resistor. To measure resistance, put the DMM in resistance measuring mode, then connect the DMM in parallel with the circuit. Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Resistance","title":"Resistance Measurement"},{"location":"ses250/lab3/#tinkercad-breadboard-simulator","text":"There are many breadboard simulators available online. In particular, TinkerCAD Circuit is a nice tool that you can use to practice assembling a circuit with a virtual breadboard. See the diagram below as an example. Use this tool to help you prepare for this and future labs. Figure 3.2 TinkerCAD Circuit Simulation Tool","title":"TinkerCAD Breadboard Simulator"},{"location":"ses250/lab3/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires 1k\u03a9 Resistor (brown-black-red) 10k\u03a9 Resistor (brown-black-orange)","title":"Materials"},{"location":"ses250/lab3/#preparation","text":"Lab Preparation Question: Read and summarize the lab as necessary. Copy two (2x) of the following Table 1 into your notebook for this lab: Table 1: Resistor # First Band Second Band Multiplier Nominal \u03a9 Measured \u03a9 Colour Total Value x 10 ^ Sketch the breadboard layout below in your notebook and then draw how the components (voltage source, resistor, voltmeter, and ammeter) will be connected on the breadboard according to the circuit in Figures 3.5, 3.6, and 3.7 (Three breadboard diagram in total). Clearly show which tie points the wire, resistor, DMM, and power supply should be attached to. Use TinkerCAD Circuit to help with your understanding of breadboard and component wiring. You may also simulate all the steps as preparation for the lab. Refer to Lab 2 Figure 2.13 for a breadboard diagram example. Copy the table in Lab Questions 3, 4, and 5 into your notebook. Calculate the theoretical reading of the voltmeter and ammeter for the circuit in Figures 3.6 and 3.7 at supply voltages of 1V, 2V, 5V, and 10V.","title":"Preparation"},{"location":"ses250/lab3/#procedures","text":"","title":"Procedures"},{"location":"ses250/lab3/#part-1-resistance-measurement","text":"Take out a 1k\u03a9 resistor and a 10k\u03a9 resistor from your lab kit. Lab Question 1: Write down the color code of each resistor then determine their resistance value using the resistor color chart in Lab 2 . Use the table below to help you determine the resistance value of each resistor. Leave the \"Measured \u03a9\" blank. Example: 1st Band 2nd Band Multiplier Nominal \u03a9 Measured \u03a9 % Error Colour Brown Black Red Total - - Value 1 0 x 10 ^ 2 1 k\u03a9 1.013 k\u03a9 1.3% Turn on one of the DMMs at your workbench and set it to the \u201c\u03a9 2W\u201d (1) resistance measurement mode. Ensure the banana plugs are connected to the resistance input terminals as shown in Figure 3.3 (2)(3). Figure 3.3 DMM Resistance Mode Connect the red alligator clip of the DMM to one lead of a resistor and the black alligator clip to the other lead of the resistor. Lab Question 2: Write down the measured resistance (at least 3 significant figures) in the \"Measured \u03a9\" column of the table you created in the pre-lab. Does this value agree with the nominal resistor value according to the color band? What is the % error? Is the error within the tolerance of the resistor (indicated by the tolerance band)? Repeat step 3 for the second resistor, then disconnect the DMM from the resistor.","title":"Part 1: Resistance Measurement"},{"location":"ses250/lab3/#part-2-voltage-and-current-measurement","text":"Ensure the DC power supply is OFF. Locate its red and black cables, then attach jumper wires to the alligator clips as shown in Figure 2.12 from Lab 2 . Set up one of the DMMs to voltage mode (refer to Lab 2 if you don't remember the procedure) and ensure the banana cables are connected properly to the DMM for voltage measurement. Connect jumper wires to each of the alligator clips. Set up the other DMM at your workbench to the current mode (DCI) by holding the \"SHIFT\" button (1) and the \"DCV\" button (2). Afterward, ensure the banana cable is connected properly to the DMM for voltage measurement by connecting the black banana cable to the \"LO\" input (3) and the red banana cable to the \"3A\" input (4) as shown in Figure 3.4. Then connect jumper wires to each of the alligator clips. Figure 3.4 Next, insert one of the resistors onto a breadboard the same way as shown in Figure 2.9 from Lab 2 , then connect the jumper wires from the DMMs and the power supply to form the following circuit. Notice the voltmeter (DMM in DC voltage mode (DCV)) is connected in parallel with the resistor and the ammeter (DMM in DC current mode (DCI)) is connected in series with the circuit. A small example of some of the connections is shown. Figure 3.5 Double-check that the circuit is assembled properly and that there is no short circuit. Tips: Follow the flow of the current in your physical circuit from the positive (+) terminal of the power supply to the resistor, then to the ammeter, then to the negative terminal of the power supply to verify proper connections. Turn on the DC power supply and set the output to 5V, then turn on the output. Verify the voltage reading on the DMM agrees with the output of the DC power supply, then turn it off . If you are not seeing 5VDC at the DMM, verify your wiring and that you are using the correct output channel of the power supply. Lab Question 3: Adjust the power supply output to 1V, 2V, 5V, and 10V to complete the table below. Do the measurements agree with Ohm's Law? Power Supply Voltage [V] 1V 2V 5V 10V Current Using 1k\u03a9 Resistor [A] Current Using 10k\u03a9 Resistor [A] Turn off the DC power supply output.","title":"Part 2: Voltage and Current Measurement"},{"location":"ses250/lab3/#part-3-series-and-parallel-resistive-circuit","text":"Next, we\u2019ll assemble the following series resistive circuit using the 1k\u03a9 and 10k\u03a9 resistors on a breadboard. The power supply will act as the DC voltage source. Figure 3.6 Set the DC power supply to 1V output, then turn on the output. Verify the voltage reading on the DMM agrees with the output of the DC power supply, then turn it off . If you are not seeing 0.09VDC at the DMM, verify your wiring and that you are using the correct output channel of the power supply. Lab Question 4: Adjust the power supply output to 1V, 2V, 5V, and 10V to complete the table below. Do the measurements agree with the estimate you made in the pre-lab? Power Supply Voltage [V] 1V 2V 5V 10V Voltmeter Reading [V] Ammeter Reading [A] Lastly, we\u2019ll assemble the following parallel resistive circuit using the 1k\u03a9 and 10k\u03a9 resistors on a breadboard. The power supply will act as the DC voltage source. Figure 3.7 Set the DC power supply to 1V output, then turn on the output. Verify the voltage reading on the DMM agrees with the output of the DC power supply, then turn it off . If you are not seeing 1VDC at the DMM, verify your wiring and that you are using the correct output channel of the power supply. Lab Question 5: Adjust the power supply output to 1V, 2V, 5V, and 10V to complete the table below. Do the measurements agree with the estimate you made in the pre-lab? Power Supply Voltage [V] 1V 2V 5V 10V Voltmeter Reading [V] Ammeter Reading [A] DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BEEN MARKED BY THE INSTRUCTOR. Turn off the DC power supply output. Once you've completed all the above steps, ask the lab professor or instructor to demonstrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Part 3: Series and Parallel Resistive Circuit"},{"location":"ses250/lab4/","text":"Lab 4 : Kirchhoff's Laws Seneca Polytechnic SES250 Electromagnatics Purposes To become familiar with measurement techniques of direct current (DC) To study the relationship between voltage, resistance, and current To understand and verify Kirchhoff's Laws To understand and verify Th\u00e9venin Theorem Objectives Assemble electronic components onto a breadboard Measure voltage and current from a breadboard using a digital multimeter (DMM) Important Rules for this Lab Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit. Description If you don't remember how to operate the DMM and read the resistor colour band, refer to the description section of Lab 2 . Kirchhoff's Current Law (KCL) When analyzing electronic circuits, a method often used is Kirchhoff's current law (KCL). KCL, Kirchhoff's first law, or Kirchhoff's junction rule, states that, for any node (junction) in an electrical circuit, the sum of currents flowing into that node is equal to the sum of currents flowing out of that node; or equivalently: the algebraic sum of currents in a network of conductors meeting at a point is zero: \\displaystyle\\sum_{i=1}^{n} I_i = \\sum_{i=1}^{n} {{V_i} \\over {R_i}} = 0 Figure 4.1 The current entering any junction is equal to the current leaving that junction. i2 + i3 = i1 + i4 Kirchhoff's Voltage Law (KVL) KVL, Kirchhoff's second law, or Kirchhoff's loop rule, states that the directed sum of the potential differences (voltages) around any closed loop is zero. Similarly to Kirchhoff's current law, the voltage law can be stated as: \\displaystyle\\sum_{i=1}^{n} V_i = \\sum_{i=1}^{n} {{I_i} {R_i}} = 0 Figure 4.2 The voltages around any closed loop are zero Source: Wikipedia: Kirchhoff's circuit laws TinkerCAD Breadboard Simulator There are many breadboard simulators available online. In particular, TinkerCAD Circuit is a nice tool that you can use to practice assembling a circuit with a virtual breadboard. See the diagram below as an example. Use this tool to help you prepare for this and future labs. Figure 4.3 TinkerCAD Circuit Simulation Tool Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (2x) 100\u03a9 Resistor (brown-black-brown) (2x) 330\u03a9 Resistor (orange-orange-brown) (2x) 1k\u03a9 Resistor (brown-black-red) (1x) 4.7k\u03a9 Resistor (yellow-purple-red) (2x) 10k\u03a9 resistor (brown-black-orange) Preparation Lab Preparation Question: Read and summarize the lab as necessary. Copy observation table 1 into your notebook. Sketch the breadboard diagram below onto your notebook then draw how the components (voltage source, resistor, voltmeter, and ammeter) will be connected on the breadboard according to the circuit in Figure 4.4 for measuring: I_1 I_2 I_L V_a V_b Clearly show which tie point the wire, resistor, DMM, and power supply be attached to. Use TinkerCAD Circuit to help with your understanding of breadboard and component wiring. You may also simulate all the steps as preparation for the lab. Refer the Lab 2 Figure 2.13 for a breadboard diagram example. Use KCL or KVL to calculate the estimated (therotical) values for I_1 , I_2 , I_L , V_a and V_b in Figure 4.4 then fill in the appropriate cell in the observation table 1. Use 1k\u03a9 for R_L and show all calculation. Procedures Current and Voltage Measurement For this lab, below is the circuit that you'll be working with. You'll need to add voltmeter and ammeter into the circuit to measure the branch current and node voltage. Remember, current measurement needs to be in series with the branch. Figure 4.4 Assemble the above circuit shown onto your breadboard as how you prepared during your pre-lab for measuring current I_1 . Use 1k\u03a9 for R_L . Turn on the power supplies and set the DMM for the appropriate measurement then write down your measurement into the observation table. Lab Question 1: Write down the measured current into the appropriate cell in the table below. Tabel 1: Observation Table: I_1 I_2 I_L V_a V_b Estimated Value Measured Value % Error Turn off the output of the power supplies. Modify the circuit on your breadboard for measuring current I_2 and I_L as how you prepared during your pre-lab. You may use both DMM. Turn on the power supplies then write down your measurement into the observation table. Lab Question 2: Write down the measured current into the appropriate cell in the observation table. Repeat the above steps for the measurement of voltage measurement V_a and V_b . You may use both DMM. Lab Question 3: Does all the % error falls within the tolarance of the resistors? DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. You can keep your circuit assembled for Lab 5. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 4 : Kirchhoff's Laws"},{"location":"ses250/lab4/#lab-4-kirchhoffs-laws","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab 4 : Kirchhoff's Laws"},{"location":"ses250/lab4/#purposes","text":"To become familiar with measurement techniques of direct current (DC) To study the relationship between voltage, resistance, and current To understand and verify Kirchhoff's Laws To understand and verify Th\u00e9venin Theorem","title":"Purposes"},{"location":"ses250/lab4/#objectives","text":"Assemble electronic components onto a breadboard Measure voltage and current from a breadboard using a digital multimeter (DMM)","title":"Objectives"},{"location":"ses250/lab4/#important-rules-for-this-lab","text":"Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit.","title":"Important Rules for this Lab"},{"location":"ses250/lab4/#description","text":"If you don't remember how to operate the DMM and read the resistor colour band, refer to the description section of Lab 2 .","title":"Description"},{"location":"ses250/lab4/#kirchhoffs-current-law-kcl","text":"When analyzing electronic circuits, a method often used is Kirchhoff's current law (KCL). KCL, Kirchhoff's first law, or Kirchhoff's junction rule, states that, for any node (junction) in an electrical circuit, the sum of currents flowing into that node is equal to the sum of currents flowing out of that node; or equivalently: the algebraic sum of currents in a network of conductors meeting at a point is zero: \\displaystyle\\sum_{i=1}^{n} I_i = \\sum_{i=1}^{n} {{V_i} \\over {R_i}} = 0 Figure 4.1 The current entering any junction is equal to the current leaving that junction. i2 + i3 = i1 + i4","title":"Kirchhoff's Current Law (KCL)"},{"location":"ses250/lab4/#kirchhoffs-voltage-law-kvl","text":"KVL, Kirchhoff's second law, or Kirchhoff's loop rule, states that the directed sum of the potential differences (voltages) around any closed loop is zero. Similarly to Kirchhoff's current law, the voltage law can be stated as: \\displaystyle\\sum_{i=1}^{n} V_i = \\sum_{i=1}^{n} {{I_i} {R_i}} = 0 Figure 4.2 The voltages around any closed loop are zero Source: Wikipedia: Kirchhoff's circuit laws","title":"Kirchhoff's Voltage Law (KVL)"},{"location":"ses250/lab4/#tinkercad-breadboard-simulator","text":"There are many breadboard simulators available online. In particular, TinkerCAD Circuit is a nice tool that you can use to practice assembling a circuit with a virtual breadboard. See the diagram below as an example. Use this tool to help you prepare for this and future labs. Figure 4.3 TinkerCAD Circuit Simulation Tool","title":"TinkerCAD Breadboard Simulator"},{"location":"ses250/lab4/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (2x) 100\u03a9 Resistor (brown-black-brown) (2x) 330\u03a9 Resistor (orange-orange-brown) (2x) 1k\u03a9 Resistor (brown-black-red) (1x) 4.7k\u03a9 Resistor (yellow-purple-red) (2x) 10k\u03a9 resistor (brown-black-orange)","title":"Materials"},{"location":"ses250/lab4/#preparation","text":"Lab Preparation Question: Read and summarize the lab as necessary. Copy observation table 1 into your notebook. Sketch the breadboard diagram below onto your notebook then draw how the components (voltage source, resistor, voltmeter, and ammeter) will be connected on the breadboard according to the circuit in Figure 4.4 for measuring: I_1 I_2 I_L V_a V_b Clearly show which tie point the wire, resistor, DMM, and power supply be attached to. Use TinkerCAD Circuit to help with your understanding of breadboard and component wiring. You may also simulate all the steps as preparation for the lab. Refer the Lab 2 Figure 2.13 for a breadboard diagram example. Use KCL or KVL to calculate the estimated (therotical) values for I_1 , I_2 , I_L , V_a and V_b in Figure 4.4 then fill in the appropriate cell in the observation table 1. Use 1k\u03a9 for R_L and show all calculation.","title":"Preparation"},{"location":"ses250/lab4/#procedures","text":"","title":"Procedures"},{"location":"ses250/lab4/#current-and-voltage-measurement","text":"For this lab, below is the circuit that you'll be working with. You'll need to add voltmeter and ammeter into the circuit to measure the branch current and node voltage. Remember, current measurement needs to be in series with the branch. Figure 4.4 Assemble the above circuit shown onto your breadboard as how you prepared during your pre-lab for measuring current I_1 . Use 1k\u03a9 for R_L . Turn on the power supplies and set the DMM for the appropriate measurement then write down your measurement into the observation table. Lab Question 1: Write down the measured current into the appropriate cell in the table below. Tabel 1: Observation Table: I_1 I_2 I_L V_a V_b Estimated Value Measured Value % Error Turn off the output of the power supplies. Modify the circuit on your breadboard for measuring current I_2 and I_L as how you prepared during your pre-lab. You may use both DMM. Turn on the power supplies then write down your measurement into the observation table. Lab Question 2: Write down the measured current into the appropriate cell in the observation table. Repeat the above steps for the measurement of voltage measurement V_a and V_b . You may use both DMM. Lab Question 3: Does all the % error falls within the tolarance of the resistors? DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. You can keep your circuit assembled for Lab 5. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Current and Voltage Measurement"},{"location":"ses250/lab5/","text":"Lab 5 : Th\u00e9venin Circuit Seneca Polytechnic SES250 Electromagnatics Purposes To become familiar with measurement techniques of direct current (DC) To study the relationship between voltage, resistance, and current To understand and verify Th\u00e9venin Theorem Objectives Assemble electronic components onto a breadboard Measure voltage and current from a breadboard using a digital multimeter (DMM) Important Rules for this Lab Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit. Description If you don't remember how to operate the DMM and read the resistor colour band, refer to the description section of Lab 2 . Th\u00e9venin Theorem Th\u00e9venin theorem is a method often used to simplify circuit analysis from a complex circuit to a simpler one with only a Th\u00e9venin voltage source in series with a Th\u00e9venin resistor. Any linear electrical network containing only voltage sources, current sources and resistances can be replaced at terminals A\u2013B by an equivalent combination of a voltage source V_{th} in a series connection with a resistance R_{th} . Figure 5.1 Th\u00e9venin equivalent circuit The equivalent voltage V_{th} is the voltage obtained at terminals A\u2013B of the network with terminals A\u2013B open-circuited. The equivalent resistance R_{th} is the resistance that the circuit between terminals A and B would have if all ideal voltage sources in the circuit were replaced by a short circuit and all ideal current sources were replaced by an open circuit. If terminals A and B are connected to one another, the current flowing from A and B will be V_{th} over R_{th} . This means that R_{th} could alternatively be calculated as V_{th} divided by the short-circuit current between A and B when they are connected together. Source: Wikipedia: Th\u00e9venin's theorem Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (2x) 100\u03a9 Resistor (brown-black-brown) (2x) 330\u03a9 Resistor (orange-orange-brown) (2x) 1k\u03a9 Resistor (brown-black-red) (1x) 4.7k\u03a9 Resistor (yellow-purple-red) (2x) 10k\u03a9 resistor (brown-black-orange) Preparation Lab Preparation Question: Read and summarize the lab as necessary. Copy observation table 1 and 2 of this lab into your notebook. Sketch a breadboard diagram of Figure 5.2 and Figure 5.3 onto your notebook for measuring: I_L V_{ab} (or the potential difference between V_a and V_b ) Use KCL or KVL to calculate the estimated values for I_L , V_{ab} in Figure 5.2 then fill in the appropriate cell in the observation table 1. Perform the calculation using 100\u03a9, 330\u03a9, 1k\u03a9, and 10k\u03a9 for R_L . Find the Th\u00e9venin equivalent circuit for Figure 5.2 then choose the closest resistor you have to R_{th} for Part 2 of the lab. Use Th\u00e9venin Theorem to calculate the estimated values for I_L in Figure 5.3 for each of the R_L values in Part 1 then fill in the appropriate cell in the observation table 2. Procedures For this lab, you'll be using the same circuit as the one from Lab 4 but you'll be varying the value of the load resistor to understand the concept of Th\u00e9venin Circuit. Use 1k\u03a9 for R_L . Figure 5.2 Part 1: I_L and V_{ab} for various R_L Assemble the circuit above as how you've prepare in your pre-lab. Replace the R_L resistor with the various value on the table below then measure current I_L and V_{ab} for each value. Turn on the power supplies then write down your measurement into the observation table. Lab Question 1: Write down the measured current into the appropriate cell in the table below. Tabel 1: R_L Observation Table: R_L Estimated I_L Estimated V_{ab} Measured I_L Measured V_{ab} 100\u03a9 330\u03a9 1k\u03a9 10k\u03a9 Turn off the output of the power supplies then repeat the measurement above for all R_L values. DO NOT disassemble the circuit. Part 2: Th\u00e9venin Equivalent Circuit Next, assemble the Th\u00e9venin circuit given below with the resistor value you calculate in the pre-lab. Start with 1k\u03a9 for R_L . Assemble it beside the circuit from Part 1. Figure 5.3 Apply the Th\u00e9venin voltage you calculated from the pre-lab then turn on the power supplies. Write down your measurement in the observation table. Lab Question 2: Write down the measured current into the appropriate cell in the table below. Table 2: Th\u00e9venin Circuit Observation Table: R_L Measured I_L Measured V_{ab} Power Dissipated 100\u03a9 330\u03a9 1k\u03a9 10k\u03a9 Turn off the output of the power supplies then repeat the measurement above for all R_L values. Lab Question 3: Does the value agree closely with the original circuit? Note that the R_{th} you've chosen might not exactly match the theoretical R_{th} . Lab Question 4: Calculate the power dissipation P = IV by the load resistor in each case. Which resistor dissipated the most power? This is the load resistor value that allow for the maximum amount of power to be transferred from the voltage source to the load (Maxium Power Transferred). DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 5 : Th\u00e9venin Circuit"},{"location":"ses250/lab5/#lab-5-thevenin-circuit","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab 5 : Th\u00e9venin Circuit"},{"location":"ses250/lab5/#purposes","text":"To become familiar with measurement techniques of direct current (DC) To study the relationship between voltage, resistance, and current To understand and verify Th\u00e9venin Theorem","title":"Purposes"},{"location":"ses250/lab5/#objectives","text":"Assemble electronic components onto a breadboard Measure voltage and current from a breadboard using a digital multimeter (DMM)","title":"Objectives"},{"location":"ses250/lab5/#important-rules-for-this-lab","text":"Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit.","title":"Important Rules for this Lab"},{"location":"ses250/lab5/#description","text":"If you don't remember how to operate the DMM and read the resistor colour band, refer to the description section of Lab 2 .","title":"Description"},{"location":"ses250/lab5/#thevenin-theorem","text":"Th\u00e9venin theorem is a method often used to simplify circuit analysis from a complex circuit to a simpler one with only a Th\u00e9venin voltage source in series with a Th\u00e9venin resistor. Any linear electrical network containing only voltage sources, current sources and resistances can be replaced at terminals A\u2013B by an equivalent combination of a voltage source V_{th} in a series connection with a resistance R_{th} . Figure 5.1 Th\u00e9venin equivalent circuit The equivalent voltage V_{th} is the voltage obtained at terminals A\u2013B of the network with terminals A\u2013B open-circuited. The equivalent resistance R_{th} is the resistance that the circuit between terminals A and B would have if all ideal voltage sources in the circuit were replaced by a short circuit and all ideal current sources were replaced by an open circuit. If terminals A and B are connected to one another, the current flowing from A and B will be V_{th} over R_{th} . This means that R_{th} could alternatively be calculated as V_{th} divided by the short-circuit current between A and B when they are connected together. Source: Wikipedia: Th\u00e9venin's theorem","title":"Th\u00e9venin Theorem"},{"location":"ses250/lab5/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (2x) 100\u03a9 Resistor (brown-black-brown) (2x) 330\u03a9 Resistor (orange-orange-brown) (2x) 1k\u03a9 Resistor (brown-black-red) (1x) 4.7k\u03a9 Resistor (yellow-purple-red) (2x) 10k\u03a9 resistor (brown-black-orange)","title":"Materials"},{"location":"ses250/lab5/#preparation","text":"Lab Preparation Question: Read and summarize the lab as necessary. Copy observation table 1 and 2 of this lab into your notebook. Sketch a breadboard diagram of Figure 5.2 and Figure 5.3 onto your notebook for measuring: I_L V_{ab} (or the potential difference between V_a and V_b ) Use KCL or KVL to calculate the estimated values for I_L , V_{ab} in Figure 5.2 then fill in the appropriate cell in the observation table 1. Perform the calculation using 100\u03a9, 330\u03a9, 1k\u03a9, and 10k\u03a9 for R_L . Find the Th\u00e9venin equivalent circuit for Figure 5.2 then choose the closest resistor you have to R_{th} for Part 2 of the lab. Use Th\u00e9venin Theorem to calculate the estimated values for I_L in Figure 5.3 for each of the R_L values in Part 1 then fill in the appropriate cell in the observation table 2.","title":"Preparation"},{"location":"ses250/lab5/#procedures","text":"For this lab, you'll be using the same circuit as the one from Lab 4 but you'll be varying the value of the load resistor to understand the concept of Th\u00e9venin Circuit. Use 1k\u03a9 for R_L . Figure 5.2","title":"Procedures"},{"location":"ses250/lab5/#part-1-i_l-and-v_ab-for-various-r_l","text":"Assemble the circuit above as how you've prepare in your pre-lab. Replace the R_L resistor with the various value on the table below then measure current I_L and V_{ab} for each value. Turn on the power supplies then write down your measurement into the observation table. Lab Question 1: Write down the measured current into the appropriate cell in the table below. Tabel 1: R_L Observation Table: R_L Estimated I_L Estimated V_{ab} Measured I_L Measured V_{ab} 100\u03a9 330\u03a9 1k\u03a9 10k\u03a9 Turn off the output of the power supplies then repeat the measurement above for all R_L values. DO NOT disassemble the circuit.","title":"Part 1: I_L and V_{ab} for various R_L"},{"location":"ses250/lab5/#part-2-thevenin-equivalent-circuit","text":"Next, assemble the Th\u00e9venin circuit given below with the resistor value you calculate in the pre-lab. Start with 1k\u03a9 for R_L . Assemble it beside the circuit from Part 1. Figure 5.3 Apply the Th\u00e9venin voltage you calculated from the pre-lab then turn on the power supplies. Write down your measurement in the observation table. Lab Question 2: Write down the measured current into the appropriate cell in the table below. Table 2: Th\u00e9venin Circuit Observation Table: R_L Measured I_L Measured V_{ab} Power Dissipated 100\u03a9 330\u03a9 1k\u03a9 10k\u03a9 Turn off the output of the power supplies then repeat the measurement above for all R_L values. Lab Question 3: Does the value agree closely with the original circuit? Note that the R_{th} you've chosen might not exactly match the theoretical R_{th} . Lab Question 4: Calculate the power dissipation P = IV by the load resistor in each case. Which resistor dissipated the most power? This is the load resistor value that allow for the maximum amount of power to be transferred from the voltage source to the load (Maxium Power Transferred). DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Part 2: Th\u00e9venin Equivalent Circuit"},{"location":"ses250/lab6/","text":"Lab 6 : Digital Storage Oscilloscope (DSO) Seneca Polytechnic SES250 Electromagnatics Purpose To learn how to operate the function generator and digital storage oscilloscope (DSO) Objectives Generate waveform using a function generator Measure waveform using a digital storage oscilloscope (DSO) Important Rules for this Lab Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply and/or the function generator must be switched off before making any changes to the circuit. Description Function Generator A function generator is a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave, and sawtooth shapes. These waveforms can be either repetitive or single shots. Figure 6.1 Keysight 33500B Function Generator In the electronics lab, you will be using a Keysight 33500B (or similar) Function Generator. Its manual can be found here: Function Generator Manual Source: Wikipedia: Function Generator Reference Video: How to Use A KEYSIGHT E33220A Function Generator to Generate A Sine Wave Digital Storage Oscilloscope (DSO) An oscilloscope, or DSO (for the more modern digital storage oscilloscope), is a type of electronic test instrument that graphically displays varying signal voltages, usually as a calibrated two-dimensional plot of one or more signals as a function of time. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, the calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument. Modern digital instruments may calculate and display these properties directly. Figure 6.2 Keysight 33500B Function Generator In the electronics lab, you will be using a Keysight DSO-X 2002A (or similar) Digital Storage Oscilloscope. Its manual can be found here: DSO Manual Source: Wikipedia: Oscilloscope Materials Preparation Lab Preparation Question: List 5 waveform that can be generated by the function generator used in this lab. Read through the lab manual and list the button(s) that you need to press to turn the output of the function generator on and off. In your own word, explain the difference between the 50\u03a9 and High-Z output mode of the function generator used in this lab. Procedures Identify the Digital Oscilloscope at your workbench. Disconnect any cable plugged into it so it is as shown below. Figure 6.3 Turn on the oscilloscope with the power button (8.3-1) if it is not already on. Identify the two cables with a BNC connector beside the oscilloscope. Connect the BNC cables to the CH1 (8.3-4) and CH2 connectors of the oscilloscope as shown. Figure 6.4 Press the CH1 On/Off button (6.3-6) so CH1 is on (button lights up green). Press the CH2 On/Off button so CH2 is off (no light showing at the button). The bright lines on the DSO display the waveform of the signal as a function of time. When there is no signal, the waveform is a flat line. If you don't see a flat line, that means your DSO is displaying amplified electronic noise from the environment. Don't worry if you don't see a flat line for this step of the lab. Lab Question 1: How many signal line(s) (6.3-13, bright solid horizontal line) do you see on the display? What is the colour of the line(s)? Press the CH2 On/Off button to turn CH2 on (button lights up green) then press the Auto Scale button (6.3-9) again. Lab Question 2: How many signal line(s) do you see on the display? What is the colour of the line(s)? You can adjust the vertical position of those signal lines for measurement or display purposes. Turn the CH1 vertical position knob (6.3-5) until the CH1 signal line is reasonably lined up vertically centred on the display. Try changing the vertical position of the CH2 signal line as well. Afterward, line up both signal lines vertically centred on the display. One line will be on top of the other line. Modern DSOs are complex test instruments with a lot of functionality. It is a very useful tool once you understand how to use it. The more you use and play with the tool, the more familiar you'll get. Turn off CH2. Identify the Function Generator at your workbench. Disconnect any cable plug into it so it is as shown below. Figure 6.5 Identify the cable with a BNC connector beside the function generator and connect it to the Output of the function generator (6.5-3). Afterward, push the power button (6.5-1) to turn on the function generator. After the function generator is turned on, we'll set up a 1kHz Sine wave, press the Waveforms button (6.5-7) and select Sine waveform mode from button menus (6.5-2). Then press the Parameters button (6.5-8) and use the keypad, digit selector buttons (6.5-5), and the adjustment knob (8.5-6) to set the following: Frequency: 1.000 kHz ( Note: pay attention to the number of 0s in kHz You can adjust the Units as necessary.) Amplitude: 100.0 mVpp (default setting) Offset: 0.000 V (default setting) Phase: 0\u00b0 (default setting) Identify the cable connected to the function generator and the alligator clips at the end of the cable connected to CH1 of the oscilloscope. Connect the two red alligator clips together and connect the two black alligator clips together. WARNING: Ensure the exposed portion of the red alligator clip is NOT touching the exposed portion of the black alligator clip. Figure 6.6 Once the cables are connected and the waveform is set, push the channel button on the function generator (6.7-4) then turn the output to \u201cOn\u201d (6.7-9). Figure 6.7 You should now see some signal on the DSO. If not, push the Auto Scale button on the oscilloscope (8.3-9). You should see a waveform that is similar to that shown in the figure below. Figure 6.8 Turn the time division knob (6.3-12) and the horizontal position knob (6.3-11) a few ticks clockwise then counter-clockwise. Lab Question 3: What effect do the time division knob and the horizontal position knob have on the waveform? The grey-white vertical lines (6.8-2) on the oscilloscope chart are called time division lines and the top right of the display shows the time divisor (6.8-4). In the figure above, the time divisor is set to 200.0\u03bcs/ which means each time division line represents 200.0\u03bcs in the time domain. The are a total of 10 time divisions in the display. Lab Question 4: Find two peaks in the signal waveform then count the number of time divisions in each period of the sine wave. Afterward, calculate the frequency of the sine wave using: f = 1 / T where f is the frequency in [Hz] and T is the period in [s]. Does it agree with the output of the function generator? You can adjust the horizontal position of the sine wave with the horizontal position knob to help with counting if necessary. Change the output of the function generator to a different frequency such as 500Hz and another waveform such as square and triangle then see how it is displayed on the oscilloscope. Afterward, put the function generator back to a sine wave at 1kHz. Press the Measurement (Meas) button (6.3-8) on the oscilloscope. In the measurement menu that shows up, use the menu buttons (6.3-2) and menu selector knob (6.3-3) to clear all measurements with the Clear Meas option. Then, add Frequency (Freq) and peak-to-peak voltage (Pk-Pk) for measurement. Ensure the Source channel is set to 1 at the lower left corner of the menu. The two measurements should now show up in the measurement list on the right-hand side. If a mistake is made, press Clear Meas to remove a measurement. Lab Question 5: Does the frequency measurement agree with your calculation above? Turn the time division knob slowly so the waveform expands and compresses horizontally. Turn it from 10 periods to only a portion of the waveform shown. Lab Question 6: At what time divisor does the measurement starts to become invalid? How many periods of the waveform are shown when it becomes invalid? What comment can you make on how the oscilloscope calculates the freq measurement (in terms of the waveform required to be displayed on the screen)? The grey-white horizontal line (6.8-1) on the oscilloscope display is called a voltage division line and at the top left of the display shows the voltage divisor (6.8-3). In the figure above, 50.0mV/ means each line represents 50.0mV in the voltage range. The are a total of 8 voltage divisions in the display. Lab Question 7: Find the peak and the trough of the signal waveform. Count the number of voltage divisions from the peak to the trough of the sine wave then calculate the peak-to-peak voltage of the sine wave. Does it agree with the peak-to-peak voltage (Pk-Pk) value in the measurement list? Lab Question 8: Is this peak-to-peak voltage (Pk-Pk) value the same or different from the peak-to-peak voltage amplitude (Vpp) value you set at the function generator earlier? Describe how are they the same or different. Turn off the output of the function generator. Reminder: Press the Channel button then Output Off. Afterward, press the Output Load button (6.7-10) and change the setting to \"High-Z\". If you are using the 33220A, the High-Z setting is in Utility > Output Setting. Then change the amplitude of the Sine wave to 3 Vpp. Reminder: press \u201cParameters\u201d to access the settings. Keep the Offset and Phase at 0. Turn on the output of the function generator. You should now see a 3 V peak-to-peak signal on the oscilloscope. Adjust the voltage division knob (6.3-7) so the sine wave will fit into the screen again. Lab Question 9: What is the voltage divisor value used to achieve this? Then, count the number of voltage divisions or read from the measurement list to find the peak-to-peak voltage of the signal. How does your result compare to the result in the measurements list and to the output setting of the function generator? Read here for an explanation of why there's a difference in output value when using difference output mode. NOTE: Press the CH1 button (6.3-6) and ensure the \u201cCoupling\u201d setting on the oscilloscope at the lower left corner of the display is set as \u201cDC\u201d and the \u201cProbe\u201d setting at the lower right corner is selected as \u201c1X\u201d If not, correct them by pressing and selecting the respective settings and change them with the selector knob (6.3-3). The knob can be turned and pressed. Adjust the settings so that at least three but no more than ten periods are showing on the DSO display and at least four voltage divisions of peak-to-peak voltage. Change the output parameters of the function generator and repeat the scaling process so you are competent with manually scaling an oscilloscope. Lab Question 10: (During-Lab) Demostrate to the lab professor or instructor that you are competent in generating a wave signal from the function generator and manually scaling (non-using auto scale) the display of an oscilloscope to view such signal. Turn off the function generator and disconnect the alligator clips. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate you've completed the lab and written down all your observation. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 6 : Digital Storage Oscilloscope (DSO)"},{"location":"ses250/lab6/#lab-6-digital-storage-oscilloscope-dso","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab 6 : Digital Storage Oscilloscope (DSO)"},{"location":"ses250/lab6/#purpose","text":"To learn how to operate the function generator and digital storage oscilloscope (DSO)","title":"Purpose"},{"location":"ses250/lab6/#objectives","text":"Generate waveform using a function generator Measure waveform using a digital storage oscilloscope (DSO)","title":"Objectives"},{"location":"ses250/lab6/#important-rules-for-this-lab","text":"Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply and/or the function generator must be switched off before making any changes to the circuit.","title":"Important Rules for this Lab"},{"location":"ses250/lab6/#description","text":"","title":"Description"},{"location":"ses250/lab6/#function-generator","text":"A function generator is a piece of electronic test equipment or software used to generate different types of electrical waveforms over a wide range of frequencies. Some of the most common waveforms produced by the function generator are the sine wave, square wave, triangular wave, and sawtooth shapes. These waveforms can be either repetitive or single shots. Figure 6.1 Keysight 33500B Function Generator In the electronics lab, you will be using a Keysight 33500B (or similar) Function Generator. Its manual can be found here: Function Generator Manual Source: Wikipedia: Function Generator Reference Video: How to Use A KEYSIGHT E33220A Function Generator to Generate A Sine Wave","title":"Function Generator"},{"location":"ses250/lab6/#digital-storage-oscilloscope-dso","text":"An oscilloscope, or DSO (for the more modern digital storage oscilloscope), is a type of electronic test instrument that graphically displays varying signal voltages, usually as a calibrated two-dimensional plot of one or more signals as a function of time. The displayed waveform can then be analyzed for properties such as amplitude, frequency, rise time, time interval, distortion, and others. Originally, the calculation of these values required manually measuring the waveform against the scales built into the screen of the instrument. Modern digital instruments may calculate and display these properties directly. Figure 6.2 Keysight 33500B Function Generator In the electronics lab, you will be using a Keysight DSO-X 2002A (or similar) Digital Storage Oscilloscope. Its manual can be found here: DSO Manual Source: Wikipedia: Oscilloscope","title":"Digital Storage Oscilloscope (DSO)"},{"location":"ses250/lab6/#materials","text":"","title":"Materials"},{"location":"ses250/lab6/#preparation","text":"Lab Preparation Question: List 5 waveform that can be generated by the function generator used in this lab. Read through the lab manual and list the button(s) that you need to press to turn the output of the function generator on and off. In your own word, explain the difference between the 50\u03a9 and High-Z output mode of the function generator used in this lab.","title":"Preparation"},{"location":"ses250/lab6/#procedures","text":"Identify the Digital Oscilloscope at your workbench. Disconnect any cable plugged into it so it is as shown below. Figure 6.3 Turn on the oscilloscope with the power button (8.3-1) if it is not already on. Identify the two cables with a BNC connector beside the oscilloscope. Connect the BNC cables to the CH1 (8.3-4) and CH2 connectors of the oscilloscope as shown. Figure 6.4 Press the CH1 On/Off button (6.3-6) so CH1 is on (button lights up green). Press the CH2 On/Off button so CH2 is off (no light showing at the button). The bright lines on the DSO display the waveform of the signal as a function of time. When there is no signal, the waveform is a flat line. If you don't see a flat line, that means your DSO is displaying amplified electronic noise from the environment. Don't worry if you don't see a flat line for this step of the lab. Lab Question 1: How many signal line(s) (6.3-13, bright solid horizontal line) do you see on the display? What is the colour of the line(s)? Press the CH2 On/Off button to turn CH2 on (button lights up green) then press the Auto Scale button (6.3-9) again. Lab Question 2: How many signal line(s) do you see on the display? What is the colour of the line(s)? You can adjust the vertical position of those signal lines for measurement or display purposes. Turn the CH1 vertical position knob (6.3-5) until the CH1 signal line is reasonably lined up vertically centred on the display. Try changing the vertical position of the CH2 signal line as well. Afterward, line up both signal lines vertically centred on the display. One line will be on top of the other line. Modern DSOs are complex test instruments with a lot of functionality. It is a very useful tool once you understand how to use it. The more you use and play with the tool, the more familiar you'll get. Turn off CH2. Identify the Function Generator at your workbench. Disconnect any cable plug into it so it is as shown below. Figure 6.5 Identify the cable with a BNC connector beside the function generator and connect it to the Output of the function generator (6.5-3). Afterward, push the power button (6.5-1) to turn on the function generator. After the function generator is turned on, we'll set up a 1kHz Sine wave, press the Waveforms button (6.5-7) and select Sine waveform mode from button menus (6.5-2). Then press the Parameters button (6.5-8) and use the keypad, digit selector buttons (6.5-5), and the adjustment knob (8.5-6) to set the following: Frequency: 1.000 kHz ( Note: pay attention to the number of 0s in kHz You can adjust the Units as necessary.) Amplitude: 100.0 mVpp (default setting) Offset: 0.000 V (default setting) Phase: 0\u00b0 (default setting) Identify the cable connected to the function generator and the alligator clips at the end of the cable connected to CH1 of the oscilloscope. Connect the two red alligator clips together and connect the two black alligator clips together. WARNING: Ensure the exposed portion of the red alligator clip is NOT touching the exposed portion of the black alligator clip. Figure 6.6 Once the cables are connected and the waveform is set, push the channel button on the function generator (6.7-4) then turn the output to \u201cOn\u201d (6.7-9). Figure 6.7 You should now see some signal on the DSO. If not, push the Auto Scale button on the oscilloscope (8.3-9). You should see a waveform that is similar to that shown in the figure below. Figure 6.8 Turn the time division knob (6.3-12) and the horizontal position knob (6.3-11) a few ticks clockwise then counter-clockwise. Lab Question 3: What effect do the time division knob and the horizontal position knob have on the waveform? The grey-white vertical lines (6.8-2) on the oscilloscope chart are called time division lines and the top right of the display shows the time divisor (6.8-4). In the figure above, the time divisor is set to 200.0\u03bcs/ which means each time division line represents 200.0\u03bcs in the time domain. The are a total of 10 time divisions in the display. Lab Question 4: Find two peaks in the signal waveform then count the number of time divisions in each period of the sine wave. Afterward, calculate the frequency of the sine wave using: f = 1 / T where f is the frequency in [Hz] and T is the period in [s]. Does it agree with the output of the function generator? You can adjust the horizontal position of the sine wave with the horizontal position knob to help with counting if necessary. Change the output of the function generator to a different frequency such as 500Hz and another waveform such as square and triangle then see how it is displayed on the oscilloscope. Afterward, put the function generator back to a sine wave at 1kHz. Press the Measurement (Meas) button (6.3-8) on the oscilloscope. In the measurement menu that shows up, use the menu buttons (6.3-2) and menu selector knob (6.3-3) to clear all measurements with the Clear Meas option. Then, add Frequency (Freq) and peak-to-peak voltage (Pk-Pk) for measurement. Ensure the Source channel is set to 1 at the lower left corner of the menu. The two measurements should now show up in the measurement list on the right-hand side. If a mistake is made, press Clear Meas to remove a measurement. Lab Question 5: Does the frequency measurement agree with your calculation above? Turn the time division knob slowly so the waveform expands and compresses horizontally. Turn it from 10 periods to only a portion of the waveform shown. Lab Question 6: At what time divisor does the measurement starts to become invalid? How many periods of the waveform are shown when it becomes invalid? What comment can you make on how the oscilloscope calculates the freq measurement (in terms of the waveform required to be displayed on the screen)? The grey-white horizontal line (6.8-1) on the oscilloscope display is called a voltage division line and at the top left of the display shows the voltage divisor (6.8-3). In the figure above, 50.0mV/ means each line represents 50.0mV in the voltage range. The are a total of 8 voltage divisions in the display. Lab Question 7: Find the peak and the trough of the signal waveform. Count the number of voltage divisions from the peak to the trough of the sine wave then calculate the peak-to-peak voltage of the sine wave. Does it agree with the peak-to-peak voltage (Pk-Pk) value in the measurement list? Lab Question 8: Is this peak-to-peak voltage (Pk-Pk) value the same or different from the peak-to-peak voltage amplitude (Vpp) value you set at the function generator earlier? Describe how are they the same or different. Turn off the output of the function generator. Reminder: Press the Channel button then Output Off. Afterward, press the Output Load button (6.7-10) and change the setting to \"High-Z\". If you are using the 33220A, the High-Z setting is in Utility > Output Setting. Then change the amplitude of the Sine wave to 3 Vpp. Reminder: press \u201cParameters\u201d to access the settings. Keep the Offset and Phase at 0. Turn on the output of the function generator. You should now see a 3 V peak-to-peak signal on the oscilloscope. Adjust the voltage division knob (6.3-7) so the sine wave will fit into the screen again. Lab Question 9: What is the voltage divisor value used to achieve this? Then, count the number of voltage divisions or read from the measurement list to find the peak-to-peak voltage of the signal. How does your result compare to the result in the measurements list and to the output setting of the function generator? Read here for an explanation of why there's a difference in output value when using difference output mode. NOTE: Press the CH1 button (6.3-6) and ensure the \u201cCoupling\u201d setting on the oscilloscope at the lower left corner of the display is set as \u201cDC\u201d and the \u201cProbe\u201d setting at the lower right corner is selected as \u201c1X\u201d If not, correct them by pressing and selecting the respective settings and change them with the selector knob (6.3-3). The knob can be turned and pressed. Adjust the settings so that at least three but no more than ten periods are showing on the DSO display and at least four voltage divisions of peak-to-peak voltage. Change the output parameters of the function generator and repeat the scaling process so you are competent with manually scaling an oscilloscope. Lab Question 10: (During-Lab) Demostrate to the lab professor or instructor that you are competent in generating a wave signal from the function generator and manually scaling (non-using auto scale) the display of an oscilloscope to view such signal. Turn off the function generator and disconnect the alligator clips. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate you've completed the lab and written down all your observation. You might be asked to explain some of the concepts you've learned in this lab.","title":"Procedures"},{"location":"ses250/lab7/","text":"Lab 7 : Capacitor and RC Circuit Seneca Polytechnic SES250 Electromagnatics Purposes To understand the relationship between the voltage and capacitance of a capacitor To understand the discharging and charging of a capacitor Objectives Assemble electronic components onto a breadboard Measure the capacitance of a capacitor using a digital multimeter (DMM) Measure the response of an RC circuit using a Digital Storage Oscilloscope (DSO) Important Rules for this Lab Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit. Description Capacitor A capacitor is an electronic device for storing electrical energy, consisting of two conductors in close proximity and insulated from each other. A simple example of such a storage device is the parallel-plate capacitor. If positive charges with total charge +Q are deposited on one of the conductors and an equal amount of negative charge \u2212Q is deposited on the second conductor, the capacitor is said to have a charge Q. Source: Britannica: capacitor The capacitance of a parallel plate capacitor can be calculated using: C = {{\\epsilon_0 A} \\over {s}} where \\epsilon_0 is the permittivity in vacuum and have a value of \\epsilon_0 = {8.854 \\times 10^{-12} {Nm^2 \\over C^2}} , A is the area of the plates, and s is the distance between the plates. Similar to resistors, capacitors use special markings to indicate their values. Since the amount of area for markings on a capacitor is limited, there is also a set of rules for specifying the capacitance value of a capacitor. Manufacturers often use two separate lines for their capacitor markings and these have the following meanings: First line: capacitance (in pF or \u03bcF) [and tolerance (J=5%, K=10%, M=20%)] Second line: rated DC voltage [and code for the dielectric material] For a ceramic capacitor, often only a three-digit code is given. The first two digits correspond to the first two digits of the value whilst the third digit is a multiplier which gives the number of zeros to be added to give the value in pF. For example, 104 means 10 x 104 pF = 100nF. Furthermore, some capacitors such as electrolytic capacitors are marked with symbols (\u201c+\u201d and \u201c-\u201d) to indicate the correct polarity. Failure to observe these markings when connecting a capacitor to a circuit can be catastrophic! Figure 7.1 Various Capacitor Markings Figure 7.2 Non-polarized vs Polarized Capacitor Figure 7.3 Polarized Capacitor Leads Source: Capacitor Markings Source: What Is Non-polarized Capacitor Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Capacitance RC Circuit A resistor-capacitor circuit (RC circuit), RC filter or RC network, is an electric circuit composed of resistors and capacitors. It may be driven by a voltage or current source and these will produce different responses. A first-order RC circuit is composed of one resistor and one capacitor and is the simplest type of RC circuit. Figure 7.4 Series RC circuit A series RC circuit with a capacitor that is initially charged to V_0 = {Q_0 \\over C} and then allowed to discharge through a resistor R will exhibit the following relationship for the voltage across the capacitor over some time: V_C(t) = V_0 e^{(-{t \\over {RC}})} where V_0 is the capacitor voltage at t = 0 The time required for the voltage to fall to V_0 e^{-1} or about 37% (roughly 1/3 of V_0 ) is called the RC time constant and is given by: \\tau = RC where \\tau is measured in seconds, R in ohms and C in farads. The chart below shows a typical curve of the voltage across the capacitor during discharge in an RC circuit. Figure 7.5 Voltage curve of a capacitor during discharge in an RC circuit Source: Wikipedia: RC Circuit Light-emitting diode (LED) A light-emitting diode (LED) is a semiconductor device that emits light when current flows through it. Electrons in the semiconductor recombine with electron holes, releasing energy in the form of photons. The color of the light (corresponding to the energy of the photons) is determined by the energy required for electrons to cross the band gap of the semiconductor.White light is obtained by using multiple semiconductors or a layer of light-emitting phosphor on the semiconductor device. Figure 7.6 Left: The flat spot of the LED indicate the Cathode (-) lead. Right: LED Electronic Symbol. Source: Wikipedia: Light-emitting diode Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (1x) 1k\u03a9 Resistor (brown-black-red) (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100nF Ceramic Capacitor (usually orange with 104 marking) (1x) 10\u03bcF Electrolytic Capacitor (usually blue or black with 10\u03bcF marking) (1x) 100\u03bcF Electrolytic Capacitor (usually blue or black with 100\u03bcF marking) Preparation Lab Preparation Question: Read and summarize the lab as necessary. Copy observation tables 1, 2 and 3 of this lab into your notebook. Sketch a breadboard diagram of Figure 7.8 onto your notebook. Calculate the theoretical RC time constant (\u03c4) for each combination of R-C in Table 2. Calculate the voltage at \u03c4 if the initial voltage of an R-C circuit is 1V. Show all calculations. Derive the formula for the current through the resistor in an RC circuit. Procedures Part 1: Measuring Capacitance In this part of the lab, we will be exploring the capacitance of a capacitor. Turn on a DMM and set it to capacitance mode by pressing the SHIFT (1) + Freq (2) button (to access the -||- mode) then release. Ensure the alligator clips are connected to the terminals labelled \u201cHI\u201d under \u201cInput V\u03a9\u25ba|\u201d (3) and \u201cLO\u201d under \u201cInput V\u03a9\u25ba|\u201d (4). Figure 7.7 Lab Question 1: Without connecting the cable to anything, record the capacitance with the alligator clip not connected to anything. This is the capacitance due to just the cable (open circuit capacitance). Table 1 Capacitor # Cable Capacitance (\u03bcF) Marked C (\u03bcF) Measured C with Cable (\u03bcF) Measured C (\u03bcF) 1 2 3 Marked C (\u03bcF) = marking on the capacitor Measured C (\u03bcF) = Measured C with Cable (\u03bcF) - Cable Capacitance (\u03bcF) Acquire a 100nF Capacitor (usually small and orange with marking 104 for 10 x 10^4 pF) then connect the two leads of the capacitor to the DMM. Lab Question 2: Record the capacitance. Remember, this is the capacitance with the cable. Lab Question 3: Subtract the cable capacitance from the value to get the capacitor capacitance. Record this into the table 1. Acquire a 10\u03bcF Capacitor (usually round cylindrical with marking 10\u03bcF) then connect the two leads of the capacitor to the DMM per the polarity of the capacitor. The red clip is connected to the (+) lead and the black clip is connected to the (-) lead. INCORRECT CONNECTION AGAINST THE POLARIZATION OF THE CAPACITOR CAN BE CATASTROPHIC! Lab Question 4: Record the capacitance into the table 1. Repeat for a 100\u03bcF Capacitor. Disconnect the DMM and the capacitor. Part 2: RC Circuit In this part of the lab, we will be exploring the transient response (discharging and charging) of an RC circuit. A function generator set to square wave output will act as the closing and opening of the circuit. Figure 7.8 When the function generator's output is positive relative to the negative terminal (similar to the DC circuit below with the switch CLOSED), it is charging the capacitor. During this period, the voltage across the capacitor will raise to the same voltage as the output of the function generator. Figure 7.9 When the function generator's output is the same relative to the negative terminal (similar to the DC circuit below with the switch OPEN), no more current is supplied by the function generator. During this period, the voltage across the capacitor will drop as it is discharging by the series RC circuit with the LED. Figure 7.10 Obtain a 1k\u03a9 resistor, 10k\u03a9 resistors, a breadboard, a LED and a few jumper wires. You should also have the capacitor you worked with earlier. Lab Question 5: Measure the resistance value of your resistor and record it in Table 2. Refer to Lab 2 if you don't remember how to measure resistance. Copy your measured capacitor value from above and insert it into Table 2 as well. Table 2 Resistor Capacitor Measured R (k\u03a9) Measured C (\u03bcF) RC Constant (\u03c4) (ms) 1k\u03a9 10\u03bcF 1k\u03a9 100nF 10k\u03a9 100nF Lab Question 6: Calculate the RC time constant \u03c4 = RC for each of the configuration above. Set up your circuit as per Figure 7.8 using a 1k\u03a9 resistor and a 10\u03bcF capacitor on a breadboard with CH1 of the DSO measuring the voltage across the capacitor. Pay attention to the direction / polarity of the LED. The transient current through can only be estimated using the voltage across the capacitor in this configuration. However, the current can also be observed using the LED as it will light up when there are current. Additionally, the LED also act as a reverse current protection for the polarized capacitor. INCORRECT CONNECTION AGAINST THE POLARIZATION OF THE CAPACITOR CAN BE CATASTROPHIC! Turn on the function generator and set the output to High-Z output mode . Afterward, set the output to a 3Vpp square wave at 10Hz with a 3V DC Offset . Leave all other settings as default. Refer to Lab 6 if you don't remember how to use a function generator. Ensure the function generator is in High-Z mode and set to 3V DC offset Turn on the DSO and adjust the settings to zoom into the falling edge of the square wave so you'll see a single period of the RC waveform similar to Figure 7.5. Remember, the function generator is simulating the closing and opening of the circuit at 10Hz. Refer to Lab 6 if you don't remember how to use a function generator. Lab Question 7: Using the grid line or the measurement tool, find the time it takes for the voltage to drop 67% from the maximum and record it as the measured RC time constant. Table 3 Resistor Capacitor Calculated \u03c4 (ms) Measured \u03c4 (ms) % Error 1k\u03a9 10\u03bcF 1k\u03a9 100nF 10k\u03a9 100nF Lab Question 8: Calculate the percentage error of the estimated and measured RC time constant. Repeat step 2 with the various values of resistors and capacitors. Adjust the period (by adjust the frequency) of the function generator output so it is about 5-10x the RC time constant for best result in measurement. Lab Question 9: What do you observe regarding the RC time constant as the resistor and the capacitor value increase and decrease? Lab Question 10: What do you observe from the LED in term of the charging / discharging cycle of the capacitor? Remember, where there are current, the LED will turn on. DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 7 : Capacitor and RC Circuit"},{"location":"ses250/lab7/#lab-7-capacitor-and-rc-circuit","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab 7 : Capacitor and RC Circuit"},{"location":"ses250/lab7/#purposes","text":"To understand the relationship between the voltage and capacitance of a capacitor To understand the discharging and charging of a capacitor","title":"Purposes"},{"location":"ses250/lab7/#objectives","text":"Assemble electronic components onto a breadboard Measure the capacitance of a capacitor using a digital multimeter (DMM) Measure the response of an RC circuit using a Digital Storage Oscilloscope (DSO)","title":"Objectives"},{"location":"ses250/lab7/#important-rules-for-this-lab","text":"Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit.","title":"Important Rules for this Lab"},{"location":"ses250/lab7/#description","text":"","title":"Description"},{"location":"ses250/lab7/#capacitor","text":"A capacitor is an electronic device for storing electrical energy, consisting of two conductors in close proximity and insulated from each other. A simple example of such a storage device is the parallel-plate capacitor. If positive charges with total charge +Q are deposited on one of the conductors and an equal amount of negative charge \u2212Q is deposited on the second conductor, the capacitor is said to have a charge Q. Source: Britannica: capacitor The capacitance of a parallel plate capacitor can be calculated using: C = {{\\epsilon_0 A} \\over {s}} where \\epsilon_0 is the permittivity in vacuum and have a value of \\epsilon_0 = {8.854 \\times 10^{-12} {Nm^2 \\over C^2}} , A is the area of the plates, and s is the distance between the plates. Similar to resistors, capacitors use special markings to indicate their values. Since the amount of area for markings on a capacitor is limited, there is also a set of rules for specifying the capacitance value of a capacitor. Manufacturers often use two separate lines for their capacitor markings and these have the following meanings: First line: capacitance (in pF or \u03bcF) [and tolerance (J=5%, K=10%, M=20%)] Second line: rated DC voltage [and code for the dielectric material] For a ceramic capacitor, often only a three-digit code is given. The first two digits correspond to the first two digits of the value whilst the third digit is a multiplier which gives the number of zeros to be added to give the value in pF. For example, 104 means 10 x 104 pF = 100nF. Furthermore, some capacitors such as electrolytic capacitors are marked with symbols (\u201c+\u201d and \u201c-\u201d) to indicate the correct polarity. Failure to observe these markings when connecting a capacitor to a circuit can be catastrophic! Figure 7.1 Various Capacitor Markings Figure 7.2 Non-polarized vs Polarized Capacitor Figure 7.3 Polarized Capacitor Leads Source: Capacitor Markings Source: What Is Non-polarized Capacitor Reference Video: How to Use A KEYSIGHT E34461A DMM to Measure Capacitance","title":"Capacitor"},{"location":"ses250/lab7/#rc-circuit","text":"A resistor-capacitor circuit (RC circuit), RC filter or RC network, is an electric circuit composed of resistors and capacitors. It may be driven by a voltage or current source and these will produce different responses. A first-order RC circuit is composed of one resistor and one capacitor and is the simplest type of RC circuit. Figure 7.4 Series RC circuit A series RC circuit with a capacitor that is initially charged to V_0 = {Q_0 \\over C} and then allowed to discharge through a resistor R will exhibit the following relationship for the voltage across the capacitor over some time: V_C(t) = V_0 e^{(-{t \\over {RC}})} where V_0 is the capacitor voltage at t = 0 The time required for the voltage to fall to V_0 e^{-1} or about 37% (roughly 1/3 of V_0 ) is called the RC time constant and is given by: \\tau = RC where \\tau is measured in seconds, R in ohms and C in farads. The chart below shows a typical curve of the voltage across the capacitor during discharge in an RC circuit. Figure 7.5 Voltage curve of a capacitor during discharge in an RC circuit Source: Wikipedia: RC Circuit","title":"RC Circuit"},{"location":"ses250/lab7/#light-emitting-diode-led","text":"A light-emitting diode (LED) is a semiconductor device that emits light when current flows through it. Electrons in the semiconductor recombine with electron holes, releasing energy in the form of photons. The color of the light (corresponding to the energy of the photons) is determined by the energy required for electrons to cross the band gap of the semiconductor.White light is obtained by using multiple semiconductors or a layer of light-emitting phosphor on the semiconductor device. Figure 7.6 Left: The flat spot of the LED indicate the Cathode (-) lead. Right: LED Electronic Symbol. Source: Wikipedia: Light-emitting diode","title":"Light-emitting diode (LED)"},{"location":"ses250/lab7/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (1x) 1k\u03a9 Resistor (brown-black-red) (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100nF Ceramic Capacitor (usually orange with 104 marking) (1x) 10\u03bcF Electrolytic Capacitor (usually blue or black with 10\u03bcF marking) (1x) 100\u03bcF Electrolytic Capacitor (usually blue or black with 100\u03bcF marking)","title":"Materials"},{"location":"ses250/lab7/#preparation","text":"Lab Preparation Question: Read and summarize the lab as necessary. Copy observation tables 1, 2 and 3 of this lab into your notebook. Sketch a breadboard diagram of Figure 7.8 onto your notebook. Calculate the theoretical RC time constant (\u03c4) for each combination of R-C in Table 2. Calculate the voltage at \u03c4 if the initial voltage of an R-C circuit is 1V. Show all calculations. Derive the formula for the current through the resistor in an RC circuit.","title":"Preparation"},{"location":"ses250/lab7/#procedures","text":"","title":"Procedures"},{"location":"ses250/lab7/#part-1-measuring-capacitance","text":"In this part of the lab, we will be exploring the capacitance of a capacitor. Turn on a DMM and set it to capacitance mode by pressing the SHIFT (1) + Freq (2) button (to access the -||- mode) then release. Ensure the alligator clips are connected to the terminals labelled \u201cHI\u201d under \u201cInput V\u03a9\u25ba|\u201d (3) and \u201cLO\u201d under \u201cInput V\u03a9\u25ba|\u201d (4). Figure 7.7 Lab Question 1: Without connecting the cable to anything, record the capacitance with the alligator clip not connected to anything. This is the capacitance due to just the cable (open circuit capacitance). Table 1 Capacitor # Cable Capacitance (\u03bcF) Marked C (\u03bcF) Measured C with Cable (\u03bcF) Measured C (\u03bcF) 1 2 3 Marked C (\u03bcF) = marking on the capacitor Measured C (\u03bcF) = Measured C with Cable (\u03bcF) - Cable Capacitance (\u03bcF) Acquire a 100nF Capacitor (usually small and orange with marking 104 for 10 x 10^4 pF) then connect the two leads of the capacitor to the DMM. Lab Question 2: Record the capacitance. Remember, this is the capacitance with the cable. Lab Question 3: Subtract the cable capacitance from the value to get the capacitor capacitance. Record this into the table 1. Acquire a 10\u03bcF Capacitor (usually round cylindrical with marking 10\u03bcF) then connect the two leads of the capacitor to the DMM per the polarity of the capacitor. The red clip is connected to the (+) lead and the black clip is connected to the (-) lead. INCORRECT CONNECTION AGAINST THE POLARIZATION OF THE CAPACITOR CAN BE CATASTROPHIC! Lab Question 4: Record the capacitance into the table 1. Repeat for a 100\u03bcF Capacitor. Disconnect the DMM and the capacitor.","title":"Part 1: Measuring Capacitance"},{"location":"ses250/lab7/#part-2-rc-circuit","text":"In this part of the lab, we will be exploring the transient response (discharging and charging) of an RC circuit. A function generator set to square wave output will act as the closing and opening of the circuit. Figure 7.8 When the function generator's output is positive relative to the negative terminal (similar to the DC circuit below with the switch CLOSED), it is charging the capacitor. During this period, the voltage across the capacitor will raise to the same voltage as the output of the function generator. Figure 7.9 When the function generator's output is the same relative to the negative terminal (similar to the DC circuit below with the switch OPEN), no more current is supplied by the function generator. During this period, the voltage across the capacitor will drop as it is discharging by the series RC circuit with the LED. Figure 7.10 Obtain a 1k\u03a9 resistor, 10k\u03a9 resistors, a breadboard, a LED and a few jumper wires. You should also have the capacitor you worked with earlier. Lab Question 5: Measure the resistance value of your resistor and record it in Table 2. Refer to Lab 2 if you don't remember how to measure resistance. Copy your measured capacitor value from above and insert it into Table 2 as well. Table 2 Resistor Capacitor Measured R (k\u03a9) Measured C (\u03bcF) RC Constant (\u03c4) (ms) 1k\u03a9 10\u03bcF 1k\u03a9 100nF 10k\u03a9 100nF Lab Question 6: Calculate the RC time constant \u03c4 = RC for each of the configuration above. Set up your circuit as per Figure 7.8 using a 1k\u03a9 resistor and a 10\u03bcF capacitor on a breadboard with CH1 of the DSO measuring the voltage across the capacitor. Pay attention to the direction / polarity of the LED. The transient current through can only be estimated using the voltage across the capacitor in this configuration. However, the current can also be observed using the LED as it will light up when there are current. Additionally, the LED also act as a reverse current protection for the polarized capacitor. INCORRECT CONNECTION AGAINST THE POLARIZATION OF THE CAPACITOR CAN BE CATASTROPHIC! Turn on the function generator and set the output to High-Z output mode . Afterward, set the output to a 3Vpp square wave at 10Hz with a 3V DC Offset . Leave all other settings as default. Refer to Lab 6 if you don't remember how to use a function generator. Ensure the function generator is in High-Z mode and set to 3V DC offset Turn on the DSO and adjust the settings to zoom into the falling edge of the square wave so you'll see a single period of the RC waveform similar to Figure 7.5. Remember, the function generator is simulating the closing and opening of the circuit at 10Hz. Refer to Lab 6 if you don't remember how to use a function generator. Lab Question 7: Using the grid line or the measurement tool, find the time it takes for the voltage to drop 67% from the maximum and record it as the measured RC time constant. Table 3 Resistor Capacitor Calculated \u03c4 (ms) Measured \u03c4 (ms) % Error 1k\u03a9 10\u03bcF 1k\u03a9 100nF 10k\u03a9 100nF Lab Question 8: Calculate the percentage error of the estimated and measured RC time constant. Repeat step 2 with the various values of resistors and capacitors. Adjust the period (by adjust the frequency) of the function generator output so it is about 5-10x the RC time constant for best result in measurement. Lab Question 9: What do you observe regarding the RC time constant as the resistor and the capacitor value increase and decrease? Lab Question 10: What do you observe from the LED in term of the charging / discharging cycle of the capacitor? Remember, where there are current, the LED will turn on. DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Part 2: RC Circuit"},{"location":"ses250/lab8/","text":"Lab 8 : RL Circuit and Filters Seneca Polytechnic SES250 Electromagnatics Purposes To understand the relationship between the voltage and inductance of an inductor To understand the de-energize and energize of an inductor Objectives Assemble electronic components onto a breadboard Measure the response of an RL circuit using a Digital Storage Oscilloscope (DSO) Estimate the inductance of an inductor using its RL transient response Important Rules for this Lab Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit. Description Inductor An inductor, also called a coil, choke, or reactor, is a passive two-terminal electrical component that stores energy in a magnetic field when electric current flows through it. An inductor typically consists of an insulated wire wound into a coil. When the current flowing through the coil changes, the time-varying magnetic field induces an electromotive force (emf) (voltage) in the conductor, described by Faraday's law of induction. According to Lenz's law, the induced voltage has a polarity (direction) which opposes the change in current that created it. As a result, inductors oppose any changes in current through them. Figure 8.1 Inductors Source: Wikipedia: Inductor The inductance of a coil-type inductor can be calculated using: L = {{\\mu_0 \\pi N^2 R^2} \\over {l}} where: \\mu_0 is the permeability in vacuum and have a value of \\mu_0 = {4 \\pi \\times 10^{-7} {H \\over m}} N is the number of loops in the coil R is the radius of the coil l is the length of the coil (not the length of the wire) Similar to capacitors, the vast majority of inductors use written markings to indicate values, working current, and tolerance. The most usual method of marking ferrite-cored inductors involves quoting the value (in mH or \u03bcH), the tolerance (often either 5% or 10%), and the maximum working current (where appropriate). The marking scheme follows a similar convention to that used with small capacitors: First line: Inductance (in mH or \u03bcH) and tolerance (J=5%, K=10%, M=20%). Second line: rated d.c. current (where specified). A three-digit code is often used to mark small inductors. The first two digits correspond to the first two digits of the value whilst the third digit is a multiplier which gives the number of zeros to be added to give the value in \u03bcH. Figure 8.2 Various Inductor Markings Source: Inductor Markings RL Circuit A resistor\u2013inductor circuit (RL circuit), RL filter or RL network, is an electric circuit composed of resistors and inductors driven by a voltage or current source. A first-order RL circuit is composed of one resistor and one inductor, either in series driven by a voltage source or in parallel driven by a current source. It is one of the simplest analogue infinite impulse response electronic filters. Figure 8.3 Series RL circuit A series RL circuit with an inductor that is initially energized to I_0 = {V_in \\over R} and then allowed to de-energized through a resistor R will exhibit the following relationship for the current through the inductor over some time: I_L(t) = I_0 e^{(-{R \\over L} t)} where I_0 is the inductor current at t = 0 The time required for the current to fall to I_0 e^{-1} or about 37% (roughly 1/3 of I_0 ) is called the RL time constant and is given by: \\tau = {L \\over R} where \\tau is measured in seconds, R in ohms and L in henry. Since the current through an inductor is often difficult to measure directly, voltage measurements are often used to study the transient response of an RL circuit by using the following relationship: V_in(t) = V_L(t) + V_R(t) where: V_L(t) = V_0 e^{(-{R \\over L} t)} V_R(t) = V_0 ( 1 - e^{(-{R \\over L} t)} ) The chart below shows a typical curve of the voltage across the inductor and resistor during energizing in an RL circuit. Figure 8.4 Voltage curve of an inductor during energizing in an RL circuit Figure 8.5 Voltage curve of a resistor during energizing in an RL circuit Source: Wikipedia: RL Circuit Low-pass Filters A low-pass filter is a circuit offering easy passage to low-frequency signals and difficult passage to high-frequency signals. There are two basic kinds of circuits capable of accomplishing this objective, and many variations of each one: The inductive low-pass filter in (Figure 8.6 Left) and the capacitive low-pass filter in (Figure 8.6 Right). Figure 8.6 (Left) Inductive Low-Pass Filter, (Right) Capacitive Low-Pass Filter In an inductive low-pass filter, the inductor\u2019s impedance increases with increasing frequency. This high impedance in series tends to block high-frequency signals from getting to the load. In a capacitive low-pass filter, the capacitor\u2019s impedance decreases with increasing frequency. This low impedance tends to short out high-frequency signals, dropping most of the voltage across series resistor R. All low-pass filters are rated at a certain cutoff frequency. That is the frequency above which the output voltage falls below 70.7% of the input voltage. The cutoff frequency [Hz] for an inductive low-pass filter is: f_c = {R \\over {2 \\pi L}} The cutoff frequency [Hz] for a capacitive low-pass filter is: f_c = {1 \\over {2 \\pi R C}} Source: All About Circuits: Low-pass Filters Potentiometer A potentiometer is a three-terminal resistor with a sliding or rotating contact that forms an adjustable voltage divider.[1] If only two terminals are used, one end and the wiper, it acts as a variable resistor or rheostat. The measuring instrument called a potentiometer is essentially a voltage divider used for measuring electric potential (voltage); the component is an implementation of the same principle, hence its name. Figure 8.7 (Left) Potentiometer with leg indication, (Right) Potentiometer Electronics Symbol Source: Wikipedia: Potentiometer Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (1x) 100\u03a9 Resistor (brown-black-brown) (1x) 330\u03a9 Resistor (orange-orange-brown) (1x) 1k\u03a9 Resistor (brown-black-red) (1x) 4.7k\u03a9 resistor (yellow-violet-red) (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100\u03bcH drum inductor (1x) 10k\u03a9 Potentiometer (Blue Trimpot) Preparation Lab Preparation Question: Read and summarize the lab as necessary. Copy observation tables 1, and 2 of this lab into your notebook. Sketch three breadboard diagram, one for each of Figure 8.8, Figure 8.10 and Figure 8.12 onto your notebook. Derive a formula to find the inductance of an inductor from the RL response formula. If we need to reduce a 500kHz noise to at least 70.7% of it's original value with an RL low-pass filter. Which resistor from our lab material should we if you are using the 100\u03bcH inductor? Procedures Part 1: RL Circuit In this part of the lab, we will be exploring the transient response (de-energizing and energizing) of an RL circuit. A function generator set to square wave output will act as the closing and opening of the circuit. Figure 8.8 Obtain a 100\u03bcH inductor. The inductance of an inductor cannot be easily measured using the DMM we have in the lab. As a result, in addition to observing the RL response, you'll also be estimating the inductance of the inductor. Select a resistor value that will give you an RL time constant, \\tau = {L \\over R} , of about 1\u03bcs. You'll also need a breadboard and a few jumper wires. Lab Question 1: Measure the resistance value of your resistor and record it in Table 1. Refer to Lab 2 if you don't remember how to measure resistance. Table 1 Value Measured Resistance (R) [\u03a9] Marked Inductance (L) [H] Theoretical RL Constant ( \\tau = {L \\over R} ) [s] Measured \u03c4 [s] Estimated Inductance [H] % Error Inductance Lab Question 2: Calculate the theoretical RL time constant using the measured resistance value and the marked inductance value. Set up your circuit as per Figure 8.8 with CH1 of the DSO measuring the voltage across the inductor. The transient current through the inductor can only be estimated using the voltage across. Turn on the function generator and set the output to a 3Vpp square wave at 100kHz with a 3V DC Offset at High-Z output mode . Leave all other settings as default. Refer to Lab 6 if you don't remember how to use a function generator. Turn on the DSO and adjust the settings so you'll see a single period of the RL waveform similar to Figure 8.4. Remember, the function generator is simulating the closing and opening of the circuit at 100kHz. You should see something similar to Figure 8.8 below if you setup your circuit properly. If not, verify your connection. Refer to Lab 6 if you don't remember how to use a function generator. Figure 8.9 Series RL Circuit Voltage Curve: (Red) Voltage Source, (Black) Voltage Across Inductor Lab Question 3: Using the grid line or the measurement tool, find the time it takes for the voltage to drop 67% from the maximum and record it as the measured RL time constant. Lab Question 4: Estimate the inductance of the inductor using the equation you derived during the pre-lab. What is the # error between your estimated inductance and the marked inductance by the manufacturer? Part 2: RL Low-pass Filters In this part of the lab, we'll explore a simple filter circuit using a resistor and an inductor called an inductive low-pass filter. You'll be exploring another simple filter circuit called the capacitive low-pass filter as part of the course project. A triangular (saw) wave from a signal generator will be used to simulate noise. Figure 8.10 Using the 100\u03bcH inductor from Part 1, calculate the cutoff frequency for an inductive low-pass filter for the various resistor values in Table 2. Lab Question 5: Calculate the cutoff frequency for an inductive low-pass filter for various resistor values and record it in Table 2. Table 2 Resistor Value Cutoff Frequency 33\u03a9 50\u03a9 100\u03a9 Set up your circuit using a 10k\u03a9 as per Figure 8.10 with CH1 of the DSO measuring the voltage between the inductor and the resistor (the output of the RL low-pass filter) and CH2 connected to the output of the function generator (raw signal). Start from the largest resistor. Turn on the function generator and set the output to a 3Vpp triangular (saw with 50% symmetry) wave at 200kHz with a 3V DC Offset at High-Z output mode . Leave all other settings as default. Refer to Lab 6 if you don't remember how to use a function generator. This will simulate a signal at 1V with noise at 1MHz. Turn on the output of the function generator and observe the difference between the raw signal (3VDC 200kHz signal) and the filtered signal. You should see something (but not exactly) in Figure 8.11 with the centre at 3V instead of 0V. Figure 8.11 (Blue Line) Raw signal, (Orange Line) Filtered signal Take a photo or make a sketch of your observation then repeat for all the resistor values. Lab Question 6: At which resistor value do you start to see significant improvement in filtering out (smoothing off) the 1MHz noise? What is the cutoff frequency? Part 3: RL Low-pass Filters using Potentiometer Lastly, we are going to using a potentiometer so we can fine adjust the RL filter parameter. Set up your circuit using a 1k\u03a9 resistor, a 10k\u03a9 Potentiometer as per Figure 8.12 with CH1 and CH2 of the DSO measuring the voltage between the inductor and the resistor (the output of the RL low-pass filter) and CH2 connected to the output of the function generator (raw signal). Figure 8.12 Turn the potentiometer to see the filtering effect at various resistance value. DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 8 : RL Circuit and Filters"},{"location":"ses250/lab8/#lab-8-rl-circuit-and-filters","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab 8 : RL Circuit and Filters"},{"location":"ses250/lab8/#purposes","text":"To understand the relationship between the voltage and inductance of an inductor To understand the de-energize and energize of an inductor","title":"Purposes"},{"location":"ses250/lab8/#objectives","text":"Assemble electronic components onto a breadboard Measure the response of an RL circuit using a Digital Storage Oscilloscope (DSO) Estimate the inductance of an inductor using its RL transient response","title":"Objectives"},{"location":"ses250/lab8/#important-rules-for-this-lab","text":"Any signal (voltage, current) must be adjusted to the specified value (amplitude and/or frequency) before applying them to a circuit. An instrument must be set up for the required mode of operation before it is connected to a circuit. The power supply must be switched off before making any changes to the circuit.","title":"Important Rules for this Lab"},{"location":"ses250/lab8/#description","text":"","title":"Description"},{"location":"ses250/lab8/#inductor","text":"An inductor, also called a coil, choke, or reactor, is a passive two-terminal electrical component that stores energy in a magnetic field when electric current flows through it. An inductor typically consists of an insulated wire wound into a coil. When the current flowing through the coil changes, the time-varying magnetic field induces an electromotive force (emf) (voltage) in the conductor, described by Faraday's law of induction. According to Lenz's law, the induced voltage has a polarity (direction) which opposes the change in current that created it. As a result, inductors oppose any changes in current through them. Figure 8.1 Inductors Source: Wikipedia: Inductor The inductance of a coil-type inductor can be calculated using: L = {{\\mu_0 \\pi N^2 R^2} \\over {l}} where: \\mu_0 is the permeability in vacuum and have a value of \\mu_0 = {4 \\pi \\times 10^{-7} {H \\over m}} N is the number of loops in the coil R is the radius of the coil l is the length of the coil (not the length of the wire) Similar to capacitors, the vast majority of inductors use written markings to indicate values, working current, and tolerance. The most usual method of marking ferrite-cored inductors involves quoting the value (in mH or \u03bcH), the tolerance (often either 5% or 10%), and the maximum working current (where appropriate). The marking scheme follows a similar convention to that used with small capacitors: First line: Inductance (in mH or \u03bcH) and tolerance (J=5%, K=10%, M=20%). Second line: rated d.c. current (where specified). A three-digit code is often used to mark small inductors. The first two digits correspond to the first two digits of the value whilst the third digit is a multiplier which gives the number of zeros to be added to give the value in \u03bcH. Figure 8.2 Various Inductor Markings Source: Inductor Markings","title":"Inductor"},{"location":"ses250/lab8/#rl-circuit","text":"A resistor\u2013inductor circuit (RL circuit), RL filter or RL network, is an electric circuit composed of resistors and inductors driven by a voltage or current source. A first-order RL circuit is composed of one resistor and one inductor, either in series driven by a voltage source or in parallel driven by a current source. It is one of the simplest analogue infinite impulse response electronic filters. Figure 8.3 Series RL circuit A series RL circuit with an inductor that is initially energized to I_0 = {V_in \\over R} and then allowed to de-energized through a resistor R will exhibit the following relationship for the current through the inductor over some time: I_L(t) = I_0 e^{(-{R \\over L} t)} where I_0 is the inductor current at t = 0 The time required for the current to fall to I_0 e^{-1} or about 37% (roughly 1/3 of I_0 ) is called the RL time constant and is given by: \\tau = {L \\over R} where \\tau is measured in seconds, R in ohms and L in henry. Since the current through an inductor is often difficult to measure directly, voltage measurements are often used to study the transient response of an RL circuit by using the following relationship: V_in(t) = V_L(t) + V_R(t) where: V_L(t) = V_0 e^{(-{R \\over L} t)} V_R(t) = V_0 ( 1 - e^{(-{R \\over L} t)} ) The chart below shows a typical curve of the voltage across the inductor and resistor during energizing in an RL circuit. Figure 8.4 Voltage curve of an inductor during energizing in an RL circuit Figure 8.5 Voltage curve of a resistor during energizing in an RL circuit Source: Wikipedia: RL Circuit","title":"RL Circuit"},{"location":"ses250/lab8/#low-pass-filters","text":"A low-pass filter is a circuit offering easy passage to low-frequency signals and difficult passage to high-frequency signals. There are two basic kinds of circuits capable of accomplishing this objective, and many variations of each one: The inductive low-pass filter in (Figure 8.6 Left) and the capacitive low-pass filter in (Figure 8.6 Right). Figure 8.6 (Left) Inductive Low-Pass Filter, (Right) Capacitive Low-Pass Filter In an inductive low-pass filter, the inductor\u2019s impedance increases with increasing frequency. This high impedance in series tends to block high-frequency signals from getting to the load. In a capacitive low-pass filter, the capacitor\u2019s impedance decreases with increasing frequency. This low impedance tends to short out high-frequency signals, dropping most of the voltage across series resistor R. All low-pass filters are rated at a certain cutoff frequency. That is the frequency above which the output voltage falls below 70.7% of the input voltage. The cutoff frequency [Hz] for an inductive low-pass filter is: f_c = {R \\over {2 \\pi L}} The cutoff frequency [Hz] for a capacitive low-pass filter is: f_c = {1 \\over {2 \\pi R C}} Source: All About Circuits: Low-pass Filters","title":"Low-pass Filters"},{"location":"ses250/lab8/#potentiometer","text":"A potentiometer is a three-terminal resistor with a sliding or rotating contact that forms an adjustable voltage divider.[1] If only two terminals are used, one end and the wiper, it acts as a variable resistor or rheostat. The measuring instrument called a potentiometer is essentially a voltage divider used for measuring electric potential (voltage); the component is an implementation of the same principle, hence its name. Figure 8.7 (Left) Potentiometer with leg indication, (Right) Potentiometer Electronics Symbol Source: Wikipedia: Potentiometer","title":"Potentiometer"},{"location":"ses250/lab8/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (1x) 100\u03a9 Resistor (brown-black-brown) (1x) 330\u03a9 Resistor (orange-orange-brown) (1x) 1k\u03a9 Resistor (brown-black-red) (1x) 4.7k\u03a9 resistor (yellow-violet-red) (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100\u03bcH drum inductor (1x) 10k\u03a9 Potentiometer (Blue Trimpot)","title":"Materials"},{"location":"ses250/lab8/#preparation","text":"Lab Preparation Question: Read and summarize the lab as necessary. Copy observation tables 1, and 2 of this lab into your notebook. Sketch three breadboard diagram, one for each of Figure 8.8, Figure 8.10 and Figure 8.12 onto your notebook. Derive a formula to find the inductance of an inductor from the RL response formula. If we need to reduce a 500kHz noise to at least 70.7% of it's original value with an RL low-pass filter. Which resistor from our lab material should we if you are using the 100\u03bcH inductor?","title":"Preparation"},{"location":"ses250/lab8/#procedures","text":"","title":"Procedures"},{"location":"ses250/lab8/#part-1-rl-circuit","text":"In this part of the lab, we will be exploring the transient response (de-energizing and energizing) of an RL circuit. A function generator set to square wave output will act as the closing and opening of the circuit. Figure 8.8 Obtain a 100\u03bcH inductor. The inductance of an inductor cannot be easily measured using the DMM we have in the lab. As a result, in addition to observing the RL response, you'll also be estimating the inductance of the inductor. Select a resistor value that will give you an RL time constant, \\tau = {L \\over R} , of about 1\u03bcs. You'll also need a breadboard and a few jumper wires. Lab Question 1: Measure the resistance value of your resistor and record it in Table 1. Refer to Lab 2 if you don't remember how to measure resistance. Table 1 Value Measured Resistance (R) [\u03a9] Marked Inductance (L) [H] Theoretical RL Constant ( \\tau = {L \\over R} ) [s] Measured \u03c4 [s] Estimated Inductance [H] % Error Inductance Lab Question 2: Calculate the theoretical RL time constant using the measured resistance value and the marked inductance value. Set up your circuit as per Figure 8.8 with CH1 of the DSO measuring the voltage across the inductor. The transient current through the inductor can only be estimated using the voltage across. Turn on the function generator and set the output to a 3Vpp square wave at 100kHz with a 3V DC Offset at High-Z output mode . Leave all other settings as default. Refer to Lab 6 if you don't remember how to use a function generator. Turn on the DSO and adjust the settings so you'll see a single period of the RL waveform similar to Figure 8.4. Remember, the function generator is simulating the closing and opening of the circuit at 100kHz. You should see something similar to Figure 8.8 below if you setup your circuit properly. If not, verify your connection. Refer to Lab 6 if you don't remember how to use a function generator. Figure 8.9 Series RL Circuit Voltage Curve: (Red) Voltage Source, (Black) Voltage Across Inductor Lab Question 3: Using the grid line or the measurement tool, find the time it takes for the voltage to drop 67% from the maximum and record it as the measured RL time constant. Lab Question 4: Estimate the inductance of the inductor using the equation you derived during the pre-lab. What is the # error between your estimated inductance and the marked inductance by the manufacturer?","title":"Part 1: RL Circuit"},{"location":"ses250/lab8/#part-2-rl-low-pass-filters","text":"In this part of the lab, we'll explore a simple filter circuit using a resistor and an inductor called an inductive low-pass filter. You'll be exploring another simple filter circuit called the capacitive low-pass filter as part of the course project. A triangular (saw) wave from a signal generator will be used to simulate noise. Figure 8.10 Using the 100\u03bcH inductor from Part 1, calculate the cutoff frequency for an inductive low-pass filter for the various resistor values in Table 2. Lab Question 5: Calculate the cutoff frequency for an inductive low-pass filter for various resistor values and record it in Table 2. Table 2 Resistor Value Cutoff Frequency 33\u03a9 50\u03a9 100\u03a9 Set up your circuit using a 10k\u03a9 as per Figure 8.10 with CH1 of the DSO measuring the voltage between the inductor and the resistor (the output of the RL low-pass filter) and CH2 connected to the output of the function generator (raw signal). Start from the largest resistor. Turn on the function generator and set the output to a 3Vpp triangular (saw with 50% symmetry) wave at 200kHz with a 3V DC Offset at High-Z output mode . Leave all other settings as default. Refer to Lab 6 if you don't remember how to use a function generator. This will simulate a signal at 1V with noise at 1MHz. Turn on the output of the function generator and observe the difference between the raw signal (3VDC 200kHz signal) and the filtered signal. You should see something (but not exactly) in Figure 8.11 with the centre at 3V instead of 0V. Figure 8.11 (Blue Line) Raw signal, (Orange Line) Filtered signal Take a photo or make a sketch of your observation then repeat for all the resistor values. Lab Question 6: At which resistor value do you start to see significant improvement in filtering out (smoothing off) the 1MHz noise? What is the cutoff frequency?","title":"Part 2: RL Low-pass Filters"},{"location":"ses250/lab8/#part-3-rl-low-pass-filters-using-potentiometer","text":"Lastly, we are going to using a potentiometer so we can fine adjust the RL filter parameter. Set up your circuit using a 1k\u03a9 resistor, a 10k\u03a9 Potentiometer as per Figure 8.12 with CH1 and CH2 of the DSO measuring the voltage between the inductor and the resistor (the output of the RL low-pass filter) and CH2 connected to the output of the function generator (raw signal). Figure 8.12 Turn the potentiometer to see the filtering effect at various resistance value. DO NOT DISASSEMBLE YOUR CIRCUIT UNTIL YOUR LAB HAS BENN MARKED BY THE INSTRUCTOR. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Part 3: RL Low-pass Filters using Potentiometer"},{"location":"ses250/lab9/","text":"Lab 9 : RC and RL Circuit in AC Seneca Polytechnic SES250 Electromagnatics Purposes To understand the concept of frequency and period of an alternating current To observe the phase shift of an RC and RL circuit in AC Objectives Assemble electronic components onto a breadboard Setup function generator to output AC sine wave Measure the frequency and the period of a periodic signal using a Digital Storage Oscilloscope (DSO) Measure the phase shift of an RC and RL circuit using a DSO Description Alternating Current Alternating current (AC) is an electric current which periodically reverses direction and changes its magnitude continuously with time, in contrast to direct current (DC), which flows only in one direction. The usual waveform of alternating current in most electric power circuits is a sine wave, whose positive half-period corresponds with the positive direction of the current and vice versa (the full period is called a cycle). In certain applications, different waveforms are used, such as triangular waves or square waves. Figure 9.1 Various AC Waveforms. From Left to Right and Top to Bottom: Sine, Square, Sawtooth or Ramp, Triangular Source: Wikipedia: Alternating current Source: Circuit Digest: AC Circuit Theory (Part 2) Root Mean Square (RMS) For alternating electric current, RMS is equal to the value of the constant direct current that would produce the same power dissipation in a resistive load. Electrical engineers often need to know the power, P, dissipated by electrical resistance, R. It is easy to do the calculation when there is a constant current, I, through the resistance. However, if the current is a time-varying function, I(t), this formula must be extended to reflect the fact that the current (and thus the instantaneous power) is varying over time. If the function is periodic (such as household AC power), it is still meaningful to discuss the average power dissipated over time. When measuring AC using a DMM, oftentimes, you are not measuring the maximum amplitude of the current and voltage but 1 \\over \\sqrt{2} of the amplitude. This is the root-mean-square (rms) value of a sine waveform: V_{rms} and I_{rms} . V_{rms} = {V_0 \\over \\sqrt{2}} I_{rms} = {I_0 \\over \\sqrt{2}} Figure 9.2 AC Waveforms showing the difference between V_{rms} , V_{pk} = V_0 , and V_{pp} Source: Circuit Digest: RMS Voltage Note: Keep in mind that V_{rms} calculation uses V_{0} , not V_{pp} . RC Circuit Phase Shift A Capacitive Circuit that consists of R and C in series exhibits a timing difference between the peak amplitude of the current and voltage. This timing difference is called Phase Shift. As the Capacitor opposes a change in Voltage and stores energy from the Power Supply in the form of an Electric Field, the Capacitor Voltage V_{C} lags the Capacitor Current I_{C} by 90\u00b0 and lags the Power Supply Voltage V by a Phase Angle \\phi . This phase shift [RAD] between voltage and current can be calculated by: \\phi = tan^{-1} {\\left({-1} \\over {2 \\pi fRC}\\right)} where f is AC frequency in Hz, R in Ohms and C in Farads. Figure 9.3 V-I Relationship of the Series RC Circuit RL Circuit Phase Shift An Inductive Circuit that consists of R and L in series. As the Inductor opposes a change in Current and stores energy from the Power Supply in the form of a Magnetic Field, the Inductor Voltage V_{L} leads the Inductor Current I_{L} by 90\u00b0 and leads the Power Supply Voltage V by a Phase Angle \\phi . This phase shift [RAD] between voltage and current can be calculated by: \\phi = tan^{-1} {\\left({2 \\pi fL} \\over {R}\\right)} where f is AC frequency in Hz, R in Ohms and L in Henry. Figure 9.4 V-I Relationship of the Series RL Circuit Source: CMM: Phase Shift Reference Series RC Circuit Impedance Calculator Series RL Circuit Impedance Calculator Materials Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (1x) 100\u03a9 Resistor (brown-black-brown) (1x) 330\u03a9 Resistor (orange-orange-brown) (1x) 1k\u03a9 resistor (brown-black-red) (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100nF Ceramic Capacitor (1x) 100\u03bcH drum inductor Preparation Lab Preparation Question: Read and summarize the lab as necessary. Copy observation Tables 1, and 2 of this lab into your notebook. Sketch a breadboard diagram of Figure 9.5 and Figure 9.7 onto your notebook. Calculate the V_{rms} for a 3 V_{pp} (Not V_{0} ) sine signal. Calculate the phase difference [\u00b0] between voltage and current of an RC series circuit with a the following: 10k\u03a9 resistors and 100nF capacitor at 1kHz 1k\u03a9 resistors and 100nF capacitor at 1kHz 1k\u03a9 resistors and 100nF capacitor at 500Hz 10k\u03a9 resistors and 100nF capacitor at 500Hz Show all calculations and fill them into the Theoretical Phase Shift column of Table 1. Calculate the phase difference [\u00b0] between the voltage and current of an RL series circuit with a 100\u03a9, 330\u03a9 resistors, 100\u03bcH inductor, and at 100kHz and 200kHz. Show all calculations and fill them into the Theoretical Phase Shift column of Table 2. 100\u03a9 resistors and 100\u03bcH inductor at 100kHz 330\u03a9 resistors and 100\u03bcH inductor at 100kHz 330\u03a9 resistors and 100\u03bcH inductor at 200kHz 100\u03a9 resistors and 100\u03bcH inductor at 200kHz Show all calculations and fill them into the Theoretical Phase Shift column of Table 2. Procedures Part 1 : AC Waveform and RMS Voltage This part of the lab is to re-familiarize with generating a waveform using a function generator and AC measurement using an oscilloscope and a digital multimeter (DMM). Refer to Lab 6 if you don't remember how to use a function generator. Turn on the function generator, the DMM, and the oscilloscope. Ensure the function generator output is off. Set the function generator to High-Z output mode then set it to a 1kHz sine wave with 3Vpp as the amplitude. Leave DC offset and phase shift to zero (0). Connect the output of the function generator to CH1 of the oscilloscope. The red alligator clip of the function generator output should connect to the red alligator clip of the oscilloscope input and the same for the black alligator clip. Connect the DMM to the output of the function generator while keeping the oscilloscope connected. All three red clips connected togehter then three black connected together or use breadboard and jumper wires. Adjust the DSO so that about two periods are showing on the display. Make note of the TIME/DIV and VOLT/DIV and verify if align with the setting you provided to the function generator. Set up the DMM to measure in AC voltage mode (VAC). Lab Question 1: Does the reading from the DMM agree with the setting from the function generator and the DSO? Lab Question 2: Your DMM should give you a reading that is not 3V, why do you think that is the case? Turn off the output from the function generator. Part 2 : RC Circuit in AC The next part of this lab is to observe the AC response of an RC Circuit and the relationship between the voltage V(t) and the current I(t) using an oscilloscope. Since we cannot measure I(t) directly using an oscilloscope, we'll be measuring the voltage across the resistor V_R(t) since the current and voltage are always in phase at the resistor. Figure 9.5 Set up the circuit in Figure 9.7 using a 10k\u03a9 resistor and a 100nF ceramic capacitor. DO NOT USE A POLARIZED CAPACITOR! Ensure that the function generator\u2019s output is off then set the output of the function generator to High-Z . Set the output waveform to be a sine wave then set the output amplitude to 3 Vpp and the frequency to 1.00 kHz. Leave offset voltage and phase at 0. Turn on the oscilloscope then connect CH1 and CH2 to the circuit per the circuit diagram. NOTE: The ground (black cable) for both CH1 and CH2 is connected to the negative (black) node of the function generator. Turn on the function generator output and observe the relationship between CH1 and CH2. Adjust the voltage and time division to see about two periods on the display. You should see two waveforms ressembling V and V_R in Figure 9.3. From the two signals that you see, find a peak from CH1 (measuring V(t) ) and the closest peak from CH2 (measuring V_R(t) = I(t) ). CH2 ( I(t) ) should be leading CH1 ( V(t) ). Lab Question 3: Which signal is leading? Does it agree with what you expect from a series RC circuit? Lab Question 4: Find the time difference between the two signals. You may use the horizontal position knob to move one of the signals to the centre for easier measurement. Afterward, convert this time difference you found to the phase angle difference by using the formula below. Does it agree with the phase angle difference you calculated in your pre-lab? Write your result in Table 2. \\phi = 2 \\pi {\\Delta t \\over T} \\text{ or } \\phi = 360\u00b0 {\\Delta t \\over T} where \\Delta t is the time difference and T is the period. NOTE: I(t) leading means the time difference is a negative time. Also, the time difference might be in [ms] and the phase angle difference might be in [RAD] depending on your setting. Table 1: Freq R C Theoretical Phase Shift [\u00b0] Time Diff Phase Shift [\u00b0] 1 kHz 10 k\u03a9 100 nF 1 kHz 1 k\u03a9 100 nF 500 Hz 1 k\u03a9 100 nF 500 Hz 10 k\u03a9 100 nF Figure 9.6 Repeat the measurement with various resistor values and frequencies to complete Table 1 to understand their relationships. Part 3 : RL Circuit in AC The next part of this lab is to observe the AC response of an RL Circuit and the relationship between the voltage V(t) and the current I(t) using an oscilloscope. Since we cannot measure I(t) directly using an oscilloscope, we'll be measuring the voltage across the resistor V_R(t) since the current and voltage are always in phase at the resistor. Figure 9.7 Set up the circuit in Figure 9.6 using a 100 \u03a9 resistor and 100 \u03bcH. Ensure that the function generator\u2019s output is off then set the output of the function generator to High-Z . Set the output waveform to be a sine wave then set the output amplitude to 3 Vpp and the frequency to 100 kHz. Leave offset voltage and phase at 0. Turn on the oscilloscope then connect CH1 and CH2 to the circuit per the circuit diagram. NOTE: The ground (black cable) for both CH1 and CH2 is connected to the negative (black) node of the function generator. Turn on the function generator output and observe the relationship between CH1 and CH2. Adjust the voltage and time division to see about two periods on the display. You should see two waveforms ressembling V and V_R in Figure 9.4. From the two signals that you see, find a peak from CH1 (measuring V(t) ) and the closest peak from CH2 (measuring V_R(t) = I(t) ). CH2 ( I(t) ) should be lagging CH1 ( V(t) ). Lab Question 5: Which signal is leading? Does it agree with what you expect from a series RL circuit? Lab Question 6: Find the time difference between the two signals. You may use the horizontal position knob to move one of the signals to the centre for easier measurement. Afterward, convert this time difference you found to the phase angle difference by using the formula below. Does it agree with the phase angle difference you calculated in your pre-lab? Write your result in Table 2. \\phi = 2 \\pi {\\Delta t \\over T} \\text{ or } \\phi = 360\u00b0 {\\Delta t \\over T} NOTE: I(t) lagging means the time difference is a positive time. Also, the time difference might be in [ms] and the phase angle difference might be in [RAD] depending on your setting. Table 2: Freq R L Theoretical Phase Shift [\u00b0] Time Diff Phase Shift [\u00b0] 100 kHz 100 \u03a9 100 \u03bcH 100 kHz 330 \u03a9 100 \u03bcH 200 kHz 330 \u03a9 100 \u03bcH 200 kHz 100 \u03a9 100 \u03bcH Repeat the measurement with various resistor values and frequencies to complete Table 2 to understand their relationships. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Lab 9 : RC and RL Circuit in AC"},{"location":"ses250/lab9/#lab-9-rc-and-rl-circuit-in-ac","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab 9 : RC and RL Circuit in AC"},{"location":"ses250/lab9/#purposes","text":"To understand the concept of frequency and period of an alternating current To observe the phase shift of an RC and RL circuit in AC","title":"Purposes"},{"location":"ses250/lab9/#objectives","text":"Assemble electronic components onto a breadboard Setup function generator to output AC sine wave Measure the frequency and the period of a periodic signal using a Digital Storage Oscilloscope (DSO) Measure the phase shift of an RC and RL circuit using a DSO","title":"Objectives"},{"location":"ses250/lab9/#description","text":"","title":"Description"},{"location":"ses250/lab9/#alternating-current","text":"Alternating current (AC) is an electric current which periodically reverses direction and changes its magnitude continuously with time, in contrast to direct current (DC), which flows only in one direction. The usual waveform of alternating current in most electric power circuits is a sine wave, whose positive half-period corresponds with the positive direction of the current and vice versa (the full period is called a cycle). In certain applications, different waveforms are used, such as triangular waves or square waves. Figure 9.1 Various AC Waveforms. From Left to Right and Top to Bottom: Sine, Square, Sawtooth or Ramp, Triangular Source: Wikipedia: Alternating current Source: Circuit Digest: AC Circuit Theory (Part 2)","title":"Alternating Current"},{"location":"ses250/lab9/#root-mean-square-rms","text":"For alternating electric current, RMS is equal to the value of the constant direct current that would produce the same power dissipation in a resistive load. Electrical engineers often need to know the power, P, dissipated by electrical resistance, R. It is easy to do the calculation when there is a constant current, I, through the resistance. However, if the current is a time-varying function, I(t), this formula must be extended to reflect the fact that the current (and thus the instantaneous power) is varying over time. If the function is periodic (such as household AC power), it is still meaningful to discuss the average power dissipated over time. When measuring AC using a DMM, oftentimes, you are not measuring the maximum amplitude of the current and voltage but 1 \\over \\sqrt{2} of the amplitude. This is the root-mean-square (rms) value of a sine waveform: V_{rms} and I_{rms} . V_{rms} = {V_0 \\over \\sqrt{2}} I_{rms} = {I_0 \\over \\sqrt{2}} Figure 9.2 AC Waveforms showing the difference between V_{rms} , V_{pk} = V_0 , and V_{pp} Source: Circuit Digest: RMS Voltage Note: Keep in mind that V_{rms} calculation uses V_{0} , not V_{pp} .","title":"Root Mean Square (RMS)"},{"location":"ses250/lab9/#rc-circuit-phase-shift","text":"A Capacitive Circuit that consists of R and C in series exhibits a timing difference between the peak amplitude of the current and voltage. This timing difference is called Phase Shift. As the Capacitor opposes a change in Voltage and stores energy from the Power Supply in the form of an Electric Field, the Capacitor Voltage V_{C} lags the Capacitor Current I_{C} by 90\u00b0 and lags the Power Supply Voltage V by a Phase Angle \\phi . This phase shift [RAD] between voltage and current can be calculated by: \\phi = tan^{-1} {\\left({-1} \\over {2 \\pi fRC}\\right)} where f is AC frequency in Hz, R in Ohms and C in Farads. Figure 9.3 V-I Relationship of the Series RC Circuit","title":"RC Circuit Phase Shift"},{"location":"ses250/lab9/#rl-circuit-phase-shift","text":"An Inductive Circuit that consists of R and L in series. As the Inductor opposes a change in Current and stores energy from the Power Supply in the form of a Magnetic Field, the Inductor Voltage V_{L} leads the Inductor Current I_{L} by 90\u00b0 and leads the Power Supply Voltage V by a Phase Angle \\phi . This phase shift [RAD] between voltage and current can be calculated by: \\phi = tan^{-1} {\\left({2 \\pi fL} \\over {R}\\right)} where f is AC frequency in Hz, R in Ohms and L in Henry. Figure 9.4 V-I Relationship of the Series RL Circuit Source: CMM: Phase Shift","title":"RL Circuit Phase Shift"},{"location":"ses250/lab9/#reference","text":"Series RC Circuit Impedance Calculator Series RL Circuit Impedance Calculator","title":"Reference"},{"location":"ses250/lab9/#materials","text":"Safety glasses (PPE) Lab Supplies Breadboard Jumper Wires (1x) 100\u03a9 Resistor (brown-black-brown) (1x) 330\u03a9 Resistor (orange-orange-brown) (1x) 1k\u03a9 resistor (brown-black-red) (1x) 10k\u03a9 resistor (brown-black-orange) (1x) 100nF Ceramic Capacitor (1x) 100\u03bcH drum inductor","title":"Materials"},{"location":"ses250/lab9/#preparation","text":"Lab Preparation Question: Read and summarize the lab as necessary. Copy observation Tables 1, and 2 of this lab into your notebook. Sketch a breadboard diagram of Figure 9.5 and Figure 9.7 onto your notebook. Calculate the V_{rms} for a 3 V_{pp} (Not V_{0} ) sine signal. Calculate the phase difference [\u00b0] between voltage and current of an RC series circuit with a the following: 10k\u03a9 resistors and 100nF capacitor at 1kHz 1k\u03a9 resistors and 100nF capacitor at 1kHz 1k\u03a9 resistors and 100nF capacitor at 500Hz 10k\u03a9 resistors and 100nF capacitor at 500Hz Show all calculations and fill them into the Theoretical Phase Shift column of Table 1. Calculate the phase difference [\u00b0] between the voltage and current of an RL series circuit with a 100\u03a9, 330\u03a9 resistors, 100\u03bcH inductor, and at 100kHz and 200kHz. Show all calculations and fill them into the Theoretical Phase Shift column of Table 2. 100\u03a9 resistors and 100\u03bcH inductor at 100kHz 330\u03a9 resistors and 100\u03bcH inductor at 100kHz 330\u03a9 resistors and 100\u03bcH inductor at 200kHz 100\u03a9 resistors and 100\u03bcH inductor at 200kHz Show all calculations and fill them into the Theoretical Phase Shift column of Table 2.","title":"Preparation"},{"location":"ses250/lab9/#procedures","text":"","title":"Procedures"},{"location":"ses250/lab9/#part-1-ac-waveform-and-rms-voltage","text":"This part of the lab is to re-familiarize with generating a waveform using a function generator and AC measurement using an oscilloscope and a digital multimeter (DMM). Refer to Lab 6 if you don't remember how to use a function generator. Turn on the function generator, the DMM, and the oscilloscope. Ensure the function generator output is off. Set the function generator to High-Z output mode then set it to a 1kHz sine wave with 3Vpp as the amplitude. Leave DC offset and phase shift to zero (0). Connect the output of the function generator to CH1 of the oscilloscope. The red alligator clip of the function generator output should connect to the red alligator clip of the oscilloscope input and the same for the black alligator clip. Connect the DMM to the output of the function generator while keeping the oscilloscope connected. All three red clips connected togehter then three black connected together or use breadboard and jumper wires. Adjust the DSO so that about two periods are showing on the display. Make note of the TIME/DIV and VOLT/DIV and verify if align with the setting you provided to the function generator. Set up the DMM to measure in AC voltage mode (VAC). Lab Question 1: Does the reading from the DMM agree with the setting from the function generator and the DSO? Lab Question 2: Your DMM should give you a reading that is not 3V, why do you think that is the case? Turn off the output from the function generator.","title":"Part 1 : AC Waveform and RMS Voltage"},{"location":"ses250/lab9/#part-2-rc-circuit-in-ac","text":"The next part of this lab is to observe the AC response of an RC Circuit and the relationship between the voltage V(t) and the current I(t) using an oscilloscope. Since we cannot measure I(t) directly using an oscilloscope, we'll be measuring the voltage across the resistor V_R(t) since the current and voltage are always in phase at the resistor. Figure 9.5 Set up the circuit in Figure 9.7 using a 10k\u03a9 resistor and a 100nF ceramic capacitor. DO NOT USE A POLARIZED CAPACITOR! Ensure that the function generator\u2019s output is off then set the output of the function generator to High-Z . Set the output waveform to be a sine wave then set the output amplitude to 3 Vpp and the frequency to 1.00 kHz. Leave offset voltage and phase at 0. Turn on the oscilloscope then connect CH1 and CH2 to the circuit per the circuit diagram. NOTE: The ground (black cable) for both CH1 and CH2 is connected to the negative (black) node of the function generator. Turn on the function generator output and observe the relationship between CH1 and CH2. Adjust the voltage and time division to see about two periods on the display. You should see two waveforms ressembling V and V_R in Figure 9.3. From the two signals that you see, find a peak from CH1 (measuring V(t) ) and the closest peak from CH2 (measuring V_R(t) = I(t) ). CH2 ( I(t) ) should be leading CH1 ( V(t) ). Lab Question 3: Which signal is leading? Does it agree with what you expect from a series RC circuit? Lab Question 4: Find the time difference between the two signals. You may use the horizontal position knob to move one of the signals to the centre for easier measurement. Afterward, convert this time difference you found to the phase angle difference by using the formula below. Does it agree with the phase angle difference you calculated in your pre-lab? Write your result in Table 2. \\phi = 2 \\pi {\\Delta t \\over T} \\text{ or } \\phi = 360\u00b0 {\\Delta t \\over T} where \\Delta t is the time difference and T is the period. NOTE: I(t) leading means the time difference is a negative time. Also, the time difference might be in [ms] and the phase angle difference might be in [RAD] depending on your setting. Table 1: Freq R C Theoretical Phase Shift [\u00b0] Time Diff Phase Shift [\u00b0] 1 kHz 10 k\u03a9 100 nF 1 kHz 1 k\u03a9 100 nF 500 Hz 1 k\u03a9 100 nF 500 Hz 10 k\u03a9 100 nF Figure 9.6 Repeat the measurement with various resistor values and frequencies to complete Table 1 to understand their relationships.","title":"Part 2 : RC Circuit in AC"},{"location":"ses250/lab9/#part-3-rl-circuit-in-ac","text":"The next part of this lab is to observe the AC response of an RL Circuit and the relationship between the voltage V(t) and the current I(t) using an oscilloscope. Since we cannot measure I(t) directly using an oscilloscope, we'll be measuring the voltage across the resistor V_R(t) since the current and voltage are always in phase at the resistor. Figure 9.7 Set up the circuit in Figure 9.6 using a 100 \u03a9 resistor and 100 \u03bcH. Ensure that the function generator\u2019s output is off then set the output of the function generator to High-Z . Set the output waveform to be a sine wave then set the output amplitude to 3 Vpp and the frequency to 100 kHz. Leave offset voltage and phase at 0. Turn on the oscilloscope then connect CH1 and CH2 to the circuit per the circuit diagram. NOTE: The ground (black cable) for both CH1 and CH2 is connected to the negative (black) node of the function generator. Turn on the function generator output and observe the relationship between CH1 and CH2. Adjust the voltage and time division to see about two periods on the display. You should see two waveforms ressembling V and V_R in Figure 9.4. From the two signals that you see, find a peak from CH1 (measuring V(t) ) and the closest peak from CH2 (measuring V_R(t) = I(t) ). CH2 ( I(t) ) should be lagging CH1 ( V(t) ). Lab Question 5: Which signal is leading? Does it agree with what you expect from a series RL circuit? Lab Question 6: Find the time difference between the two signals. You may use the horizontal position knob to move one of the signals to the centre for easier measurement. Afterward, convert this time difference you found to the phase angle difference by using the formula below. Does it agree with the phase angle difference you calculated in your pre-lab? Write your result in Table 2. \\phi = 2 \\pi {\\Delta t \\over T} \\text{ or } \\phi = 360\u00b0 {\\Delta t \\over T} NOTE: I(t) lagging means the time difference is a positive time. Also, the time difference might be in [ms] and the phase angle difference might be in [RAD] depending on your setting. Table 2: Freq R L Theoretical Phase Shift [\u00b0] Time Diff Phase Shift [\u00b0] 100 kHz 100 \u03a9 100 \u03bcH 100 kHz 330 \u03a9 100 \u03bcH 200 kHz 330 \u03a9 100 \u03bcH 200 kHz 100 \u03a9 100 \u03bcH Repeat the measurement with various resistor values and frequencies to complete Table 2 to understand their relationships. Once you've completed all the above steps, ask the lab professor or instructor over and demostrate that you've completed the lab and written down all your observations. You might be asked to explain some of the concepts you've learned in this lab.","title":"Part 3 : RL Circuit in AC"},{"location":"ses250/safety/","text":"Lab Safety Seneca Polytechnic SES250 Electromagnatics Objectives Review of Laboratory First Aid and Safety Procedures Emergency Contact In case of life threatening emergency: Call 911 for fire, medical, or police Then call campus security: 416-764-0911 for assistance Laboratory First Aid and Safety Procedures Lab Safety Presentation Slides Lab WHMIS Training The following online WHMIS training module are to be completed by each student with the completion certificate submitted on blackboard before the end of Lab 1. Online WHMIS Training Module Access Guide Online WHMIS Training Module Link Lab Agreement The following Lab agreement are to be signed by each student and submitted on blackboard before the end of Lab 1. Lab Agreement","title":"Lab Safety"},{"location":"ses250/safety/#lab-safety","text":"Seneca Polytechnic SES250 Electromagnatics","title":"Lab Safety"},{"location":"ses250/safety/#objectives","text":"Review of Laboratory First Aid and Safety Procedures","title":"Objectives"},{"location":"ses250/safety/#emergency-contact","text":"In case of life threatening emergency: Call 911 for fire, medical, or police Then call campus security: 416-764-0911 for assistance","title":"Emergency Contact"},{"location":"ses250/safety/#laboratory-first-aid-and-safety-procedures","text":"Lab Safety Presentation Slides","title":"Laboratory First Aid and Safety Procedures"},{"location":"ses250/safety/#lab-whmis-training","text":"The following online WHMIS training module are to be completed by each student with the completion certificate submitted on blackboard before the end of Lab 1. Online WHMIS Training Module Access Guide Online WHMIS Training Module Link","title":"Lab WHMIS Training"},{"location":"ses250/safety/#lab-agreement","text":"The following Lab agreement are to be signed by each student and submitted on blackboard before the end of Lab 1. Lab Agreement","title":"Lab Agreement"},{"location":"ses250/supplies/","text":"Lab Supplies Seneca Polytechnic SES250 Electromagnatics You are not required to purchase the lab items from the store/supplier suggested here. You may purchase them from anywhere of your choice as long as they meet the lab requirement. Mandatory Items for SE250 Labs Safety Glasses The safety glasses must have side shields and a top shield. ( CCOHS Reference ) Where to Buy: A similar version can be purchased from the Seneca Campus Store: Temp Lite Series Clear Safety Glasses . Bound Lab Notebook Bound Notebook Ring Notebook Where to Buy: A similar version can be purchased from the Seneca Campus Store: Lab Notes 200 Pages . SES250 Lab Kit The following lab components are mandatory for you to brign to the lab for this course. They are common in the field of Electronics / Electrical Engineering and some of the components will be used in future courses. Also included on the list are some of the places you can purchase the items. They can also be purchased from other major online retailers but links will not be provided as their product listing is very dynamic. Item Canada Robotix DigiKey Sayal (1x) Full-size Breadboard Breadboard Breadboard Breadboard Kit (20x) Jumper Wires Wire Kit Jumper Wire Breadboard Kit (5x) 100\u03a9 1/4W 5% Resistor 5 pcs 100\u03a9 (5x) 330\u03a9 1/4W 5% Resistor 5 pcs 330\u03a9 10 pcs (5x) 1k\u03a9 1/4W 5% Resistor 5 pcs 1k\u03a9 10 pcs (5x) 4.7k\u03a9 1/4W 5% Resistor 5 pcs 4.7k\u03a9 10 pcs (5x) 10k\u03a9 1/4W 5% Resistor 5 pcs 10k\u03a9 10 pcs (2x) 0.1\u03bcF 50V 20% Ceramic Capacitor 5 pcs 0.1\u03bcF 2 pcs (2x) 10\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 10\u03bcF 2 pcs (2x) 100\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 100\u03bcF 2 pcs (1x) 100\u00b5H 1A 10% Inductor 2 pcs (Drum Coil) 100\u00b5H 2 pcs (Axial) (1x) Red 5mm LED 5pcs RED Led 5 pcs (1x) Potentiometer 10k\u03a9 with Knob 1 pc 10k\u03a9 POT 1 pc Canada Robotix has bundled the above components into a single kit: SES250 Lab Kit Other Optional Components Item Canada Robotix Creatron Sayal Alligator Leads 10 pcs 10 pcs 10 pcs","title":"Lab Supplies"},{"location":"ses250/supplies/#lab-supplies","text":"Seneca Polytechnic SES250 Electromagnatics You are not required to purchase the lab items from the store/supplier suggested here. You may purchase them from anywhere of your choice as long as they meet the lab requirement.","title":"Lab Supplies"},{"location":"ses250/supplies/#mandatory-items-for-se250-labs","text":"Safety Glasses The safety glasses must have side shields and a top shield. ( CCOHS Reference ) Where to Buy: A similar version can be purchased from the Seneca Campus Store: Temp Lite Series Clear Safety Glasses . Bound Lab Notebook Bound Notebook Ring Notebook Where to Buy: A similar version can be purchased from the Seneca Campus Store: Lab Notes 200 Pages .","title":"Mandatory Items for SE250 Labs"},{"location":"ses250/supplies/#ses250-lab-kit","text":"The following lab components are mandatory for you to brign to the lab for this course. They are common in the field of Electronics / Electrical Engineering and some of the components will be used in future courses. Also included on the list are some of the places you can purchase the items. They can also be purchased from other major online retailers but links will not be provided as their product listing is very dynamic. Item Canada Robotix DigiKey Sayal (1x) Full-size Breadboard Breadboard Breadboard Breadboard Kit (20x) Jumper Wires Wire Kit Jumper Wire Breadboard Kit (5x) 100\u03a9 1/4W 5% Resistor 5 pcs 100\u03a9 (5x) 330\u03a9 1/4W 5% Resistor 5 pcs 330\u03a9 10 pcs (5x) 1k\u03a9 1/4W 5% Resistor 5 pcs 1k\u03a9 10 pcs (5x) 4.7k\u03a9 1/4W 5% Resistor 5 pcs 4.7k\u03a9 10 pcs (5x) 10k\u03a9 1/4W 5% Resistor 5 pcs 10k\u03a9 10 pcs (2x) 0.1\u03bcF 50V 20% Ceramic Capacitor 5 pcs 0.1\u03bcF 2 pcs (2x) 10\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 10\u03bcF 2 pcs (2x) 100\u03bcF 50V 20% Electrolytic Capacitor 2 pcs 100\u03bcF 2 pcs (1x) 100\u00b5H 1A 10% Inductor 2 pcs (Drum Coil) 100\u00b5H 2 pcs (Axial) (1x) Red 5mm LED 5pcs RED Led 5 pcs (1x) Potentiometer 10k\u03a9 with Knob 1 pc 10k\u03a9 POT 1 pc Canada Robotix has bundled the above components into a single kit: SES250 Lab Kit","title":"SES250 Lab Kit"},{"location":"ses250/supplies/#other-optional-components","text":"Item Canada Robotix Creatron Sayal Alligator Leads 10 pcs 10 pcs 10 pcs","title":"Other Optional Components"}]}